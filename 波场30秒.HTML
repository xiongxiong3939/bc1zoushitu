<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>æ³¢åœº30ç§’èµ›è½¦ - å¼€å¥–ç³»ç»Ÿ (UTC+8)</title>

<!-- Excel å¯¼å‡ºåº“ï¼ˆç”¨äºèµ°åŠ¿å›¾å¯¼å‡ºï¼‰ -->
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

<style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #f4f7f9; margin: 0; }
    .container { max-width: 1200px; margin: 0 auto; }
    h2 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
    .box { 
        background: #fff; padding: 20px; margin-top: 20px;
        border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    input, button, select {
        padding: 10px; font-size: 16px;
        margin: 5px 0; border: 1px solid #ddd; border-radius: 4px;
    }
    button {
        background: #3498db; color: white; border: none;
        cursor: pointer; transition: background 0.3s;
    }
    button:hover { background: #2980b9; }
    button.secondary { background: #95a5a6; }
    button.secondary:hover { background: #7f8c8d; }
    button.success { background: #27ae60; }
    button.success:hover { background: #219653; }
    .result-box { 
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white; padding: 20px; border-radius: 10px;
        margin: 20px 0; text-align: center;
    }
    .numbers { 
        font-size: 28px; font-weight: bold; letter-spacing: 5px;
        margin: 15px 0; 
    }
    .loading { color: #e74c3c; font-weight: bold; margin: 10px 0; }
    .error { color: #e74c3c; background: #fdf2f2; padding: 10px; border-radius: 4px; }
    .success { color: #27ae60; background: #f0f9f4; padding: 10px; border-radius: 4px; }
    .warning { color: #f39c12; background: #fef9e7; padding: 10px; border-radius: 4px; }
    .hash-display { 
        background: #2c3e50; color: #ecf0f1; padding: 10px;
        border-radius: 5px; font-family: monospace; 
        word-break: break-all; margin: 10px 0; font-size: 12px;
    }
    .api-status { 
        padding: 10px; border-radius: 5px; margin: 10px 0;
        text-align: center; font-weight: bold;
    }
    .phase-item { 
        display: inline-block; margin: 10px 20px 10px 0;
        background: #f8f9fa; padding: 10px; border-radius: 5px;
        min-width: 150px;
    }
    .phase-label { font-size: 12px; color: #7f8c8d; }
    .phase-value { font-size: 18px; font-weight: bold; color: #2c3e50; }
    table { border-collapse: collapse; width: 100%; margin-top: 15px; }
    table, th, td { border: 1px solid #ddd; }
    th { background: #f8f9fa; padding: 12px; text-align: center; }
    td { padding: 10px; text-align: center; }
    .char-grid { 
        display: flex; flex-wrap: wrap; gap: 5px; margin: 15px 0;
        justify-content: center;
    }
    .char-item { 
        width: 40px; height: 40px; border-radius: 50%;
        display: flex; align-items: center; justify-content: center;
        font-weight: bold; font-size: 16px;
    }
    .char-hex { background: #e8f4fd; color: #3498db; border: 2px solid #3498db; }
    .char-digit { background: #d5f4e6; color: #27ae60; border: 2px solid #27ae60; }
    .timezone-info {
        background: #e8f4fd; padding: 8px 15px; border-radius: 5px;
        margin: 10px 0; border-left: 4px solid #3498db;
    }
    .utc8-badge {
        background: #e74c3c; color: white; padding: 2px 8px;
        border-radius: 3px; font-size: 12px; margin-left: 5px;
    }
    .red-button { 
        color: #ff0000 !important; 
        font-weight: bold;
    }
    .red-button:hover { 
        color: #ff0000 !important; 
        text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
    }
    .batch-form {
        display: grid;
        grid-template-columns: auto auto;
        gap: 10px;
        margin-bottom: 15px;
        align-items: center;
    }
    .batch-form label {
        font-weight: bold;
        margin-right: 5px;
    }
    .batch-form input[type="date"] {
        width: 150px;
    }
    .batch-form input[type="number"] {
        width: 80px;
    }

    /* ===== æ‰¹é‡æŸ¥è¯¢æ§åˆ¶é¢æ¿æ ·å¼ ===== */
    .batch-control-panel {
        background: #fff;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        border-left: 4px solid #3498db;
    }
    .batch-control-group {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        align-items: center;
        margin-bottom: 15px;
    }
    .batch-control-group label {
        font-weight: bold;
        color: #2c3e50;
        min-width: 120px;
    }
    .batch-control-panel select,
    .batch-control-panel input[type="number"],
    .batch-control-panel input[type="date"] {
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        min-width: 120px;
        font-size: 14px;
    }
    .batch-action-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin: 10px 0 0;
        justify-content: center;
    }
    .batch-action-buttons button {
        flex: 1;
        min-width: 150px;
        color: #ffffff !important;
        font-weight: bold;
        padding: 12px 15px;
        font-size: 16px;
    }
    .batch-action-buttons .stop-btn {
        background: #e74c3c !important;
    }
    .batch-action-buttons .stop-btn:hover {
        background: #c0392b !important;
    }
    .batch-action-buttons .export-btn {
        background: #27ae60 !important;
    }
    .batch-action-buttons .export-btn:hover {
        background: #219653 !important;
    }
    .batch-action-buttons .query-btn {
        background: #3498db !important;
    }
    .batch-action-buttons .query-btn:hover {
        background: #2980b9 !important;
    }
    
    .batch-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 15px;
        margin: 15px 0;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 5px;
    }
    .batch-stat-item {
        text-align: center;
        padding: 12px;
        background: white;
        border-radius: 5px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        border-top: 3px solid #3498db;
    }
    .batch-stat-value {
        font-size: 22px;
        font-weight: bold;
        color: #2c3e50;
        margin: 4px 0;
    }
    .batch-stat-label {
        font-size: 13px;
        color: #7f8c8d;
        text-transform: uppercase;
        font-weight: bold;
    }
    .batch-progress {
        margin: 15px 0;
        background: #f8f9fa;
        border-radius: 5px;
        padding: 15px;
        display: none;
    }
    .batch-progress-bar {
        height: 20px;
        background: #ecf0f1;
        border-radius: 10px;
        overflow: hidden;
        margin: 10px 0;
    }
    .batch-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #3498db, #2ecc71);
        border-radius: 10px;
        transition: width 0.3s ease;
        width: 0%;
    }
    .batch-progress-text {
        text-align: center;
        font-weight: bold;
        color: #2c3e50;
        margin-top: 5px;
    }
    
    /* ===== æ‰¹é‡ç»“æœå±•ç¤ºæ ·å¼ ===== */
    .batch-results-container {
        margin-top: 20px;
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 5px;
        background: #fff;
    }
    .batch-results-table {
        width: 100%;
        border-collapse: collapse;
    }
    .batch-results-table th {
        background: #2c3e50;
        color: white;
        padding: 12px 8px;
        position: sticky;
        top: 0;
        z-index: 10;
    }
    .batch-results-table td {
        padding: 10px 8px;
        border-bottom: 1px solid #eee;
    }
    .batch-results-table tr:nth-child(even) {
        background: #f8f9fa;
    }
    .batch-results-table tr:hover {
        background: #e8f4fd;
    }

    /* ===== IndexedDBæŒä¹…åŒ–æ§åˆ¶é¢æ¿ ===== */
    .persistence-panel {
        background: #fff;
        padding: 20px;
        border-radius: 8px;
        margin: 20px 0;
        box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        border-left: 4px solid #9b59b6;
    }
    .persistence-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }
    .persistence-header h3 {
        color: #2c3e50;
        margin: 0;
        display: flex;
        align-items: center;
    }
    .persistence-header h3:before {
        content: "ğŸ’¾";
        margin-right: 10px;
        font-size: 24px;
    }
    .persistence-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        align-items: center;
    }
    .persistence-switch-container {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    .switch-label {
        font-weight: bold;
        color: #2c3e50;
    }
    .switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 30px;
    }
    .switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: .4s;
        border-radius: 30px;
    }
    .slider:before {
        position: absolute;
        content: "";
        height: 22px;
        width: 22px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
    }
    input:checked + .slider {
        background-color: #9b59b6;
    }
    input:checked + .slider:before {
        transform: translateX(30px);
    }
    .persistence-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 15px;
        margin: 15px 0;
        padding: 15px;
        background: #f5f0f8;
        border-radius: 5px;
    }
    .persistence-stat-item {
        text-align: center;
        padding: 12px;
        background: white;
        border-radius: 5px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        border-top: 3px solid #9b59b6;
    }
    .persistence-stat-value {
        font-size: 22px;
        font-weight: bold;
        color: #2c3e50;
        margin: 4px 0;
    }
    .persistence-stat-label {
        font-size: 13px;
        color: #7f8c8d;
        text-transform: uppercase;
        font-weight: bold;
    }
    .db-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 15px;
    }
    .db-actions button {
        flex: 1;
        min-width: 150px;
        color: #ffffff !important;
        font-weight: bold;
        padding: 12px 15px;
        font-size: 14px;
    }
    .db-actions .clear-btn {
        background: #e74c3c !important;
    }
    .db-actions .clear-btn:hover {
        background: #c0392b !important;
    }
    .db-actions .export-btn {
        background: #27ae60 !important;
    }
    .db-actions .export-btn:hover {
        background: #219653 !important;
    }
    .db-actions .load-btn {
        background: #3498db !important;
    }
    .db-actions .load-btn:hover {
        background: #2980b9 !important;
    }

    /* ===== æ‰¹é‡èµ°åŠ¿å›¾æ§åˆ¶é¢æ¿ & ç»Ÿè®¡æ ·å¼ ===== */
    .control-panel {
        background:#fff;
        padding:20px;
        border-radius:8px;
        margin-bottom:20px;
        box-shadow:0 2px 10px rgba(0,0,0,0.05);
    }
    .control-group {
        display:flex;
        flex-wrap:wrap;
        gap:15px;
        align-items:center;
        margin-bottom:15px;
    }
    .control-group label {
        font-weight:bold;
        color:#2c3e50;
    }
    .control-panel select,
    .control-panel input[type="number"] {
        padding:8px 12px;
        border:1px solid #ddd;
        border-radius:4px;
        min-width:120px;
        font-size:14px;
    }
    .action-buttons {
        display:flex;
        flex-wrap:wrap;
        gap:10px;
        margin:10px 0 0;
    }
    .action-buttons button {
        flex:1;
        min-width:150px;
        color:#ffffff !important;
    }
    .pagination-controls {
        margin: 15px 0;
        display: flex;
        align-items: center;
        gap: 10px;
        justify-content: center;
        padding:10px 15px;
        background:#f8f9fa;
        border-radius:5px;
    }
    .pagination-info {
        font-weight: bold;
        color: #333;
        font-size:14px;
    }
    .stats-panel {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
        margin: 15px 0;
        padding: 15px;
        background: #e8f4fd;
        border-radius: 5px;
        border-left: 4px solid #3498db;
    }
    .stat-item {
        text-align: center;
        padding: 10px;
        background: white;
        border-radius: 5px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    }
    .stat-value {
        font-size: 20px;
        font-weight: bold;
        color: #2c3e50;
        margin: 4px 0;
    }
    .stat-label {
        font-size: 12px;
        color: #7f8c8d;
        text-transform: uppercase;
    }
    .data-preview {
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 10px;
        margin: 15px 0;
        background: #f8f9fa;
    }
    .data-row {
        padding: 4px 0;
        border-bottom: 1px solid #eee;
        font-family: monospace;
        font-size: 12px;
    }
    .data-row:last-child {
        border-bottom: none;
    }
    .export-btn {
        background: #27ae60 !important;
    }
    .export-btn:hover {
        background: #219653 !important;
    }

    /* ===== èµ°åŠ¿å›¾è¡¨æ ¼æ ·å¼ ===== */
    .trend-container {
        margin-top: 10px;
        background: #fff;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .trend-title {
        text-align: center;
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 10px;
        color: #2c3e50;
    }
    .trend-combined-container {
        display: flex;
        flex-wrap: nowrap;
        gap: 0;
        overflow-x: auto;
        margin-bottom: 10px;
        padding: 5px;
        background:#f8f9fa;
        border-radius:5px;
    }
    .trend-combined-wrapper {
        position: relative;
        flex: 0 0 auto;
        min-width:260px;
        border-right: 1px solid #ddd;
    }
    .trend-combined-wrapper:last-child { border-right:none; }
    .trend-combined-wrapper:not(:first-child) table thead tr:first-child th:nth-child(-n+2),
    .trend-combined-wrapper:not(:first-child) table tbody tr td:nth-child(-n+2) {
        display:none;
    }
    .trend-table {
        border-collapse: collapse;
        background: #fff;
        position: relative;
        z-index: 2;
        font-size: 10px;
        width: 100%;
    }
    .trend-table th,
    .trend-table td {
        border: 1px solid #ddd;
        width: 22px;
        height: 22px;
        text-align: center;
        position: relative;
        padding: 0;
    }
    .trend-table th {
        background: #f8f9fa;
        font-weight: bold;
        color: #2c3e50;
    }
    .trend-lottery-num {
        width: 70px;
        font-weight: bold;
        font-size:9px;
        padding: 0 2px;
    }

    /* ===== å¼€å¥–å·ç å½©è‰²æ–¹å—æ ·å¼ï¼ˆæ‰å¹³åŒ–ã€åœ†è§’ã€å°å°ºå¯¸ï¼Œä¿æŒè¡Œé«˜ä¸å˜ï¼‰ ===== */
    .lottery-block-container {
        display: flex;
        gap: 4px;
        justify-content: center;
        align-items: center;
        height: 18px; /* ä¿è¯ä¸è¶…è¿‡å•å…ƒæ ¼é«˜åº¦ï¼ˆ22pxï¼‰ */
    }
    .lottery-block {
        width: 18px;
        height: 18px;
        border-radius: 4px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: bold;
        color: #ffffff;
        line-height: 1;
        box-shadow: none; /* æ‰å¹³åŒ– */
    }
    .lottery-block.num-empty {
        background: #f0f0f0;
        color: #666;
        border: 1px solid #e6e6e6;
    }
    .lottery-block.num-1 { background:#ff4d4d; }
    .lottery-block.num-2 { background:#4d7fff; }
    .lottery-block.num-3 { background:#4dff7f; color:#333; }
    .lottery-block.num-4 { background:#ffcc4d; color:#333; }
    .lottery-block.num-5 { background:#cc4dff; }
    .lottery-block.num-6 { background:#ffa07a; }
    .lottery-block.num-7 { background:#7fffd4; color:#333; }
    .lottery-block.num-8 { background:#87cefa; }
    .lottery-block.num-9 { background:#da70d6; }
    .lottery-block.num-10 { background:#ffa500; }
    .tpos-1,.tpos-2,.tpos-3,.tpos-4,.tpos-5,
    .tpos-6,.tpos-7,.tpos-8,.tpos-9,.tpos-10{
      border-radius:50%;
      font-weight:bold;
      width:20px;
      height:20px;
      margin:0 auto;
      line-height:20px;
      color:#fff;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:9px;
    }
    .tpos-1{background:#ff4d4d;}
    .tpos-2{background:#4d7fff;}
    .tpos-3{background:#4dff7f;color:#333;}
    .tpos-4{background:#ffcc4d;color:#333;}
    .tpos-5{background:#cc4dff;}
    .tpos-6{background:#ffa07a;}
    .tpos-7{background:#7fffd4;color:#333;}
    .tpos-8{background:#87cefa;}
    .tpos-9{background:#da70d6;}
    .tpos-10{background:#ffa500;}
    .tmiss{
        background:#f8f8f8;
        color:#666;
        font-weight:bold;
        font-size:9px;
    }
    .trend-combined-wrapper[data-pos="1"]  .trend-table tbody tr td:nth-child(n+3) { background-color: #fff5f5; }
    .trend-combined-wrapper[data-pos="2"]  .trend-table tbody tr td:nth-child(n+3) { background-color: #f5f9ff; }
    .trend-combined-wrapper[data-pos="3"]  .trend-table tbody tr td:nth-child(n+3) { background-color: #f5fff5; }
    .trend-combined-wrapper[data-pos="4"]  .trend-table tbody tr td:nth-child(n+3) { background-color: #fffef5; }
    .trend-combined-wrapper[data-pos="5"]  .trend-table tbody tr td:nth-child(n+3) { background-color: #faf5ff; }
    .trend-combined-wrapper[data-pos="6"]  .trend-table tbody tr td:nth-child(n+3) { background-color: #fff6f0; }
    .trend-combined-wrapper[data-pos="7"]  .trend-table tbody tr td:nth-child(n+3) { background-color: #f0fffb; }
    .trend-combined-wrapper[data-pos="8"]  .trend-table tbody tr td:nth-child(n+3) { background-color: #f0f7ff; }
    .trend-combined-wrapper[data-pos="9"]  .trend-table tbody tr td:nth-child(n+3) { background-color: #fff0ff; }
    .trend-combined-wrapper[data-pos="10"] .trend-table tbody tr td:nth-child(n+3) { background-color: #fff7ec; }
    .trend-combined-wrapper[data-pos="1"]  .tpos-1  { background-color: #ff4d4d !important; }
    .trend-combined-wrapper[data-pos="2"]  .tpos-2  { background-color: #4d7fff !important; }
    .trend-combined-wrapper[data-pos="3"]  .tpos-3  { background-color: #4dff7f !important; color:#333; }
    .trend-combined-wrapper[data-pos="4"]  .tpos-4  { background-color: #ffcc4d !important; color:#333; }
    .trend-combined-wrapper[data-pos="5"]  .tpos-5  { background-color: #cc4dff !important; }
    .trend-combined-wrapper[data-pos="6"]  .tpos-6  { background-color: #ffa07a !important; }
    .trend-combined-wrapper[data-pos="7"]  .tpos-7  { background-color: #7fffd4 !important; color:#333; }
    .trend-combined-wrapper[data-pos="8"]  .tpos-8  { background-color: #87cefa !important; }
    .trend-combined-wrapper[data-pos="9"]  .tpos-9  { background-color: #da70d6 !important; }
    .trend-combined-wrapper[data-pos="10"] .tpos-10 { background-color: #ffa500 !important; }
    .trend-svg {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 3;
        pointer-events: none;
    }

    /* æ–°å¢è‡ªåŠ¨å¼€å¥–å¼€å…³æ ·å¼ */
    .auto-switch-container {
        display: flex;
        align-items: center;
        margin: 15px 0;
        padding: 12px 15px;
        background: #f8f9fa;
        border-radius: 8px;
        border-left: 4px solid #3498db;
    }
    .switch-label {
        font-weight: bold;
        color: #2c3e50;
        margin-right: 15px;
        font-size: 16px;
    }
    .switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 30px;
        margin-right: 15px;
    }
    .switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: .4s;
        border-radius: 30px;
    }
    .slider:before {
        position: absolute;
        content: "";
        height: 22px;
        width: 22px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
    }
    input:checked + .slider {
        background-color: #27ae60;
    }
    input:checked + .slider:before {
        transform: translateX(30px);
    }
    .auto-status {
        padding: 5px 10px;
        border-radius: 4px;
        font-weight: bold;
        font-size: 14px;
    }
    .auto-status.on {
        background: #d5f4e6;
        color: #27ae60;
    }
    .auto-status.off {
        background: #fdf2f2;
        color: #e74c3c;
    }
    .auto-info {
        margin-left: auto;
        font-size: 12px;
        color: #7f8c8d;
        max-width: 300px;
    }
    .countdown {
        font-size: 14px;
        font-weight: bold;
        color: #e74c3c;
        margin-left: 10px;
        min-width: 80px;
    }
    
    /* èµ°åŠ¿å›¾è‡ªåŠ¨æ›´æ–°çŠ¶æ€ */
    .trend-auto-update-status {
        margin: 10px 0;
        padding: 10px;
        background: #f0f9f4;
        border-radius: 5px;
        border-left: 4px solid #27ae60;
        display: none;
    }
    
    /* å¤±è´¥æŸ¥è¯¢æŒ‰é’®æ ·å¼ */
    .retry-btn {
        background: #e74c3c !important;
        color: white !important;
        border: none;
        padding: 5px 10px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        font-weight: bold;
    }
    .retry-btn:hover {
        background: #c0392b !important;
    }
    .retry-btn:disabled {
        background: #95a5a6 !important;
        cursor: not-allowed;
    }
    
    /* è‡ªåŠ¨å¼€å¥–çŠ¶æ€è¯¦æƒ… */
    .auto-draw-details {
        background: #f8f9fa;
        padding: 12px 15px;
        border-radius: 5px;
        margin: 10px 0;
        font-size: 14px;
    }
    .auto-draw-details strong {
        color: #2c3e50;
    }
    .auto-draw-details span {
        color: #e74c3c;
        font-weight: bold;
    }
</style>
</head>

<body>
<div class="container">
    <h2>æ³¢åœº30ç§’èµ›è½¦ - å¼€å¥–ç³»ç»Ÿ (UTC+8æ—¶åŒº)</h2>
    
    <!-- IndexedDBæŒä¹…åŒ–æ§åˆ¶é¢æ¿ -->
    <div class="persistence-panel">
        <div class="persistence-header">
            <h3>ğŸ’¾ æ•°æ®æŒä¹…åŒ–è®¾ç½® (IndexedDB)</h3>
            <div class="persistence-controls">
                <div class="persistence-switch-container">
                    <span class="switch-label">æŒä¹…åŒ–å­˜å‚¨ï¼š</span>
                    <label class="switch">
                        <input type="checkbox" id="persistenceSwitch" onchange="togglePersistence()">
                        <span class="slider"></span>
                    </label>
                    <div id="persistenceStatus" class="auto-status off">å…³é—­</div>
                </div>
                <div id="dbStatus" style="padding:5px 10px; background:#e8f4fd; border-radius:4px; font-size:12px;">
                    æ•°æ®åº“çŠ¶æ€ï¼šæœªåˆå§‹åŒ–
                </div>
            </div>
        </div>
        
        <div class="persistence-stats" id="dbStatsPanel">
            <div class="persistence-stat-item">
                <div class="persistence-stat-label">æ‰¹é‡æŸ¥è¯¢ç»“æœ</div>
                <div class="persistence-stat-value" id="statBatchCount">0</div>
                <div style="font-size:11px; color:#7f8c8d;">è®°å½•æ•°</div>
            </div>
            <div class="persistence-stat-item">
                <div class="persistence-stat-label">è‡ªåŠ¨å¼€å¥–è®°å½•</div>
                <div class="persistence-stat-value" id="statAutoDrawCount">0</div>
                <div style="font-size:11px; color:#7f8c8d;">è®°å½•æ•°</div>
            </div>
            <div class="persistence-stat-item">
                <div class="persistence-stat-label">èµ°åŠ¿å›¾æ•°æ®</div>
                <div class="persistence-stat-value" id="statTrendCount">0</div>
                <div style="font-size:11px; color:#7f8c8d;">è®°å½•æ•°</div>
            </div>
            <div class="persistence-stat-item">
                <div class="persistence-stat-label">è‡ªåŠ¨ä¸‹æ³¨è®°å½•</div>
                <div class="persistence-stat-value" id="statBettingCount">0</div>
                <div style="font-size:11px; color:#7f8c8d;">è®°å½•æ•°</div>
            </div>
            <div class="persistence-stat-item">
                <div class="persistence-stat-label">å­˜å‚¨æ€»å¤§å°</div>
                <div class="persistence-stat-value" id="statTotalSize">0 KB</div>
                <div style="font-size:11px; color:#7f8c8d;">å ç”¨ç©ºé—´</div>
            </div>
        </div>
        
        <div class="db-actions">
            <button onclick="loadAllDataFromDB()" class="load-btn">ğŸ“¥ ä»æ•°æ®åº“åŠ è½½æ‰€æœ‰æ•°æ®</button>
            <button onclick="exportAllDataToExcel()" class="export-btn">ğŸ“¤ å¯¼å‡ºæ•°æ®åº“åˆ°Excel</button>
            <button onclick="clearDatabase()" class="clear-btn">ğŸ—‘ï¸ æ¸…ç©ºæ•°æ®åº“</button>
            <button onclick="showDBInfo()" class="secondary">â„¹ï¸ æ•°æ®åº“ä¿¡æ¯</button>
        </div>
        
        <div class="db-actions" style="margin-top:10px;">
            <button onclick="clearBatchResults()" class="clear-btn" style="background:#e74c3c !important;">ğŸ—‘ï¸ æ¸…ç©ºæ‰¹é‡æŸ¥è¯¢ç»“æœæ•°æ®</button>
            <button onclick="clearAutoDrawResults()" class="clear-btn" style="background:#e74c3c !important;">ğŸ—‘ï¸ æ¸…ç©ºè‡ªåŠ¨å¼€å¥–è®°å½•æ•°æ®</button>
            <button onclick="clearTrendData()" class="clear-btn" style="background:#e74c3c !important;">ğŸ—‘ï¸ æ¸…ç©ºèµ°åŠ¿å›¾æ•°æ®</button>
            <button onclick="clearBettingRecords()" class="clear-btn" style="background:#e74c3c !important;">ğŸ—‘ï¸ æ¸…ç©ºè‡ªåŠ¨ä¸‹æ³¨è®°å½•æ•°æ®</button>
        </div>
        
        <div id="dbInfo" style="margin-top:15px; padding:10px; background:#f8f9fa; border-radius:5px; display:none;">
            <strong>ğŸ’¡ æŒä¹…åŒ–å­˜å‚¨è¯´æ˜ï¼š</strong>
            <ul style="margin:5px 0; padding-left:20px;">
                <li><strong>æ‰¹é‡æŸ¥è¯¢ç»“æœï¼š</strong>æ°¸ä¹…ä¿å­˜ï¼Œä¸ä¼šè¿‡æœŸ</li>
                <li><strong>è‡ªåŠ¨å¼€å¥–è®°å½•ï¼š</strong>è‡ªåŠ¨ç´¯ç§¯ï¼Œä¸ä¼šä¸¢å¤±</li>
                <li><strong>èµ°åŠ¿å›¾æ•°æ®ï¼š</strong>æŒä¹…ä¿å­˜ï¼Œé¡µé¢åˆ·æ–°åä»å­˜åœ¨</li>
                <li><strong>åŒºå—ç¼“å­˜ï¼š</strong>ä»ä½¿ç”¨localStorageï¼Œ5åˆ†é’Ÿè¿‡æœŸ</li>
                <li><strong>æ•°æ®å®‰å…¨ï¼š</strong>æ‰€æœ‰æ•°æ®å­˜å‚¨åœ¨æµè§ˆå™¨æœ¬åœ°ï¼Œä¸ä¼šä¸Šä¼ åˆ°æœåŠ¡å™¨</li>
            </ul>
        </div>
    </div>
    
    <!-- APIçŠ¶æ€å’Œé…ç½® -->
    <div class="box">
        <h3>ğŸ”§ TRON API é…ç½®</h3>
        <div class="phase-item">
            <div class="phase-label">API ç‰ˆæœ¬</div>
            <div class="phase-value">TronScan</div>
        </div>
        <div class="phase-item">
            <div class="phase-label">ç½‘ç»œ</div>
            <div class="phase-value">TRON ä¸»ç½‘</div>
        </div>
        <div class="phase-item">
            <div class="phase-label">API Key çŠ¶æ€</div>
            <div class="phase-value" id="apiStatus">æœªæ£€æµ‹</div>
        </div>
        
        <button onclick="checkV2APIStatus()" class="success red-button" style="margin-top:10px;">æ£€æµ‹ TRON API çŠ¶æ€</button>
        <button onclick="clearAPICache()" class="secondary" style="margin-left:10px;">æ¸…é™¤ç¼“å­˜</button>
        
        <div class="info-box" style="margin-top:15px; padding:10px; background:#e8f4fd; border-radius:5px;">
            <strong>ğŸ“Œ æ—¶åŒºè¯´æ˜ï¼š</strong>
            <ul style="margin:5px 0; padding-left:20px;">
                <li><strong>ç•Œé¢æ˜¾ç¤ºï¼š</strong>æ‰€æœ‰æ—¶é—´ä¸ºUTC+8ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰</li>
                <li><strong>å¼€å¥–è®¡ç®—ï¼š</strong>åŸºäºUTCæ—¶é—´ï¼ˆæ³¢åœºåŒºå—æ—¶é—´ï¼‰</li>
                <li><strong>æœŸå·è§„åˆ™ï¼š</strong>UTC+8æ¯å¤©00:00:33ä¸ºç¬¬ä¸€æœŸï¼ˆæ ¼å¼ï¼šYYYYMMDD0001ï¼‰</li>
                <li><strong>è·¨å¤©è§„åˆ™ï¼š</strong>ç¬¬2880æœŸè·¨å¤©åˆ°ç¬¬äºŒå¤©00:00:03ï¼ŒæœŸå·ä¸­çš„æ—¥æœŸä¿æŒå‰ä¸€å¤©</li>
                <li><strong>å¼€å¥–é—´éš”ï¼š</strong>æ¯30ç§’å¼€å¥–ä¸€æ¬¡ï¼Œæ¯å¤©å…±2880æœŸ</li>
            </ul>
        </div>
    </div>
    
    <!-- å•æœŸæŸ¥è¯¢ -->
    <div class="box">
        <h3>ğŸ“Œ å•æœŸå¼€å¥–æŸ¥è¯¢ï¼ˆTRON åŒºå—çœŸå®æ•°æ®ï¼‰</h3>
        
        <!-- æ–°å¢è‡ªåŠ¨å¼€å¥–å¼€å…³ -->
        <div class="auto-switch-container">
            <div class="switch-label">è‡ªåŠ¨å¼€å¥–å¼€å…³ï¼š</div>
            <label class="switch">
                <input type="checkbox" id="autoSwitch" onchange="toggleAutoDraw()">
                <span class="slider"></span>
            </label>
            <div id="autoStatus" class="auto-status off">æœªå¼€å¯</div>
            <div class="countdown" id="countdown">--:--</div>
            <div class="auto-info">
                å¼€å¯åè‡ªåŠ¨è·å–å½“å‰æœŸå¼€å¥–ä¿¡æ¯ï¼Œæ¯æœŸå¼€å¥–å3ç§’å¼€å§‹æŸ¥è¯¢ï¼ŒæŸ¥è¯¢åˆ°å½“æœŸä¿¡æ¯åˆ™åœæ­¢
            </div>
        </div>
        
        <!-- è‡ªåŠ¨å¼€å¥–çŠ¶æ€è¯¦æƒ… -->
        <div id="autoDrawDetails" class="auto-draw-details" style="display:none;">
            <strong>ğŸ”„ è‡ªåŠ¨å¼€å¥–çŠ¶æ€ï¼š</strong>
            <span id="autoDrawCurrentPhase">--</span> |
            <span id="autoDrawNextTime">ä¸‹ä¸€æœŸå¼€å¥–: --:--</span> |
            <span id="autoDrawRetryCount">é‡è¯•: 0æ¬¡</span>
        </div>
        
        <div style="display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px;">
            <div class="phase-item">
                <div class="phase-label">å½“å‰ UTC æ—¶é—´</div>
                <div class="phase-value" id="currentUTC">--:--:--</div>
            </div>
            <div class="phase-item">
                <div class="phase-label">å½“å‰ UTC+8 æ—¶é—´</div>
                <div class="phase-value" id="currentUTC8">--:--:--</div>
            </div>
            <div class="phase-item">
                <div class="phase-label">UTC+8å½“å‰æœŸå·</div>
                <div class="phase-value" id="currentPhaseUTC8">--</div>
            </div>
            <div class="phase-item">
                <div class="phase-label">UTC+8ä¸‹ä¸€æœŸå¼€å¥–</div>
                <div class="phase-value" id="nextDrawUTC8">--:--</div>
            </div>
        </div>
        
        <div class="timezone-info">
            <strong>ğŸ“… UTC+8 æŸ¥è¯¢å‚æ•°</strong> <span class="utc8-badge">UTC+8</span>
            <p style="margin:5px 0 0 0; font-size:14px;">
                æ¯å¤©ç¬¬ä¸€æœŸï¼š00:00:33 UTC+8 | æ¯30ç§’ä¸€æœŸ | æ¯å¤©2880æœŸ | æœŸå·æ ¼å¼ï¼šYYYYMMDD0001<br>
                ç¬¬2880æœŸè·¨å¤©åˆ°ç¬¬äºŒå¤©00:00:03ï¼ŒæœŸå·ä¸­çš„æ—¥æœŸä¿æŒå‰ä¸€å¤©<br>
                æ—¶é—´åˆ’åˆ†ï¼š00:00:00-00:00:32ä¸ºå‰ä¸€å¤©ç¬¬2880æœŸï¼Œ00:00:33ä¸ºå½“å¤©ç¬¬1æœŸ
            </p>
        </div>
        
        <label>é€‰æ‹©æ—¥æœŸ <span class="utc8-badge">UTC+8</span>ï¼š</label>
        <input id="queryDateUTC8" type="date" style="width:200px; margin:0 10px 10px 0;">
        
        <label>è¾“å…¥æœŸå· <span class="utc8-badge">UTC+8</span>ï¼ˆ1~2880ï¼‰ï¼š</label>
        <input id="qihaoUTC8" type="number" min="1" max="2880" style="width:100px; margin:0 10px 10px 0;" value="100">
        
        <button onclick="querySingleWithV2API()">æŸ¥è¯¢å¼€å¥–ç»“æœ</button>
        <button onclick="queryCurrentWithV2API()" class="success red-button" style="margin-left:10px;">æŸ¥è¯¢å½“å‰æœŸ</button>
        
        <div id="singleLoading" class="loading"></div>
        <div id="singleResult"></div>
    </div>
    
    <!-- æ‰¹é‡æŸ¥è¯¢ -->
    <div class="box">
        <h3>ğŸ“Š æ‰¹é‡æŸ¥è¯¢ï¼ˆè¿ç»­æŸ¥è¯¢æ¨¡å¼ï¼‰</h3>
        <div class="warning">
            <strong>æ³¨æ„ï¼š</strong>æ‰¹é‡æŸ¥è¯¢ä¼šå¿«é€Ÿæ¶ˆè€—APIè°ƒç”¨æ¬¡æ•°ã€‚å»ºè®®å…ˆæµ‹è¯•å°èŒƒå›´æŸ¥è¯¢ã€‚
        </div>
        
        <!-- æ‰¹é‡æŸ¥è¯¢æ§åˆ¶é¢æ¿ -->
        <div class="batch-control-panel">
            <div class="batch-control-group">
                <label>å¼€å§‹æ—¥æœŸ <span class="utc8-badge">UTC+8</span>ï¼š</label>
                <input id="batchStartDateUTC8" type="date">
                
                <label>å¼€å§‹æœŸå· <span class="utc8-badge">UTC+8</span>ï¼š</label>
                <input id="batchStartPhase" type="number" min="1" max="2880" placeholder="å¼€å§‹æœŸå·" value="100">
            </div>
            
            <div class="batch-control-group">
                <label>ç»“æŸæ—¥æœŸ <span class="utc8-badge">UTC+8</span>ï¼š</label>
                <input id="batchEndDateUTC8" type="date">
                
                <label>ç»“æŸæœŸå· <span class="utc8-badge">UTC+8</span>ï¼š</label>
                <input id="batchEndPhase" type="number" min="1" max="2880" placeholder="ç»“æŸæœŸå·" value="105">
            </div>
            
            <!-- è¿›åº¦æ¡ -->
            <div id="batchProgress" class="batch-progress">
                <div class="batch-progress-bar">
                    <div class="batch-progress-fill" id="batchProgressFill"></div>
                </div>
                <div class="batch-progress-text" id="batchProgressText">0%</div>
            </div>
            
            <!-- ç»Ÿè®¡ä¿¡æ¯ -->
            <div id="batchStats" class="batch-stats" style="display:none;">
                <div class="batch-stat-item">
                    <div class="batch-stat-label">æŸ¥è¯¢æ€»æ•°</div>
                    <div class="batch-stat-value" id="statTotal">0</div>
                </div>
                <div class="batch-stat-item">
                    <div class="batch-stat-label">æˆåŠŸæŸ¥è¯¢</div>
                    <div class="batch-stat-value" id="statSuccess">0</div>
                </div>
                <div class="batch-stat-item">
                    <div class="batch-stat-label">å¤±è´¥æŸ¥è¯¢</div>
                    <div class="batch-stat-value" id="statFailed">0</div>
                </div>
                <div class="batch-stat-item">
                    <div class="batch-stat-label">å®Œæˆè¿›åº¦</div>
                    <div class="batch-stat-value" id="statProgress">0%</div>
                </div>
            </div>
            
            <!-- æ“ä½œæŒ‰é’® -->
            <div class="batch-action-buttons">
                <button onclick="testV2API()" class="query-btn">å¼€å§‹è¿ç»­æŸ¥è¯¢</button>
                <button onclick="stopBatchQuery()" class="stop-btn" id="stopBatchBtn" style="display:none;">åœæ­¢æŸ¥è¯¢</button>
                <button onclick="exportBatchResultsToExcel()" class="export-btn" id="exportBatchBtn" style="display:none;">å¯¼å‡ºExcel</button>
            </div>
        </div>
        
        <!-- æ‰¹é‡ç»“æœå±•ç¤º -->
        <div id="batchResultsContainer" class="batch-results-container" style="display:none;">
            <table class="batch-results-table">
                <thead>
                    <tr>
                        <th>åºå·</th>
                        <th>æ—¥æœŸ</th>
                        <th>æœŸå·</th>
                        <th>å¼€å¥–æ—¶é—´</th>
                        <th>å¼€å¥–å·ç </th>
                        <th>ç¬¬1å</th>
                        <th>ç¬¬2å</th>
                        <th>ç¬¬3å</th>
                        <th>ç¬¬4å</th>
                        <th>ç¬¬5å</th>
                        <th>ç¬¬6å</th>
                        <th>ç¬¬7å</th>
                        <th>ç¬¬8å</th>
                        <th>ç¬¬9å</th>
                        <th>ç¬¬10å</th>
                        <th>çŠ¶æ€</th>
                    </tr>
                </thead>
                <tbody id="batchResultsBody">
                </tbody>
            </table>
        </div>
        
        <div id="batchLoading" class="loading"></div>
        <div id="batchResult"></div>
    </div>

    <!-- æ‰¹é‡ç»“æœèµ°åŠ¿å›¾æ¨¡å— -->
    <div class="box" id="trendBox" style="margin-top:20px;">
        <h3>ğŸ“ˆ æ‰¹é‡ç»“æœèµ°åŠ¿å›¾ & åˆ†æ</h3>
        
        <!-- èµ°åŠ¿å›¾è‡ªåŠ¨æ›´æ–°çŠ¶æ€ -->
        <div id="trendAutoUpdateStatus" class="trend-auto-update-status">
            <strong>ğŸ”„ èµ°åŠ¿å›¾è‡ªåŠ¨æ›´æ–°å·²å¯ç”¨</strong>
            <p style="margin:5px 0 0 0; font-size:14px;">
                èµ°åŠ¿å›¾å°†éšç€è‡ªåŠ¨å¼€å¥–ç»“æœå®æ—¶æ›´æ–°ã€‚å½“è‡ªåŠ¨å¼€å¥–å¼€å…³æ‰“å¼€æ—¶ï¼Œæ–°å¼€å¥–æ•°æ®ä¼šè‡ªåŠ¨æ·»åŠ åˆ°èµ°åŠ¿å›¾ä¸­ã€‚
            </p>
        </div>

        <!-- æ§åˆ¶é¢æ¿ -->
        <div class="control-panel">
            <div class="control-group">
                <label>æ¯é¡µæ˜¾ç¤ºæœŸæ•°ï¼š</label>
                <select id="trendPageSizeSelect" onchange="trendUpdatePageSize()">
                    <option value="30">30æœŸ</option>
                    <option value="50">50æœŸ</option>
                    <option value="100" selected>100æœŸ</option>
                    <option value="200">200æœŸ</option>
                    <option value="300">300æœŸ</option>
                    <option value="500">500æœŸ</option>
                </select>

                <label>èµ°åŠ¿å›¾ç±»å‹ï¼š</label>
                <select id="trendChartTypeSelect">
                    <option value="basic" selected>åŸºæœ¬èµ°åŠ¿å›¾</option>
                    <option value="trend">è¶‹åŠ¿åˆ†æå›¾ï¼ˆå¸¦è¿çº¿ï¼‰</option>
                    <option value="miss">é—æ¼é‡ç‚¹å›¾</option>
                </select>

                <label>æ˜¾ç¤ºä½ç½®ï¼š</label>
                <select id="trendDisplayModeSelect">
                    <option value="all">å…¨éƒ¨10ä¸ªä½ç½®</option>
                    <option value="top3" selected>å‰3å</option>
                    <option value="top5">å‰5å</option>
                </select>
            </div>

            <div class="control-group">
                <label>æ•°æ®æ¥æºï¼š</label>
                <label style="font-weight:normal; margin-right:10px;">
                    <input type="radio" name="trendSource" value="batch" checked
                           onclick="trendSetSource('batch')">
                    æ‰¹é‡æŸ¥è¯¢ç»“æœ
                </label>
                <label style="font-weight:normal; margin-right:10px;">
                    <input type="radio" name="trendSource" value="file"
                           onclick="trendSetSource('file')">
                    æ–‡ä»¶å¯¼å…¥ (Excel/CSV)
                </label>
                <label style="font-weight:normal; margin-right:10px;">
                    <input type="radio" name="trendSource" value="db"
                           onclick="trendSetSource('db')">
                    æ•°æ®åº“åŠ è½½
                </label>

                <input type="file"
                       id="trendFileInput"
                       accept=".xlsx,.xls,.csv"
                       style="margin-left:15px; display:none;"
                       onchange="trendHandleFileUpload(event)">
            </div>

            <div class="action-buttons" style="display:grid; grid-template-columns:repeat(5, 1fr); gap:10px; margin-bottom:10px;">
                <button class="success" onclick="loadBatchIntoTrend()">ä»æ‰¹é‡ç»“æœåŠ è½½æ•°æ®</button>
                <button class="success" onclick="trendImportFromFile()">å¯¼å…¥æ–‡ä»¶æ•°æ®</button>
                <button class="success" onclick="loadTrendFromDBRecent100()">ä»æ•°æ®åº“åŠ è½½è¿‘100æœŸèµ°åŠ¿å›¾</button>
                <button class="success" onclick="loadTrendFromDB()">ä»æ•°æ®åº“åŠ è½½èµ°åŠ¿å›¾</button>
                <button class="success" onclick="generateTrendChart()">ç”Ÿæˆèµ°åŠ¿å›¾</button>
            </div>
            <div class="action-buttons" style="display:grid; grid-template-columns:repeat(4, 1fr); gap:10px;">
                <button class="export-btn" onclick="exportTrendToExcel()">å¯¼å‡ºä¸ºExcel</button>
                <button class="export-btn" onclick="saveTrendToDB()">ğŸ’¾ ä¿å­˜åˆ°æ•°æ®åº“</button>
                <button style="background:#e74c3c;" onclick="clearTrendMemory()">æ¸…ç©ºèµ°åŠ¿å›¾å†…å­˜</button>
                <button onclick="showTrendHelp()">ä½¿ç”¨å¸®åŠ©</button>
            </div>
        </div>

        <!-- ç»Ÿè®¡é¢æ¿ -->
        <div id="trendStatsPanel" class="stats-panel" style="display:none;"></div>

        <!-- åˆ†é¡µæ§ä»¶ -->
        <div id="trendPaginationControls" class="pagination-controls" style="display:none;">
            <button onclick="trendFirstPage()">é¦–é¡µ</button>
            <button onclick="trendPrevPage()">ä¸Šä¸€é¡µ</button>
            <span class="pagination-info" id="trendPageInfo">ç¬¬ 1 é¡µ / å…± 1 é¡µ</span>
            <button onclick="trendNextPage()">ä¸‹ä¸€é¡µ</button>
            <button onclick="trendLastPage()">æœ«é¡µ</button>
            <span>è·³è½¬åˆ°ï¼š</span>
            <input type="number" id="trendJumpToPage" style="width:60px;padding:5px;">
            <button onclick="trendJumpToPage()">è·³è½¬</button>
        </div>

        <!-- æ•°æ®é¢„è§ˆ -->
        <div id="trendDataPreview" class="data-preview" style="display:none;">
            <strong>æ•°æ®é¢„è§ˆï¼ˆæœ€æ–°10æœŸï¼‰ï¼š</strong>
            <div id="trendPreviewContent"></div>
        </div>

        <!-- èµ°åŠ¿å›¾å®¹å™¨ -->
        <div class="trend-container">
            <div class="trend-title" id="trendTitle">PK10 åå¤§åæ¬¡åŸºæœ¬èµ°åŠ¿å›¾ï¼ˆæ‰¹é‡ç»“æœï¼‰</div>
            <div id="trendTables"></div>
        </div>
        
        <!-- è‡ªåŠ¨ä¸‹æ³¨è®°å½• -->
        <div class="box" id="bettingRecordsBox" style="display:none;">
            <h3>ğŸ“Š è‡ªåŠ¨ä¸‹æ³¨è®°å½•ï¼ˆå…¨éƒ¨ï¼‰</h3>
            <div style="margin-bottom:10px;">
                <button id="rule1Btn" onclick="switchBettingRule(1)" style="background:#95a5a6; margin-right:5px;">è§„åˆ™1</button>
                <button id="rule2Btn" onclick="switchBettingRule(2)" style="background:#95a5a6; margin-right:5px;">è§„åˆ™2</button>
                <button id="rule3Btn" onclick="switchBettingRule(3)" class="success" style="background:#27ae60; margin-right:5px;">è§„åˆ™3</button>
                <button id="monitorRule3Btn" onclick="toggleMonitorRule3()" class="success" style="background:#16a085; margin-right:5px;">ç›‘æ§è§„åˆ™3ï¼šå¼€</button>
                <button onclick="refreshBettingRecords()" class="success">åˆ·æ–°è®°å½•</button>
                <button onclick="clearBettingRecordsMemory()" style="background:#e74c3c;">æ¸…ç©ºè®°å½•</button>
            </div>
            <div id="bettingRecordsTable" style="max-height:500px; overflow-y:auto; overflow-x:auto;"></div>
            <div id="bettingRecordsStats" style="margin-top:15px; padding:10px; background:#f8f9fa; border-radius:5px;"></div>
        </div>
        
        <!-- è‡ªåŠ¨ç”Ÿæˆæ–¹æ¡ˆæ˜¾ç¤ºæ¡† -->
        <div class="box" id="autoSchemeBox" style="display:none;">
            <h3>ğŸ¯ è‡ªåŠ¨ç”Ÿæˆæ–¹æ¡ˆ</h3>
            <div style="margin-bottom:10px;">
                <button onclick="copyAutoScheme()" class="primary">å¤åˆ¶æ–¹æ¡ˆ</button>
                <button onclick="clearAutoScheme()" style="background:#95a5a6;">æ¸…ç©ºæ–¹æ¡ˆ</button>
                <span id="autoSchemeMeta" style="margin-left:15px; color:#555; font-size:14px;"></span>
            </div>
            <textarea id="autoSchemeTextarea" readonly style="width:100%; height:300px; font-size:14px; font-family:monospace; padding:10px; border:1px solid #ddd; border-radius:4px; resize:vertical;" placeholder="è‡ªåŠ¨ç”Ÿæˆçš„æ–¹æ¡ˆå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..."></textarea>
        </div>
    </div>
</div>

<script>
// ================== åŸæœ‰å¼€å¥–ç³»ç»Ÿ JS ==================
// ================== æ³¢åœº(TRON) åŒºå—æ¥å£é…ç½® ==================
// TRON API key moved to server-side proxy. Frontend will call relative proxy path.
const TRON_BLOCK_API_URL = "/api/block";
// é€‰æ‹©ç”¨äºå¼€å¥–è®¡ç®—çš„åŒºå—æ—¶ï¼Œå‘å¼€å¥–æ—¶é—´æ·»åŠ çš„åç§»ï¼ˆæ¯«ç§’ï¼‰ã€‚
// æœ‰æ—¶éœ€è¦é€‰æ‹©â€œå¼€å¥–æ—¶é—´ä¹‹åâ€çš„åŒºå—ä»¥é¿å…æ—¶é—´åŒæ­¥/å‡ºå—å»¶è¿Ÿé—®é¢˜ã€‚
// é»˜è®¤ 2 åˆ† 33 ç§’ = 153000 msï¼ˆå¯æŒ‰éœ€è°ƒæ•´ä¸º 0ï¼‰
const TRON_BLOCK_SELECTION_OFFSET_MS = 153000;
const charOrder = "0123456789abcdef";

// ================== èµ›è½¦è§„åˆ™ï¼ˆUTC+8ï¼‰==================
// æ¯å¤©ç¬¬ä¸€æœŸï¼š00:00:33ï¼ˆUTC+8ï¼‰ï¼Œæ¯30ç§’ä¸€æœŸï¼Œæ¯å¤©2880æœŸï¼›ç¬¬2880æœŸè·¨å¤©åˆ°ç¬¬äºŒå¤©00:00:03ï¼ˆæœŸå·æ—¥æœŸä¿æŒå‰ä¸€å¤©ï¼‰
const FIRST_DRAW_SECOND_UTC8 = 33;
const DRAW_INTERVAL_SECONDS = 30;
const PHASES_PER_DAY = 2880;

const CACHE_PREFIX = "tron_race_cache_";
const CACHE_DURATION = 5 * 60 * 1000;

// ================== IndexedDB é…ç½® ==================
const DB_NAME = "TronRaceDB";
const DB_VERSION = 2; // å‡çº§ç‰ˆæœ¬ä»¥æ”¯æŒæŠ•æ³¨è®°å½•å­˜å‚¨

// å¯¹è±¡å­˜å‚¨åç§°
const STORE_BATCH = "batch_results";
const STORE_AUTO_DRAW = "auto_draw_results";
const STORE_TREND = "trend_data";
const STORE_SETTINGS = "app_settings";
const STORE_BETTING = "betting_records";

let db = null;
let persistenceEnabled = false;

// ================== æ–°å¢è‡ªåŠ¨å¼€å¥–å˜é‡ ==================
let autoDrawInterval = null;
let autoDrawTimer = null;
let isAutoDrawRunning = false;
let nextDrawTime = null;
let autoDrawCurrentPhase = null; // å½“å‰è‡ªåŠ¨å¼€å¥–æœŸå·
let autoDrawCurrentDate = null; // å½“å‰è‡ªåŠ¨å¼€å¥–æ—¥æœŸ
let autoDrawRetryCount = 0; // é‡è¯•æ¬¡æ•°
let autoDrawRetryTimer = null; // é‡è¯•å®šæ—¶å™¨
let autoDrawMaxRetries = 8; // æœ€å¤§é‡è¯•æ¬¡æ•°ï¼ˆæ¯3ç§’ä¸€æ¬¡ï¼Œæœ€å¤š8æ¬¡ï¼‰

// ================== æ–°å¢èµ°åŠ¿å›¾è‡ªåŠ¨æ›´æ–°å˜é‡ ==================
let isTrendChartGenerated = false;
let trendAutoUpdateEnabled = false;
let lastAutoUpdateIssue = null;

// ================== æ–°å¢æ‰¹é‡æŸ¥è¯¢æ§åˆ¶å˜é‡ ==================
let stopBatchQueryFlag = false;
let batchQueryInProgress = false;
let batchTotalQueries = 0;
let batchCompletedQueries = 0;
let batchSuccessQueries = 0;
let batchFailedQueries = 0;

// ================== IndexedDB åˆå§‹åŒ– ==================
function initIndexedDB() {
    return new Promise((resolve, reject) => {
        if (!window.indexedDB) {
            console.error("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒIndexedDB");
            updateDBStatus("æµè§ˆå™¨ä¸æ”¯æŒIndexedDB");
            reject(new Error("IndexedDB not supported"));
            return;
        }

        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = function(event) {
            console.error("IndexedDB æ‰“å¼€å¤±è´¥:", event.target.error);
            updateDBStatus("æ•°æ®åº“æ‰“å¼€å¤±è´¥");
            reject(event.target.error);
        };

        request.onsuccess = function(event) {
            db = event.target.result;
            console.log("IndexedDB åˆå§‹åŒ–æˆåŠŸ");
            updateDBStatus("å·²è¿æ¥");
            
            // æ£€æŸ¥æŒä¹…åŒ–è®¾ç½®
            checkPersistenceSetting().then(() => {
                // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                updateDBStats();
                resolve(db);
            });
        };

        request.onupgradeneeded = function(event) {
            const db = event.target.result;
            const oldVersion = event.oldVersion;
            const newVersion = event.newVersion;
            
            console.log(`IndexedDB å‡çº§ä¸­ï¼Œç‰ˆæœ¬: ${oldVersion} -> ${newVersion}`);
            
            // åˆ›å»ºæ‰¹é‡æŸ¥è¯¢ç»“æœå­˜å‚¨
            if (!db.objectStoreNames.contains(STORE_BATCH)) {
                try {
                    const batchStore = db.createObjectStore(STORE_BATCH, { keyPath: "phaseFormat" });
                    batchStore.createIndex("date", "date", { unique: false });
                    batchStore.createIndex("phase", "phase", { unique: false });
                    batchStore.createIndex("timestamp", "timestamp", { unique: false });
                    console.log("âœ“ åˆ›å»ºå¯¹è±¡å­˜å‚¨:", STORE_BATCH);
                } catch (e) {
                    console.error("âœ— åˆ›å»ºæ‰¹é‡æŸ¥è¯¢ç»“æœå­˜å‚¨å¤±è´¥:", e);
                }
            }
            
            // åˆ›å»ºè‡ªåŠ¨å¼€å¥–ç»“æœå­˜å‚¨
            if (!db.objectStoreNames.contains(STORE_AUTO_DRAW)) {
                try {
                    const autoDrawStore = db.createObjectStore(STORE_AUTO_DRAW, { keyPath: "phaseFormat" });
                    autoDrawStore.createIndex("date", "date", { unique: false });
                    autoDrawStore.createIndex("phase", "phase", { unique: false });
                    autoDrawStore.createIndex("timestamp", "timestamp", { unique: false });
                    console.log("âœ“ åˆ›å»ºå¯¹è±¡å­˜å‚¨:", STORE_AUTO_DRAW);
                } catch (e) {
                    console.error("âœ— åˆ›å»ºè‡ªåŠ¨å¼€å¥–ç»“æœå­˜å‚¨å¤±è´¥:", e);
                }
            }
            
            // åˆ›å»ºèµ°åŠ¿å›¾æ•°æ®å­˜å‚¨
            if (!db.objectStoreNames.contains(STORE_TREND)) {
                try {
                    const trendStore = db.createObjectStore(STORE_TREND, { keyPath: "issue" });
                    trendStore.createIndex("timestamp", "timestamp", { unique: false });
                    console.log("âœ“ åˆ›å»ºå¯¹è±¡å­˜å‚¨:", STORE_TREND);
                } catch (e) {
                    console.error("âœ— åˆ›å»ºèµ°åŠ¿å›¾æ•°æ®å­˜å‚¨å¤±è´¥:", e);
                }
            }
            
            // åˆ›å»ºåº”ç”¨è®¾ç½®å­˜å‚¨
            if (!db.objectStoreNames.contains(STORE_SETTINGS)) {
                try {
                    db.createObjectStore(STORE_SETTINGS, { keyPath: "key" });
                    console.log("âœ“ åˆ›å»ºå¯¹è±¡å­˜å‚¨:", STORE_SETTINGS);
                } catch (e) {
                    console.error("âœ— åˆ›å»ºåº”ç”¨è®¾ç½®å­˜å‚¨å¤±è´¥:", e);
                }
            }
            
            // åˆ›å»ºè‡ªåŠ¨ä¸‹æ³¨è®°å½•å­˜å‚¨
            if (!db.objectStoreNames.contains(STORE_BETTING)) {
                try {
                    const bettingStore = db.createObjectStore(STORE_BETTING, { keyPath: "id", autoIncrement: true });
                    bettingStore.createIndex("nextIssue", "nextIssue", { unique: false });
                    bettingStore.createIndex("timestamp", "timestamp", { unique: false });
                    console.log("âœ“ åˆ›å»ºå¯¹è±¡å­˜å‚¨:", STORE_BETTING);
                } catch (e) {
                    console.error("âœ— åˆ›å»ºè‡ªåŠ¨ä¸‹æ³¨è®°å½•å­˜å‚¨å¤±è´¥:", e);
                }
            }
            
            console.log("IndexedDB æ•°æ®åº“ç»“æ„å·²åˆ›å»º/å‡çº§å®Œæˆ");
        };
    });
}

// æ£€æŸ¥æŒä¹…åŒ–è®¾ç½®
async function checkPersistenceSetting() {
    try {
        const setting = await getDBSetting("persistenceEnabled");
        if (setting !== null && setting !== undefined) {
            persistenceEnabled = setting.value;
            document.getElementById("persistenceSwitch").checked = persistenceEnabled;
            document.getElementById("persistenceStatus").textContent = persistenceEnabled ? "å¼€å¯" : "å…³é—­";
            document.getElementById("persistenceStatus").className = persistenceEnabled ? "auto-status on" : "auto-status off";
            
            // å¦‚æœæŒä¹…åŒ–å¼€å¯ï¼Œä»æ•°æ®åº“åŠ è½½æ•°æ®
            if (persistenceEnabled) {
                await loadAllDataFromDB();
            }
        }
    } catch (error) {
        console.error("æ£€æŸ¥æŒä¹…åŒ–è®¾ç½®å¤±è´¥:", error);
    }
}

// åˆ‡æ¢æŒä¹…åŒ–
async function togglePersistence() {
    const switchElement = document.getElementById("persistenceSwitch");
    const statusElement = document.getElementById("persistenceStatus");
    
    persistenceEnabled = switchElement.checked;
    statusElement.textContent = persistenceEnabled ? "å¼€å¯" : "å…³é—­";
    statusElement.className = persistenceEnabled ? "auto-status on" : "auto-status off";
    
    // ä¿å­˜è®¾ç½®åˆ°æ•°æ®åº“
    await saveDBSetting("persistenceEnabled", persistenceEnabled);
    
    if (persistenceEnabled) {
        // å¼€å¯æŒä¹…åŒ–æ—¶ï¼Œä¿å­˜å½“å‰æ•°æ®åˆ°æ•°æ®åº“
        await saveAllDataToDB();
        alert("æŒä¹…åŒ–å­˜å‚¨å·²å¼€å¯ï¼Œå½“å‰æ•°æ®å·²ä¿å­˜åˆ°æ•°æ®åº“ã€‚");
    } else {
        alert("æŒä¹…åŒ–å­˜å‚¨å·²å…³é—­ï¼Œæ–°æ•°æ®å°†ä¸ä¼šä¿å­˜åˆ°æ•°æ®åº“ã€‚");
    }
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    updateDBStats();
}

// ä¿å­˜è®¾ç½®åˆ°æ•°æ®åº“
async function saveDBSetting(key, value) {
    return new Promise((resolve, reject) => {
        if (!db) {
            reject(new Error("æ•°æ®åº“æœªåˆå§‹åŒ–"));
            return;
        }
        
        const transaction = db.transaction([STORE_SETTINGS], "readwrite");
        const store = transaction.objectStore(STORE_SETTINGS);
        
        const request = store.put({ key: key, value: value, timestamp: Date.now() });
        
        request.onsuccess = function() {
            resolve();
        };
        
        request.onerror = function(event) {
            reject(event.target.error);
        };
    });
}

// ä»æ•°æ®åº“è·å–è®¾ç½®
async function getDBSetting(key) {
    return new Promise((resolve, reject) => {
        if (!db) {
            resolve(null);
            return;
        }
        
        const transaction = db.transaction([STORE_SETTINGS], "readonly");
        const store = transaction.objectStore(STORE_SETTINGS);
        
        const request = store.get(key);
        
        request.onsuccess = function() {
            resolve(request.result);
        };
        
        request.onerror = function(event) {
            reject(event.target.error);
        };
    });
}

// ä¿å­˜æ‰¹é‡æŸ¥è¯¢ç»“æœåˆ°æ•°æ®åº“
async function saveBatchResultToDB(resultItem) {
    if (!persistenceEnabled || !db) return;
    
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_BATCH], "readwrite");
        const store = transaction.objectStore(STORE_BATCH);
        
        // ç¡®ä¿æœ‰timestampå­—æ®µ
        if (!resultItem.timestamp) {
            resultItem.timestamp = Date.now();
        }
        
        const request = store.put(resultItem);
        
        request.onsuccess = function() {
            resolve();
        };
        
        request.onerror = function(event) {
            console.error("ä¿å­˜æ‰¹é‡æŸ¥è¯¢ç»“æœåˆ°æ•°æ®åº“å¤±è´¥:", event.target.error);
            reject(event.target.error);
        };
    });
}

// ä¿å­˜è‡ªåŠ¨å¼€å¥–ç»“æœåˆ°æ•°æ®åº“
async function saveAutoDrawResultToDB(resultItem) {
    if (!persistenceEnabled || !db) return;
    
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_AUTO_DRAW], "readwrite");
        const store = transaction.objectStore(STORE_AUTO_DRAW);
        
        // ç¡®ä¿æœ‰timestampå­—æ®µ
        if (!resultItem.timestamp) {
            resultItem.timestamp = Date.now();
        }
        
        const request = store.put(resultItem);
        
        request.onsuccess = function() {
            resolve();
        };
        
        request.onerror = function(event) {
            console.error("ä¿å­˜è‡ªåŠ¨å¼€å¥–ç»“æœåˆ°æ•°æ®åº“å¤±è´¥:", event.target.error);
            reject(event.target.error);
        };
    });
}

// ä¿å­˜èµ°åŠ¿å›¾æ•°æ®åˆ°æ•°æ®åº“
async function saveTrendDataToDB() {
    if (!persistenceEnabled || !db || !trendAllData.length) return;
    
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_TREND], "readwrite");
        const store = transaction.objectStore(STORE_TREND);
        
        let completed = 0;
        let total = trendAllData.length;
        
        if (total === 0) {
            resolve();
            return;
        }
        
        trendAllData.forEach((item, index) => {
            // ç¡®ä¿æœ‰timestampå­—æ®µ
            if (!item.timestamp) {
                item.timestamp = Date.now();
            }
            
            const request = store.put(item);
            
            request.onsuccess = function() {
                completed++;
                if (completed === total) {
                    resolve();
                }
            };
            
            request.onerror = function(event) {
                console.error("ä¿å­˜èµ°åŠ¿å›¾æ•°æ®åˆ°æ•°æ®åº“å¤±è´¥:", event.target.error);
                completed++;
                if (completed === total) {
                    resolve(); // å³ä½¿æœ‰é”™è¯¯ä¹Ÿç»§ç»­
                }
            };
        });
    });
}

// ä»æ•°æ®åº“åŠ è½½æ‰¹é‡æŸ¥è¯¢ç»“æœ
async function loadBatchResultsFromDB() {
    return new Promise((resolve, reject) => {
        if (!db) {
            resolve([]);
            return;
        }
        
        const transaction = db.transaction([STORE_BATCH], "readonly");
        const store = transaction.objectStore(STORE_BATCH);
        const request = store.getAll();
        
        request.onsuccess = function() {
            resolve(request.result || []);
        };
        
        request.onerror = function(event) {
            console.error("ä»æ•°æ®åº“åŠ è½½æ‰¹é‡æŸ¥è¯¢ç»“æœå¤±è´¥:", event.target.error);
            reject(event.target.error);
        };
    });
}

// ä»æ•°æ®åº“åŠ è½½è‡ªåŠ¨å¼€å¥–ç»“æœ
async function loadAutoDrawResultsFromDB() {
    return new Promise((resolve, reject) => {
        if (!db) {
            resolve([]);
            return;
        }
        
        const transaction = db.transaction([STORE_AUTO_DRAW], "readonly");
        const store = transaction.objectStore(STORE_AUTO_DRAW);
        const request = store.getAll();
        
        request.onsuccess = function() {
            resolve(request.result || []);
        };
        
        request.onerror = function(event) {
            console.error("ä»æ•°æ®åº“åŠ è½½è‡ªåŠ¨å¼€å¥–ç»“æœå¤±è´¥:", event.target.error);
            reject(event.target.error);
        };
    });
}

// ä»æ•°æ®åº“åŠ è½½èµ°åŠ¿å›¾æ•°æ®
async function loadTrendDataFromDB() {
    return new Promise((resolve, reject) => {
        if (!db) {
            resolve([]);
            return;
        }
        
        const transaction = db.transaction([STORE_TREND], "readonly");
        const store = transaction.objectStore(STORE_TREND);
        const request = store.getAll();
        
        request.onsuccess = function() {
            resolve(request.result || []);
        };
        
        request.onerror = function(event) {
            console.error("ä»æ•°æ®åº“åŠ è½½èµ°åŠ¿å›¾æ•°æ®å¤±è´¥:", event.target.error);
            reject(event.target.error);
        };
    });
}

// ä¿å­˜æ‰€æœ‰æ•°æ®åˆ°æ•°æ®åº“
async function saveAllDataToDB() {
    if (!db) return;
    
    try {
        // ä¿å­˜æ‰¹é‡æŸ¥è¯¢ç»“æœ
        if (window.batchAllResults && window.batchAllResults.length > 0) {
            for (const result of window.batchAllResults) {
                await saveBatchResultToDB(result);
            }
        }
        
        // ä¿å­˜è‡ªåŠ¨å¼€å¥–ç»“æœï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
        // è‡ªåŠ¨å¼€å¥–ç»“æœä¼šåœ¨æ¯æ¬¡è‡ªåŠ¨å¼€å¥–æ—¶ä¿å­˜
        
        // ä¿å­˜èµ°åŠ¿å›¾æ•°æ®
        if (trendAllData.length > 0) {
            await saveTrendDataToDB();
        }
        
        console.log("æ‰€æœ‰æ•°æ®å·²ä¿å­˜åˆ°æ•°æ®åº“");
    } catch (error) {
        console.error("ä¿å­˜æ•°æ®åˆ°æ•°æ®åº“å¤±è´¥:", error);
    }
}

// ä»æ•°æ®åº“åŠ è½½æ‰€æœ‰æ•°æ®
async function loadAllDataFromDB() {
    if (!db) {
        alert("æ•°æ®åº“æœªåˆå§‹åŒ–ï¼Œè¯·ç¨åå†è¯•");
        return;
    }
    
    try {
        // åŠ è½½æ‰¹é‡æŸ¥è¯¢ç»“æœ
        const batchResults = await loadBatchResultsFromDB();
        if (batchResults.length > 0) {
            window.batchAllResults = batchResults;
            // æŒ‰æ—¥æœŸå’ŒæœŸå·æ’åº
            window.batchAllResults.sort((a, b) => {
                if (a.date !== b.date) return a.date.localeCompare(b.date);
                return a.phase - b.phase;
            });
            
            // æ›´æ–°æ‰¹é‡æŸ¥è¯¢ç»“æœæ˜¾ç¤º
            renderBatchResults();
            
            // æ˜¾ç¤ºç»“æœå®¹å™¨
            document.getElementById('batchResultsContainer').style.display = 'block';
            
            alert(`ä»æ•°æ®åº“åŠ è½½äº† ${batchResults.length} æ¡æ‰¹é‡æŸ¥è¯¢ç»“æœ`);
        }
        
        // åŠ è½½è‡ªåŠ¨å¼€å¥–ç»“æœ
        const autoDrawResults = await loadAutoDrawResultsFromDB();
        if (autoDrawResults.length > 0) {
            // å¯ä»¥åœ¨è¿™é‡Œå¤„ç†è‡ªåŠ¨å¼€å¥–ç»“æœ
            console.log(`ä»æ•°æ®åº“åŠ è½½äº† ${autoDrawResults.length} æ¡è‡ªåŠ¨å¼€å¥–ç»“æœ`);
        }
        
        // åŠ è½½èµ°åŠ¿å›¾æ•°æ®
        const trendData = await loadTrendDataFromDB();
        if (trendData.length > 0) {
            trendAllData = trendData;
            trendShowDataPreview();
            alert(`ä»æ•°æ®åº“åŠ è½½äº† ${trendData.length} æ¡èµ°åŠ¿å›¾æ•°æ®`);
        }
        
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        updateDBStats();
        
    } catch (error) {
        console.error("ä»æ•°æ®åº“åŠ è½½æ•°æ®å¤±è´¥:", error);
        alert("ä»æ•°æ®åº“åŠ è½½æ•°æ®å¤±è´¥: " + error.message);
    }
}

// æ¸…ç©ºæ•°æ®åº“
async function clearDatabase() {
    if (!db || !confirm("ç¡®å®šè¦æ¸…ç©ºæ•°æ®åº“ä¸­çš„æ‰€æœ‰æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼")) {
        return;
    }
    
    try {
        // æ¸…ç©ºæ‰€æœ‰å¯¹è±¡å­˜å‚¨
        const stores = [STORE_BATCH, STORE_AUTO_DRAW, STORE_TREND, STORE_BETTING];
        
        for (const storeName of stores) {
            const transaction = db.transaction([storeName], "readwrite");
            const store = transaction.objectStore(storeName);
            const request = store.clear();
            
            await new Promise((resolve, reject) => {
                request.onsuccess = resolve;
                request.onerror = () => reject(request.error);
            });
        }
        
        // é‡ç½®å†…å­˜ä¸­çš„æ•°æ®
        window.batchAllResults = [];
        window.batchAllErrors = [];
        trendAllData = [];
        localStorage.removeItem(BETTING_STORE_KEY);
        
        // æ›´æ–°UI
        renderBatchResults();
        trendShowDataPreview();
        
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        updateDBStats();
        
        alert("æ•°æ®åº“å·²æ¸…ç©º");
    } catch (error) {
        console.error("æ¸…ç©ºæ•°æ®åº“å¤±è´¥:", error);
        alert("æ¸…ç©ºæ•°æ®åº“å¤±è´¥: " + error.message);
    }
}

// æ¸…ç©ºæ‰¹é‡æŸ¥è¯¢ç»“æœæ•°æ®
async function clearBatchResults() {
    if (!confirm("ç¡®å®šè¦æ¸…ç©ºæ‰¹é‡æŸ¥è¯¢ç»“æœæ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼")) {
        return;
    }
    
    try {
        // æ¸…ç©ºIndexedDBä¸­çš„æ‰¹é‡æŸ¥è¯¢ç»“æœ
        if (db) {
            const transaction = db.transaction([STORE_BATCH], "readwrite");
            const store = transaction.objectStore(STORE_BATCH);
            const request = store.clear();
            
            await new Promise((resolve, reject) => {
                request.onsuccess = resolve;
                request.onerror = () => reject(request.error);
            });
        }
        
        // æ¸…ç©ºå†…å­˜ä¸­çš„æ•°æ®
        window.batchAllResults = [];
        window.batchAllErrors = [];
        
        // æ›´æ–°UI
        renderBatchResults();
        
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        updateDBStats();
        
        alert("æ‰¹é‡æŸ¥è¯¢ç»“æœæ•°æ®å·²æ¸…ç©º");
    } catch (error) {
        console.error("æ¸…ç©ºæ‰¹é‡æŸ¥è¯¢ç»“æœæ•°æ®å¤±è´¥:", error);
        alert("æ¸…ç©ºæ‰¹é‡æŸ¥è¯¢ç»“æœæ•°æ®å¤±è´¥: " + error.message);
    }
}

// æ¸…ç©ºè‡ªåŠ¨å¼€å¥–è®°å½•æ•°æ®
async function clearAutoDrawResults() {
    if (!confirm("ç¡®å®šè¦æ¸…ç©ºè‡ªåŠ¨å¼€å¥–è®°å½•æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼")) {
        return;
    }
    
    try {
        // æ¸…ç©ºIndexedDBä¸­çš„è‡ªåŠ¨å¼€å¥–è®°å½•
        if (db) {
            const transaction = db.transaction([STORE_AUTO_DRAW], "readwrite");
            const store = transaction.objectStore(STORE_AUTO_DRAW);
            const request = store.clear();
            
            await new Promise((resolve, reject) => {
                request.onsuccess = resolve;
                request.onerror = () => reject(request.error);
            });
        }
        
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        updateDBStats();
        
        alert("è‡ªåŠ¨å¼€å¥–è®°å½•æ•°æ®å·²æ¸…ç©º");
    } catch (error) {
        console.error("æ¸…ç©ºè‡ªåŠ¨å¼€å¥–è®°å½•æ•°æ®å¤±è´¥:", error);
        alert("æ¸…ç©ºè‡ªåŠ¨å¼€å¥–è®°å½•æ•°æ®å¤±è´¥: " + error.message);
    }
}

// æ¸…ç©ºèµ°åŠ¿å›¾æ•°æ®
async function clearTrendData() {
    if (!confirm("ç¡®å®šè¦æ¸…ç©ºèµ°åŠ¿å›¾æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼")) {
        return;
    }
    
    try {
        // æ¸…ç©ºIndexedDBä¸­çš„èµ°åŠ¿å›¾æ•°æ®
        if (db) {
            const transaction = db.transaction([STORE_TREND], "readwrite");
            const store = transaction.objectStore(STORE_TREND);
            const request = store.clear();
            
            await new Promise((resolve, reject) => {
                request.onsuccess = resolve;
                request.onerror = () => reject(request.error);
            });
        }
        
        // æ¸…ç©ºå†…å­˜ä¸­çš„æ•°æ®
        trendAllData = [];
        trendCurrentPage = 1;
        trendTotalPages = 1;
        trendStats = null;
        isTrendChartGenerated = false;
        trendAutoUpdateEnabled = false;
        lastAutoUpdateIssue = null;
        
        // æ¸…ç©ºUIæ˜¾ç¤º
        const tablesDiv = document.getElementById('trendTables');
        if (tablesDiv) tablesDiv.innerHTML = '';
        const statsPanel = document.getElementById('trendStatsPanel');
        if (statsPanel) statsPanel.style.display = 'none';
        const pag = document.getElementById('trendPaginationControls');
        if (pag) pag.style.display = 'none';
        const preview = document.getElementById('trendDataPreview');
        if (preview) preview.style.display = 'none';
        const autoUpdateStatus = document.getElementById('trendAutoUpdateStatus');
        if (autoUpdateStatus) autoUpdateStatus.style.display = 'none';
        
        // æ›´æ–°UIé¢„è§ˆ
        trendShowDataPreview();
        
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        updateDBStats();
        
        alert("èµ°åŠ¿å›¾æ•°æ®å·²æ¸…ç©º");
    } catch (error) {
        console.error("æ¸…ç©ºèµ°åŠ¿å›¾æ•°æ®å¤±è´¥:", error);
        alert("æ¸…ç©ºèµ°åŠ¿å›¾æ•°æ®å¤±è´¥: " + error.message);
    }
}

// ä»…æ¸…ç©ºå†…å­˜ä¸­çš„èµ°åŠ¿å›¾æ•°æ®ï¼ˆä¸æ“ä½œæ•°æ®åº“ï¼‰
function clearTrendMemory() {
    if (!confirm("ç¡®å®šè¦æ¸…ç©ºèµ°åŠ¿å›¾å†…å­˜å—ï¼Ÿæ­¤æ“ä½œä¸ä¼šå½±å“å·²ä¿å­˜çš„æ•°æ®åº“æ•°æ®ï¼Œä¸”ä¸å¯æ’¤é”€ï¼")) {
        return;
    }

    // æ¸…ç©ºå†…å­˜ä¸­çš„æ•°æ®
    trendAllData = [];
    trendCurrentPage = 1;
    trendTotalPages = 1;
    trendStats = null;
    isTrendChartGenerated = false;
    trendAutoUpdateEnabled = false;
    lastAutoUpdateIssue = null;

    // æ¸…ç©ºUIæ˜¾ç¤º
    const tablesDiv = document.getElementById('trendTables');
    if (tablesDiv) tablesDiv.innerHTML = '';
    const statsPanel = document.getElementById('trendStatsPanel');
    if (statsPanel) statsPanel.style.display = 'none';
    const pag = document.getElementById('trendPaginationControls');
    if (pag) pag.style.display = 'none';
    const preview = document.getElementById('trendDataPreview');
    if (preview) preview.style.display = 'none';
    const autoUpdateStatus = document.getElementById('trendAutoUpdateStatus');
    if (autoUpdateStatus) autoUpdateStatus.style.display = 'none';

    // æ›´æ–°UIé¢„è§ˆ
    if (typeof trendShowDataPreview === 'function') trendShowDataPreview();

    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯ï¼ˆåˆ·æ–°æ˜¾ç¤ºï¼Œä½†ä¸ä¿®æ”¹æ•°æ®åº“ï¼‰
    if (typeof updateDBStats === 'function') updateDBStats();

    alert("èµ°åŠ¿å›¾å†…å­˜å·²æ¸…ç©º");
}

// ä»…æ¸…ç©ºâ€œè‡ªåŠ¨ä¸‹æ³¨è®°å½•â€å½“å‰æ˜¾ç¤º/ç¼“å­˜ï¼ˆä¸åˆ é™¤ IndexedDB æ•°æ®åº“ä¸­çš„å†å²è®°å½•ï¼‰
// - è®°å½•ç‰ˆé¢çš„â€œæ¸…ç©ºè®°å½•â€æŒ‰é’®åº”åªæ¸…è¿™é‡Œï¼ˆé¿å…è¯¯åˆ æ•°æ®åº“æ•°æ®ï¼‰
function clearBettingRecordsMemory() {
    if (!confirm("ç¡®å®šè¦æ¸…ç©ºè‡ªåŠ¨ä¸‹æ³¨è®°å½•ï¼ˆä»…æ¸…ç©ºå½“å‰æ˜¾ç¤º/ç¼“å­˜ï¼Œä¸åˆ é™¤æ•°æ®åº“å†å²æ•°æ®ï¼‰å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼")) {
        return;
    }

    try {
        // ä»…æ¸…ç©º localStorageï¼ˆç”¨äºæ˜¾ç¤ºæœ€è¿‘50æœŸçš„è®°å½•ç¼“å­˜ï¼‰
        localStorage.removeItem(BETTING_STORE_KEY);

        // æ›´æ–°UIæ˜¾ç¤ºï¼ˆè¡¨æ ¼/ç»Ÿè®¡ä¼šéš localStorage å˜åŒ–åˆ·æ–°ï¼‰
        if (typeof refreshBettingRecords === 'function') {
            refreshBettingRecords();
        }

        // åˆ·æ–°æ•°æ®åº“ç»Ÿè®¡ï¼ˆæ•°æ®åº“æœªå˜ï¼Œä½†åˆ·æ–°é¢æ¿æ•°å€¼å±•ç¤ºï¼‰
        if (typeof updateDBStats === 'function') {
            updateDBStats();
        }

        alert("è‡ªåŠ¨ä¸‹æ³¨è®°å½•å·²æ¸…ç©ºï¼ˆæœªåˆ é™¤æ•°æ®åº“å†å²æ•°æ®ï¼‰");
    } catch (error) {
        console.error("æ¸…ç©ºè‡ªåŠ¨ä¸‹æ³¨è®°å½•ï¼ˆä»…ç¼“å­˜ï¼‰å¤±è´¥:", error);
        alert("æ¸…ç©ºè‡ªåŠ¨ä¸‹æ³¨è®°å½•å¤±è´¥: " + (error && error.message ? error.message : String(error)));
    }
}

// æ¸…ç©ºè‡ªåŠ¨ä¸‹æ³¨è®°å½•æ•°æ®
async function clearBettingRecords() {
    if (!confirm("ç¡®å®šè¦æ¸…ç©ºè‡ªåŠ¨ä¸‹æ³¨è®°å½•æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼")) {
        return;
    }
    
    try {
        // æ¸…ç©ºIndexedDBä¸­çš„è‡ªåŠ¨ä¸‹æ³¨è®°å½•
        if (db) {
            const transaction = db.transaction([STORE_BETTING], "readwrite");
            const store = transaction.objectStore(STORE_BETTING);
            const request = store.clear();
            
            await new Promise((resolve, reject) => {
                request.onsuccess = resolve;
                request.onerror = () => reject(request.error);
            });
        }
        
        // æ¸…ç©ºlocalStorageä¸­çš„è‡ªåŠ¨ä¸‹æ³¨è®°å½•
        localStorage.removeItem(BETTING_STORE_KEY);
        
        // æ›´æ–°UIï¼ˆå¦‚æœæœ‰æ˜¾ç¤ºæŠ•æ³¨è®°å½•çš„åœ°æ–¹ï¼‰
        if (typeof refreshBettingRecords === 'function') {
            refreshBettingRecords();
        }
        
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        updateDBStats();
        
        alert("è‡ªåŠ¨ä¸‹æ³¨è®°å½•æ•°æ®å·²æ¸…ç©º");
    } catch (error) {
        console.error("æ¸…ç©ºè‡ªåŠ¨ä¸‹æ³¨è®°å½•æ•°æ®å¤±è´¥:", error);
        alert("æ¸…ç©ºè‡ªåŠ¨ä¸‹æ³¨è®°å½•æ•°æ®å¤±è´¥: " + error.message);
    }
}

// å¯¼å‡ºæ•°æ®åº“æ‰€æœ‰æ•°æ®åˆ°Excel
async function exportAllDataToExcel() {
    if (!db) {
        alert("æ•°æ®åº“æœªåˆå§‹åŒ–");
        return;
    }
    
    try {
        const wb = XLSX.utils.book_new();
        
        // å¯¼å‡ºæ‰¹é‡æŸ¥è¯¢ç»“æœ
        const batchResults = await loadBatchResultsFromDB();
        if (batchResults.length > 0) {
            const wsData = [
                ['æœŸå·', 'å¼€å¥–å·ç ', 'ç¬¬1å', 'ç¬¬2å', 'ç¬¬3å', 'ç¬¬4å', 'ç¬¬5å', 
                 'ç¬¬6å', 'ç¬¬7å', 'ç¬¬8å', 'ç¬¬9å', 'ç¬¬10å', 'å¼€å¥–æ—¶é—´', 'åŒºå—é«˜åº¦', 'æŸ¥è¯¢æ—¶é—´']
            ];
            
            batchResults.forEach(item => {
                const row = [
                    item.phaseFormat,
                    item.result ? item.result.join('') : 'N/A',
                    item.result ? item.result[0] : 'N/A',
                    item.result ? item.result[1] : 'N/A',
                    item.result ? item.result[2] : 'N/A',
                    item.result ? item.result[3] : 'N/A',
                    item.result ? item.result[4] : 'N/A',
                    item.result ? item.result[5] : 'N/A',
                    item.result ? item.result[6] : 'N/A',
                    item.result ? item.result[7] : 'N/A',
                    item.result ? item.result[8] : 'N/A',
                    item.result ? item.result[9] : 'N/A',
                    item.timeUTC8 || 'N/A',
                    item.blockNumber || 'N/A',
                    new Date(item.timestamp).toLocaleString('zh-CN')
                ];
                wsData.push(row);
            });
            
            const ws = XLSX.utils.aoa_to_sheet(wsData);
            XLSX.utils.book_append_sheet(wb, ws, 'æ‰¹é‡æŸ¥è¯¢ç»“æœ');
        }
        
        // å¯¼å‡ºè‡ªåŠ¨å¼€å¥–ç»“æœ
        const autoDrawResults = await loadAutoDrawResultsFromDB();
        if (autoDrawResults.length > 0) {
            const wsData = [
                ['æœŸå·', 'å¼€å¥–å·ç ', 'ç¬¬1å', 'ç¬¬2å', 'ç¬¬3å', 'ç¬¬4å', 'ç¬¬5å', 
                 'ç¬¬6å', 'ç¬¬7å', 'ç¬¬8å', 'ç¬¬9å', 'ç¬¬10å', 'å¼€å¥–æ—¶é—´', 'åŒºå—é«˜åº¦', 'è‡ªåŠ¨è·å–æ—¶é—´']
            ];
            
            autoDrawResults.forEach(item => {
                const row = [
                    item.phaseFormat,
                    item.result ? item.result.join('') : 'N/A',
                    item.result ? item.result[0] : 'N/A',
                    item.result ? item.result[1] : 'N/A',
                    item.result ? item.result[2] : 'N/A',
                    item.result ? item.result[3] : 'N/A',
                    item.result ? item.result[4] : 'N/A',
                    item.result ? item.result[5] : 'N/A',
                    item.result ? item.result[6] : 'N/A',
                    item.result ? item.result[7] : 'N/A',
                    item.result ? item.result[8] : 'N/A',
                    item.result ? item.result[9] : 'N/A',
                    item.timeUTC8 || 'N/A',
                    item.blockNumber || 'N/A',
                    new Date(item.timestamp).toLocaleString('zh-CN')
                ];
                wsData.push(row);
            });
            
            const ws = XLSX.utils.aoa_to_sheet(wsData);
            XLSX.utils.book_append_sheet(wb, ws, 'è‡ªåŠ¨å¼€å¥–è®°å½•');
        }
        
        // å¯¼å‡ºèµ°åŠ¿å›¾æ•°æ®
        if (trendAllData.length > 0) {
            const wsData = [
                // è°ƒæ•´åˆ—é¡ºåºä¸ºï¼šæœŸå· | å¼€å¥–å·ç  | ç¬¬1å~ç¬¬10å | ä¿å­˜æ—¶é—´
                ['æœŸå·', 'å¼€å¥–å·ç ', 'ç¬¬1å', 'ç¬¬2å', 'ç¬¬3å', 'ç¬¬4å', 'ç¬¬5å',
                 'ç¬¬6å', 'ç¬¬7å', 'ç¬¬8å', 'ç¬¬9å', 'ç¬¬10å', 'ä¿å­˜æ—¶é—´']
            ];
            
            trendAllData.forEach(r => {
                const nums = [];
                for (let p = 1; p <= 10; p++) {
                    const v = r['p' + p];
                    nums.push(v == null || v === '' ? '-' : v);
                }

                // ç¬¬ä¸€åˆ—ï¼šæœŸå·ï¼›ç¬¬äºŒåˆ—ï¼šå¼€å¥–å·ç ï¼ˆæ‹¼æ¥ï¼‰
                const row = [r.issue, nums.join('')];

                // ç¬¬3~12åˆ—ï¼šç¬¬1å~ç¬¬10å
                for (let i = 0; i < nums.length; i++) {
                    row.push(nums[i]);
                }

                // æœ€åä¸€åˆ—ï¼šä¿å­˜æ—¶é—´
                row.push(r.timestamp ? new Date(r.timestamp).toLocaleString('zh-CN') : 'N/A');

                wsData.push(row);
            });
            
            const ws = XLSX.utils.aoa_to_sheet(wsData);
            XLSX.utils.book_append_sheet(wb, ws, 'èµ°åŠ¿å›¾æ•°æ®');
        }
        
        // å¯¼å‡ºè‡ªåŠ¨ä¸‹æ³¨è®°å½•
        const bettingRecords = await loadBettingRecordsFromDB();
        if (bettingRecords.length > 0) {
            const wsData = [
                ['æœŸå·', 'è§¦å‘æ¡ä»¶', 'æ–¹æ¡ˆè§„åˆ™', 'æ–¹æ¡ˆæ•°', 'æ’é™¤é¡¹', 'å¼€å¥–ç»“æœ', 'ä¸­å¥–çŠ¶æ€', 'æŠ•æ³¨æ—¶é—´']
            ];
            
            bettingRecords.forEach(record => {
                const positionNames = ['', 'ç¬¬1å', 'ç¬¬2å', 'ç¬¬3å'];
                const triggerDesc = `${positionNames[record.triggerPosition]}è¿ç»­ä¸‰æœŸå‡ºç°æ•°å­—${record.triggerNumber}`;
                
                // ç”Ÿæˆæ’é™¤é¡¹ä¿¡æ¯
                const excludeInfo = [];
                const posMap = { 'w': 'ç¬¬ä¸€å', 'q': 'ç¬¬äºŒå', 'b': 'ç¬¬ä¸‰å' };
                if (record.enabledPositions && record.excludeDigits) {
                    record.enabledPositions.forEach(pos => {
                        const posName = posMap[pos];
                        const excludeNums = record.excludeDigits[pos] || [];
                        if (excludeNums.length > 0) {
                            const sortedNums = excludeNums.slice().sort((a, b) => a - b);
                            excludeInfo.push(`${posName}æ’é™¤${sortedNums.join('ã€')}`);
                        }
                    });
                }
                const excludeStr = excludeInfo.length > 0 ? excludeInfo.join('ï¼Œ') : 'æ— ';
                
                // è·å–æ–¹æ¡ˆè§„åˆ™ï¼ˆå…¼å®¹æ—§æ•°æ®ï¼Œé»˜è®¤ä¸º"è§„åˆ™1"ï¼‰
                const ruleStr = record.rule || 'è§„åˆ™1';
                
                // å¼€å¥–ç»“æœ
                let resultStr = 'å¾…å¼€å¥–';
                let winStatus = 'å¾…å¼€å¥–';
                if (record.checked) {
                    const resultNums = [];
                    record.enabledPositions.forEach(pos => {
                        const posMap = { 'w': 1, 'q': 2, 'b': 3 };
                        const posNum = posMap[pos];
                        const num = record.result['p' + posNum];
                        resultNums.push(num != null ? String(num).padStart(2, '0') : '--');
                    });
                    resultStr = resultNums.join(' ');
                    winStatus = record.isWin ? 'ä¸­å¥–' : 'æœªä¸­å¥–';
                }
                
                const row = [
                    record.nextIssue,
                    triggerDesc,
                    ruleStr,
                    record.schemes.length,
                    excludeStr,
                    resultStr,
                    winStatus,
                    record.timestamp ? new Date(record.timestamp).toLocaleString('zh-CN') : 'N/A'
                ];
                wsData.push(row);
            });
            
            const ws = XLSX.utils.aoa_to_sheet(wsData);
            XLSX.utils.book_append_sheet(wb, ws, 'è‡ªåŠ¨ä¸‹æ³¨è®°å½•');
        }
        
        if (wb.SheetNames.length === 0) {
            alert("æ•°æ®åº“ä¸­æ²¡æœ‰æ•°æ®å¯å¯¼å‡º");
            return;
        }
        
        const fileName = `æ³¢åœº30ç§’èµ›è½¦æ•°æ®åº“_${new Date().toISOString().slice(0,10)}.xlsx`;
        XLSX.writeFile(wb, fileName);
        
        alert(`æ•°æ®åº“æ•°æ®å·²å¯¼å‡ºä¸º ${fileName}`);
    } catch (e) {
        alert('å¯¼å‡ºå¤±è´¥ï¼š' + e.message);
        console.error(e);
    }
}

// æ›´æ–°æ•°æ®åº“çŠ¶æ€æ˜¾ç¤º
function updateDBStatus(status) {
    const statusElement = document.getElementById("dbStatus");
    if (statusElement) {
        statusElement.textContent = "æ•°æ®åº“çŠ¶æ€ï¼š" + status;
    }
}

// æ›´æ–°æ•°æ®åº“ç»Ÿè®¡ä¿¡æ¯
async function updateDBStats() {
    if (!db) return;
    
    try {
        // è·å–å„å­˜å‚¨çš„è®°å½•æ•°
        const batchCount = await getStoreCount(STORE_BATCH);
        const autoDrawCount = await getStoreCount(STORE_AUTO_DRAW);
        const trendCount = await getStoreCount(STORE_TREND);
        const bettingCount = await getStoreCount(STORE_BETTING);
        
        // æ›´æ–°UI
        document.getElementById("statBatchCount").textContent = batchCount;
        document.getElementById("statAutoDrawCount").textContent = autoDrawCount;
        document.getElementById("statTrendCount").textContent = trendCount;
        const bettingCountEl = document.getElementById("statBettingCount");
        if (bettingCountEl) bettingCountEl.textContent = bettingCount;
        
        // ä¼°ç®—å­˜å‚¨å¤§å°
        const totalSize = await estimateDBSize();
        document.getElementById("statTotalSize").textContent = totalSize;
        
    } catch (error) {
        console.error("æ›´æ–°æ•°æ®åº“ç»Ÿè®¡ä¿¡æ¯å¤±è´¥:", error);
    }
}

// è·å–å¯¹è±¡å­˜å‚¨è®°å½•æ•°
async function getStoreCount(storeName) {
    return new Promise((resolve, reject) => {
        if (!db) {
            resolve(0);
            return;
        }
        
        const transaction = db.transaction([storeName], "readonly");
        const store = transaction.objectStore(storeName);
        const request = store.count();
        
        request.onsuccess = function() {
            resolve(request.result);
        };
        
        request.onerror = function(event) {
            reject(event.target.error);
        };
    });
}

// ä¼°ç®—æ•°æ®åº“å¤§å°
async function estimateDBSize() {
    // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„ä¼°ç®—ï¼Œå®é™…å¤§å°å¯èƒ½éœ€è¦æ›´å¤æ‚çš„è®¡ç®—
    try {
        const batchCount = await getStoreCount(STORE_BATCH);
        const autoDrawCount = await getStoreCount(STORE_AUTO_DRAW);
        const trendCount = await getStoreCount(STORE_TREND);
        
        // å‡è®¾æ¯æ¡è®°å½•å¹³å‡å¤§å°ä¸º2KB
        const totalRecords = batchCount + autoDrawCount + trendCount;
        const estimatedSizeKB = Math.round(totalRecords * 2);
        
        if (estimatedSizeKB < 1024) {
            return `${estimatedSizeKB} KB`;
        } else {
            return `${(estimatedSizeKB / 1024).toFixed(2)} MB`;
        }
    } catch (error) {
        return "æœªçŸ¥";
    }
}

// æ˜¾ç¤ºæ•°æ®åº“ä¿¡æ¯
function showDBInfo() {
    const infoElement = document.getElementById("dbInfo");
    if (infoElement.style.display === "none") {
        infoElement.style.display = "block";
    } else {
        infoElement.style.display = "none";
    }
}

// ä»æ•°æ®åº“åŠ è½½è¿‘100æœŸèµ°åŠ¿å›¾
async function loadTrendFromDBRecent100() {
    if (!db) {
        alert("æ•°æ®åº“æœªåˆå§‹åŒ–");
        return;
    }
    
    try {
        const trendData = await loadTrendDataFromDB();
        if (trendData.length === 0) {
            alert("æ•°æ®åº“ä¸­æ²¡æœ‰èµ°åŠ¿å›¾æ•°æ®");
            return;
        }
        
        // æŒ‰æœŸå·æ’åºï¼Œå–æœ€è¿‘100æœŸ
        const sortedData = trendData.slice().sort((a, b) => {
            const ai = isNaN(a.issue) ? a.issue : Number(a.issue);
            const bi = isNaN(b.issue) ? b.issue : Number(b.issue);
            if (ai < bi) return 1;
            if (ai > bi) return -1;
            return 0;
        });
        
        // å–æœ€è¿‘100æœŸ
        const recent100Data = sortedData.slice(0, 100);
        
        if (recent100Data.length === 0) {
            alert("æ²¡æœ‰å¯ç”¨çš„èµ°åŠ¿å›¾æ•°æ®");
            return;
        }
        
        // æ›´æ–°èµ°åŠ¿å›¾æ•°æ®ä¸ºæœ€è¿‘100æœŸ
        trendAllData = recent100Data;
        trendCurrentPage = 1;
        trendUpdatePageSize();
        trendShowDataPreview();
        
        alert(`ä»æ•°æ®åº“åŠ è½½äº†æœ€è¿‘ ${recent100Data.length} æœŸèµ°åŠ¿å›¾æ•°æ®`);
        
        // è‡ªåŠ¨ç”Ÿæˆèµ°åŠ¿å›¾
        setTimeout(() => {
            generateTrendChart();
        }, 500);
        
    } catch (error) {
        alert("åŠ è½½èµ°åŠ¿å›¾æ•°æ®å¤±è´¥: " + error.message);
        console.error(error);
    }
}

// ä»æ•°æ®åº“åŠ è½½èµ°åŠ¿å›¾æ•°æ®
async function loadTrendFromDB() {
    if (!db) {
        alert("æ•°æ®åº“æœªåˆå§‹åŒ–");
        return;
    }
    
    try {
        const trendData = await loadTrendDataFromDB();
        if (trendData.length === 0) {
            alert("æ•°æ®åº“ä¸­æ²¡æœ‰èµ°åŠ¿å›¾æ•°æ®");
            return;
        }
        
        trendAllData = trendData;
        trendCurrentPage = 1;
        trendUpdatePageSize();
        trendShowDataPreview();
        
        alert(`ä»æ•°æ®åº“åŠ è½½äº† ${trendData.length} æ¡èµ°åŠ¿å›¾æ•°æ®`);
        
        // è‡ªåŠ¨ç”Ÿæˆèµ°åŠ¿å›¾
        setTimeout(() => {
            generateTrendChart();
        }, 500);
        
    } catch (error) {
        alert("åŠ è½½èµ°åŠ¿å›¾æ•°æ®å¤±è´¥: " + error.message);
        console.error(error);
    }
}

// ä¿å­˜èµ°åŠ¿å›¾æ•°æ®åˆ°æ•°æ®åº“
async function saveTrendToDB() {
    if (!trendAllData.length) {
        alert("æ²¡æœ‰èµ°åŠ¿å›¾æ•°æ®å¯ä¿å­˜");
        return;
    }
    
    try {
        await saveTrendDataToDB();
        alert(`èµ°åŠ¿å›¾æ•°æ®å·²ä¿å­˜åˆ°æ•°æ®åº“ï¼Œå…± ${trendAllData.length} æ¡è®°å½•`);
        
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        updateDBStats();
        
    } catch (error) {
        alert("ä¿å­˜èµ°åŠ¿å›¾æ•°æ®å¤±è´¥: " + error.message);
        console.error(error);
    }
}

// ================== åŸæœ‰å‡½æ•° ==================
function updateCurrentTime() {
    const now = new Date();
    const utcStr = now.toISOString().substr(11, 8);
    document.getElementById('currentUTC').textContent = utcStr;

    const utc8 = new Date(now.getTime() + 8 * 60 * 60 * 1000);
    const utc8Str = utc8.toISOString().substr(11, 8);
    document.getElementById('currentUTC8').textContent = utc8Str;

    const utc8Hours = utc8.getUTCHours();
    const utc8Minutes = utc8.getUTCMinutes();
    const utc8Seconds = utc8.getUTCSeconds();
    const totalSecondsUTC8 = utc8Hours * 3600 + utc8Minutes * 60 + utc8Seconds;

    // æ³¢åœº30ç§’èµ›è½¦ï¼šæ¯å¤©ç¬¬ä¸€æœŸ 00:00:33ï¼ˆUTC+8ï¼‰ï¼Œæ¯30ç§’ä¸€æœŸï¼Œæ¯å¤©2880æœŸï¼›
    // ç¬¬2880æœŸè·¨å¤©åˆ°ç¬¬äºŒå¤©00:00:03ï¼ˆæœŸå·æ—¥æœŸä¿æŒå‰ä¸€å¤©ï¼‰
    let currentPhaseUTC8;
    
    if (totalSecondsUTC8 < FIRST_DRAW_SECOND_UTC8) {
        // 00:00:00~00:00:32ï¼šå±äºå‰ä¸€å¤©çš„æœ€åä¸€æœŸï¼ˆç¬¬2880æœŸï¼Œå¼€å¥–æ—¶é—´00:00:03ï¼‰
        currentPhaseUTC8 = PHASES_PER_DAY;
    } else {
        // 00:00:33ä¹‹åï¼šæ­£å¸¸è®¡ç®—ï¼ˆæ¯30ç§’ä¸€æœŸï¼‰
        const adjustedSeconds = totalSecondsUTC8 - FIRST_DRAW_SECOND_UTC8;
        currentPhaseUTC8 = Math.floor(adjustedSeconds / DRAW_INTERVAL_SECONDS) + 1;
        if (currentPhaseUTC8 < 1) currentPhaseUTC8 = 1;
        // æ³¨æ„ï¼šå½“æ—¥è‡ªç„¶æ—¥å†…æœ€é«˜ä¼šåˆ° 2879ï¼ˆ23:59:33ï¼‰ï¼Œç¬¬2880æœŸè·¨å¤©åˆ°æ¬¡æ—¥00:00:03
        if (currentPhaseUTC8 > PHASES_PER_DAY - 1) currentPhaseUTC8 = PHASES_PER_DAY - 1;
    }

    document.getElementById('currentPhaseUTC8').textContent = currentPhaseUTC8;

    // è®¡ç®—ä¸‹ä¸€æœŸå¼€å¥–æ—¶é—´
    const nextPhaseUTC8 = currentPhaseUTC8 >= PHASES_PER_DAY ? 1 : currentPhaseUTC8 + 1;
    const nextTotalSeconds = (nextPhaseUTC8 - 1) * DRAW_INTERVAL_SECONDS + FIRST_DRAW_SECOND_UTC8;
    const nextHourUTC8 = Math.floor(nextTotalSeconds / 3600) % 24;
    const nextMinuteUTC8 = Math.floor((nextTotalSeconds % 3600) / 60);
    const nextSecondUTC8 = nextTotalSeconds % 60;
    document.getElementById('nextDrawUTC8').textContent =
        `${nextHourUTC8.toString().padStart(2, '0')}:${nextMinuteUTC8.toString().padStart(2, '0')}:${nextSecondUTC8.toString().padStart(2, '0')}`;

    const todayUTC8 = utc8.toISOString().split('T')[0];
    if (!document.getElementById('queryDateUTC8').value) {
        document.getElementById('queryDateUTC8').value = todayUTC8;
    }
    if (!document.getElementById('batchStartDateUTC8').value) {
        document.getElementById('batchStartDateUTC8').value = todayUTC8;
    }
    if (!document.getElementById('batchEndDateUTC8').value) {
        document.getElementById('batchEndDateUTC8').value = todayUTC8;
    }
}
setInterval(updateCurrentTime, 1000);
updateCurrentTime();

// ================== TRON API å·¥å…·å‡½æ•° ==================
function buildTronBlockApiUrl(params = {}) {
    // Support relative proxy path (e.g. /api/block) or full URL
    let url;
    try {
        if (TRON_BLOCK_API_URL.startsWith('http')) {
            url = new URL(TRON_BLOCK_API_URL);
        } else {
            url = new URL(TRON_BLOCK_API_URL, window.location.origin);
        }
    } catch (e) {
        url = new URL(TRON_BLOCK_API_URL, window.location.origin);
    }
    for (const [key, value] of Object.entries(params)) {
        if (value === null || typeof value === 'undefined') continue;
        url.searchParams.set(key, String(value));
    }
    return url.toString();
}

function extractTronBlocks(payload) {
    if (!payload) return [];
    if (Array.isArray(payload)) return payload;
    if (Array.isArray(payload.data)) return payload.data;
    if (Array.isArray(payload.blocks)) return payload.blocks;
    if (Array.isArray(payload.items)) return payload.items;
    return [];
}

async function checkV2APIStatus() {
    const statusDiv = document.getElementById('apiStatus');
    const resultDiv = document.getElementById('singleResult');
    statusDiv.textContent = "æ£€æµ‹ä¸­...";
    statusDiv.style.color = "#f39c12";
    try {
        // ä½¿ç”¨ TronScan æœ€æ–°åŒºå—æ¥å£åšè¿é€šæ€§æ£€æµ‹
        const url = `${TRON_BLOCK_API_URL}?start=0&limit=1&sort=-timestamp`;
        // Call proxy; proxy will add TRON-PRO-API-KEY header server-side
        const response = await fetch(url);
        const data = await response.json();
        const blocks = extractTronBlocks(data);
        if (blocks && blocks.length > 0) {
            statusDiv.textContent = "âœ“ TRON APIæ­£å¸¸";
            statusDiv.style.color = "#27ae60";
            resultDiv.innerHTML = `
                <div class="success">
                    <strong>âœ“ TRON API è¿æ¥æˆåŠŸï¼</strong><br>
                    <strong>API ç«¯ç‚¹ï¼š</strong> TronScan /api/block<br>
                    <strong>æ£€æµ‹æ—¶é—´ï¼š</strong> ${new Date().toLocaleString('zh-CN')}<br>
                    <strong>æµ‹è¯•URLï¼š</strong> <small>${url}</small>
                </div>
            `;
        } else {
            statusDiv.textContent = "âœ— TRON APIå¼‚å¸¸";
            statusDiv.style.color = "#e74c3c";
            resultDiv.innerHTML = `
                <div class="error">
                    <strong>âœ— TRON API è¿æ¥å¼‚å¸¸</strong><br>
                    <strong>é”™è¯¯ä¿¡æ¯ï¼š</strong> ${data.message || "è¿”å›æ•°æ®å¼‚å¸¸"}<br>
                    <strong>å»ºè®®ï¼š</strong><br>
                    1. æ£€æŸ¥ç½‘ç»œè¿æ¥<br>
                    2. æ£€æŸ¥ TRON-PRO-API-KEY æ˜¯å¦æœ‰æ•ˆ<br>
                    3. æ£€æŸ¥æ˜¯å¦è¢«CORSé™åˆ¶ï¼ˆå¯å°è¯•æœ¬åœ°æœåŠ¡å™¨è¿è¡Œï¼‰<br>
                    <strong>æµ‹è¯•URLï¼š</strong><br>
                    <small>${url}</small>
                </div>
            `;
        }
    } catch (error) {
        statusDiv.textContent = "âœ— ç½‘ç»œé”™è¯¯";
        statusDiv.style.color = "#e74c3c";
        resultDiv.innerHTML = `
            <div class="error">
                <strong>âœ— ç½‘ç»œè¿æ¥å¤±è´¥</strong><br>
                <strong>é”™è¯¯ä¿¡æ¯ï¼š</strong> ${error.message}<br>
                <strong>å¯èƒ½åŸå› ï¼š</strong><br>
                1. ç½‘ç»œè¿æ¥é—®é¢˜<br>
                2. CORSé™åˆ¶ï¼ˆè¯·å°è¯•åœ¨æœåŠ¡å™¨ä¸Šè¿è¡Œï¼‰<br>
                3. APIæœåŠ¡æš‚æ—¶ä¸å¯ç”¨<br>
                <strong>å»ºè®®ï¼š</strong><br>
                1. æ£€æŸ¥æ˜¯å¦èƒ½è®¿é—® <a href="https://apilist.tronscanapi.com" target="_blank">apilist.tronscanapi.com</a><br>
                2. å°è¯•ä½¿ç”¨VPNæˆ–ä»£ç†<br>
                3. ç¨åé‡è¯•
            </div>
        `;
    }
}

// ================== ä¿®æ”¹ç¼“å­˜å‡½æ•°ï¼šè‡ªåŠ¨å¼€å¥–æ¨¡å¼ä¸‹ç¦ç”¨ç¼“å­˜ ==================
function getFromCache(key) {
    // å½“è‡ªåŠ¨å¼€å¥–è¿è¡Œæ—¶ï¼Œç¦ç”¨ç¼“å­˜
    if (isAutoDrawRunning) {
        return null;
    }
    
    const cacheKey = CACHE_PREFIX + key;
    const cached = localStorage.getItem(cacheKey);
    if (cached) {
        const data = JSON.parse(cached);
        const now = Date.now();
        if (now - data.timestamp < CACHE_DURATION) {
            return data.value;
        } else {
            localStorage.removeItem(cacheKey);
        }
    }
    return null;
}
function saveToCache(key, value) {
    // å½“è‡ªåŠ¨å¼€å¥–è¿è¡Œæ—¶ï¼Œä¸ä¿å­˜ç¼“å­˜
    if (isAutoDrawRunning) {
        return;
    }
    
    const cacheKey = CACHE_PREFIX + key;
    const cacheData = { timestamp: Date.now(), value: value };
    localStorage.setItem(cacheKey, JSON.stringify(cacheData));
}

// æ³¢åœº30ç§’èµ›è½¦ï¼šç¬¬2880æœŸè·¨å¤©åˆ°ç¬¬äºŒå¤©00:00:03ï¼ˆUTC+8ï¼‰
function getDrawTimeUTC(dateStrUTC8, qiUTC8) {
    if (qiUTC8 < 1 || qiUTC8 > PHASES_PER_DAY) return null;
    
    // ç‰¹æ®Šå¤„ç†ç¬¬2880æœŸï¼šè·¨å¤©åˆ°ç¬¬äºŒå¤©çš„00:00:03ï¼ˆUTC+8ï¼‰
    if (qiUTC8 === PHASES_PER_DAY) {
        // ç¬¬2880æœŸå¼€å¥–æ—¶é—´æ˜¯ç¬¬äºŒå¤©çš„00:00:03ï¼ˆUTC+8ï¼‰
        // ä½†æœŸå·ä¸­çš„æ—¥æœŸä¿æŒå‰ä¸€å¤©ï¼Œå®é™…æŸ¥è¯¢æ—¶ä½¿ç”¨UTCå½“å¤©16:00:03
        const date = new Date(`${dateStrUTC8}T00:00:00+08:00`);
        date.setDate(date.getDate() + 1); // æ—¥æœŸåŠ ä¸€å¤©ï¼Œå¾—åˆ°ç¬¬äºŒå¤©çš„æ—¥æœŸ
        const adjustedDateStrUTC8 = date.toISOString().split('T')[0];
        const timeStrUTC8 = "00:00:03";
        
        // UTC+8çš„ç¬¬äºŒå¤©00:00:03 = UTCçš„å½“å¤©16:00:03ï¼ˆæœŸå·æ—¥æœŸå¯¹åº”çš„UTCå½“å¤©ï¼‰
        // æ‰€ä»¥ç›´æ¥ä½¿ç”¨æœŸå·æ—¥æœŸï¼ˆdateStrUTC8ï¼‰å¯¹åº”çš„UTCæ—¶é—´16:00:03
        const dateUTC8 = new Date(`${dateStrUTC8}T16:00:03+00:00`);
        const utcTimeStr = dateUTC8.toISOString().replace('T', ' ').substring(0, 19);
        return { 
            utc: utcTimeStr, 
            utc8: `${adjustedDateStrUTC8} ${timeStrUTC8}`, 
            originalDate: dateStrUTC8 
        };
    }
    
    // å…¶ä»–æœŸæ­£å¸¸è®¡ç®—ï¼šç¬¬ä¸€æœŸ00:00:33ï¼Œä¹‹åæ¯30ç§’ä¸€æœŸï¼ˆ1~2879ï¼‰
    const totalSecondsUTC8 = (qiUTC8 - 1) * DRAW_INTERVAL_SECONDS + FIRST_DRAW_SECOND_UTC8;
    const hoursUTC8 = Math.floor(totalSecondsUTC8 / 3600) % 24;
    const minsUTC8 = Math.floor((totalSecondsUTC8 % 3600) / 60);
    const secsUTC8 = totalSecondsUTC8 % 60;
    const timeStrUTC8 = `${hoursUTC8.toString().padStart(2, '0')}:${minsUTC8.toString().padStart(2, '0')}:${secsUTC8.toString().padStart(2, '0')}`;
    
    // å¤„ç†è·¨å¤©ï¼ˆç†è®ºä¸Š1~2879ä¸ä¼šè·¨å¤©ï¼Œè¿™é‡Œä¿ç•™é€šç”¨é€»è¾‘ï¼‰
    let adjustedDateStrUTC8 = dateStrUTC8;
    if (hoursUTC8 >= 24) {
        const date = new Date(`${dateStrUTC8}T00:00:00+08:00`);
        date.setDate(date.getDate() + 1);
        adjustedDateStrUTC8 = date.toISOString().split('T')[0];
    }
    
    const dateUTC8 = new Date(`${adjustedDateStrUTC8}T${timeStrUTC8}+08:00`);
    const utcTimeStr = dateUTC8.toISOString().replace('T', ' ').substring(0, 19);
    return { utc: utcTimeStr, utc8: `${adjustedDateStrUTC8} ${timeStrUTC8}`, originalDate: dateStrUTC8 };
}

function getPhaseFormat(dateStrUTC8, qiUTC8) {
    const year = dateStrUTC8.substring(0, 4);
    const month = dateStrUTC8.substring(5, 7);
    const day = dateStrUTC8.substring(8, 10);
    // æœŸå·æ ¼å¼4ä½ï¼šæ¯å¤©æœ€å¤š2880æœŸ
    const phaseStr = qiUTC8.toString().padStart(4, '0');
    return `${year}${month}${day}${phaseStr}`;
}
function getTimestamp(timeStr) {
    return Math.floor(new Date(timeStr + ' UTC').getTime() / 1000);
}

function getTronBlockTimestampMs(block) {
    if (!block) return null;
    const t = block.timestamp ?? block.time ?? block.block_timestamp ?? block.blockTime ?? block.block_time;
    if (t === null || typeof t === 'undefined') return null;
    const n = Number(t);
    if (Number.isFinite(n) && n > 0) {
        // Tron å¸¸è§ä¸ºæ¯«ç§’(13ä½)ï¼Œä¹Ÿå¯èƒ½æ˜¯ç§’(10ä½)ï¼šç»Ÿä¸€è½¬ä¸ºæ¯«ç§’
        return n < 1e12 ? n * 1000 : n;
    }
    return null;
}

function getTronBlockNumber(block) {
    if (!block) return null;
    const n = block.number ?? block.height ?? block.blockNumber ?? block.block_num ?? block.blockNum;
    if (n === null || typeof n === 'undefined') return null;
    const num = Number(n);
    if (Number.isFinite(num)) return String(Math.trunc(num));
    if (typeof n === 'string' && n.trim()) return n.trim();
    return null;
}

function getTronBlockHash(block) {
    if (!block) return null;
    // TronScan å¸¸è§å­—æ®µï¼šblockID / hash / id
    const h = block.hash ?? block.blockID ?? block.blockId ?? block.id ?? block.block_id;
    if (typeof h === 'string' && h.trim()) return h.trim();
    return null;
}

// å†…å­˜ç¼“å­˜ï¼šç”¨äºè‡ªåŠ¨å¼€å¥–æ¨¡å¼ï¼ˆè‡ªåŠ¨å¼€å¥–æ—¶localStorageç¼“å­˜è¢«ç¦ç”¨ï¼‰
const tronBlockHashMem = new Map(); // blockNumber -> blockHash
const tronBlockPageMem = new Map(); // `${start}_${limit}` -> { ts, blocks }
const TRON_PAGE_CACHE_TTL_MS = 1200; // çº¦1.2ç§’ï¼Œé¿å…â€œæœ€æ–°å—â€è¢«ç¼“å­˜ä½å¯¼è‡´ä¸€ç›´åŒä¸€å—

async function fetchTronBlockPage(start = 0, limit = 50) {
    const memKey = `${start}_${limit}`;
    const memCached = tronBlockPageMem.get(memKey);
    // start=0 æ˜¯â€œæœ€æ–°åŒºå—åˆ—è¡¨â€ï¼Œå¿…é¡»å°½é‡å®æ—¶ï¼šä¸èµ°ç¼“å­˜
    if (memCached && start !== 0) {
        const age = Date.now() - (memCached.ts || 0);
        if (age >= 0 && age < TRON_PAGE_CACHE_TTL_MS) {
            return memCached.blocks;
        }
    }
    const url = buildTronBlockApiUrl({ start, limit, sort: '-timestamp' });
    // Use proxy without exposing API key
    const response = await fetch(url);
    const data = await response.json();
    const blocks = extractTronBlocks(data);
    tronBlockPageMem.set(memKey, { ts: Date.now(), blocks });
    // ç®€å•çš„å†…å­˜ä¿æŠ¤ï¼šé¡µç¼“å­˜å¤ªå¤§æ—¶æ¸…ç©ºï¼ˆé¿å…æ— é™å¢é•¿ï¼‰
    if (tronBlockPageMem.size > 500) tronBlockPageMem.clear();
    return blocks;
}

async function tryFetchTronBlocksAround(targetMs) {
    // å°è¯•ç”¨â€œæ—¶é—´çª—å£â€å‚æ•°ç›´æ¥å–é™„è¿‘åŒºå—ï¼ˆè‹¥APIæ”¯æŒå¯æ˜¾è‘—æé€Ÿï¼›è‹¥ä¸æ”¯æŒåˆ™å›é€€åˆ°åˆ†é¡µæ‰«æï¼‰
    const windowMs = 5 * 60 * 1000; // 5åˆ†é’Ÿçª—å£
    const url = buildTronBlockApiUrl({
        start_timestamp: targetMs - windowMs,
        end_timestamp: targetMs + windowMs,
        limit: 200,
        sort: 'timestamp'
    });
    try {
        // Query via proxy (server injects API key)
        const response = await fetch(url);
        const data = await response.json();
        const blocks = extractTronBlocks(data);
        if (!blocks || blocks.length === 0) return null;

        // åˆ¤æ–­æ˜¯å¦çœŸçš„â€œå‘½ä¸­é™„è¿‘â€ï¼Œé¿å…APIå¿½ç•¥å‚æ•°å¯¼è‡´è¿”å›æœ€æ–°å—
        let bestDelta = Infinity;
        for (const b of blocks) {
            const ts = getTronBlockTimestampMs(b);
            if (ts === null) continue;
            const d = Math.abs(ts - targetMs);
            if (d < bestDelta) bestDelta = d;
        }
        if (bestDelta > windowMs) return null;
        return blocks;
    } catch (e) {
        return null;
    }
}

// è·å–â€œæœ€æ¥è¿‘å¼€å¥–æ—¶é—´ä¹‹åâ€çš„åŒºå—ï¼ˆclosest afterï¼‰ï¼Œç”¨äºè®¡ç®—ç»“æœï¼ˆä¸æ—§é€»è¾‘ä¿æŒä¸€è‡´ï¼‰
async function getTronBlockInfoByTimestamp(timestampSeconds) {
    // å°†é€‰æ‹©æ—¶é—´å‘ååç§»ä»¥ç¡®ä¿é€‰åˆ°â€œå¼€å¥–æ—¶é—´ä¹‹åâ€çš„åŒºå—
    const offsetMs = Number(TRON_BLOCK_SELECTION_OFFSET_MS) || 0;
    const cacheKey = `tron_blockinfo_${timestampSeconds}_${offsetMs}`;
    const cached = getFromCache(cacheKey);
    if (cached) return cached;

    const targetMs = Number(timestampSeconds) * 1000;
    if (!Number.isFinite(targetMs) || targetMs <= 0) {
        throw new Error("TRON: æ— æ•ˆçš„æ—¶é—´æˆ³");
    }

    const selectMs = targetMs + offsetMs;

    // ä¼˜å…ˆå°è¯•â€œé™„è¿‘åŒºå—â€å¿«é€ŸæŸ¥è¯¢ï¼ˆè‹¥APIæ”¯æŒï¼‰
    const around = await tryFetchTronBlocksAround(selectMs);
    if (around && around.length > 0) {
        // æŒ‰æ—¶é—´å‡åºï¼Œæ‰¾æœ€å°çš„ ts>=target
        const sorted = around.slice().sort((x, y) => {
            const tx = getTronBlockTimestampMs(x) ?? 0;
            const ty = getTronBlockTimestampMs(y) ?? 0;
            return tx - ty;
        });
        let picked = null;
        for (const b of sorted) {
            const ts = getTronBlockTimestampMs(b);
            if (ts !== null && ts >= selectMs) { picked = b; break; }
        }
        if (!picked) picked = sorted[sorted.length - 1];
        const blockNumber = getTronBlockNumber(picked);
        const blockHash = getTronBlockHash(picked);
        const blockTs = getTronBlockTimestampMs(picked);
        if (blockNumber && blockHash && blockTs) {
            const info = { blockNumber, blockHash, blockTimestamp: blockTs };
            tronBlockHashMem.set(blockNumber, blockHash);
            saveToCache(cacheKey, info);
            saveToCache(`blockhash_${blockNumber}`, blockHash);
            return info;
        }
        // è‹¥å­—æ®µä¸å…¨ï¼Œç»§ç»­èµ°åˆ†é¡µæ‰«æ
    }

    const limit = 100;

    // å…ˆæ‹¿æœ€æ–°é¡µï¼Œç”¨äºä¼°ç®—åç§»ï¼ˆé¿å…ä»0ä¸€è·¯æ‰«åˆ°å¾ˆä¹…ä»¥å‰ï¼‰
    const firstPage = await fetchTronBlockPage(0, limit);
    if (!firstPage || firstPage.length === 0) {
        throw new Error("TRON: æ— æ³•è·å–æœ€æ–°åŒºå—åˆ—è¡¨ï¼ˆå¯èƒ½æ˜¯CORS/ç½‘ç»œ/APIé™åˆ¶ï¼‰");
    }
    const newest = firstPage[0];
    const newestTs = getTronBlockTimestampMs(newest);
    if (newestTs === null) {
        throw new Error("TRON: æœ€æ–°åŒºå—ç¼ºå°‘timestampå­—æ®µ");
    }

    // è‹¥é€‰æ‹©æ—¶é—´åœ¨æœªæ¥ï¼šç›´æ¥å–æœ€æ–°å—
    if (selectMs > newestTs) {
        const blockNumber = getTronBlockNumber(newest);
        const blockHash = getTronBlockHash(newest);
        const blockTs = newestTs;
        if (!blockNumber || !blockHash) throw new Error("TRON: æœ€æ–°åŒºå—å­—æ®µç¼ºå¤±");
        const info = { blockNumber, blockHash, blockTimestamp: blockTs };
        tronBlockHashMem.set(blockNumber, blockHash);
        saveToCache(cacheKey, info);
        saveToCache(`blockhash_${blockNumber}`, blockHash);
        return info;
    }

    // ä½¿ç”¨å¹³å‡å‡ºå—æ—¶é—´ä¼°ç®— start åç§»ï¼ˆTRONçº¦3ç§’/å—ï¼‰
    const avgBlockTimeSec = 3;
    const diffSec = Math.max(0, Math.floor((newestTs - targetMs) / 1000));
    let start = Math.max(0, Math.floor(diffSec / avgBlockTimeSec) - limit);

    const visited = new Set();
    for (let iter = 0; iter < 80; iter++) {
        const key = `${start}`;
        if (visited.has(key)) break;
        visited.add(key);

        const blocks = await fetchTronBlockPage(start, limit);
        if (!blocks || blocks.length === 0) break;

        const tsFirst = getTronBlockTimestampMs(blocks[0]);
        const tsLast = getTronBlockTimestampMs(blocks[blocks.length - 1]);
        if (tsFirst === null || tsLast === null) {
            // å­—æ®µä¸å…¨ï¼Œå‘åç¿»é¡µç»§ç»­å°è¯•
            start += limit;
            continue;
        }

        // é€‰æ‹©æ—¶é—´æ¯”æœ¬é¡µæœ€æ–°å—è¿˜æ–° -> å¾€â€œæ›´æ–°â€çš„æ–¹å‘èµ°ï¼ˆå‡å°startï¼‰
        if (selectMs > tsFirst) {
            start = Math.max(0, start - limit);
            continue;
        }
        // é€‰æ‹©æ—¶é—´æ¯”æœ¬é¡µæœ€æ—§å—è¿˜æ—§ -> å¾€â€œæ›´æ—§â€çš„æ–¹å‘èµ°ï¼ˆå¢å¤§startï¼‰
        if (selectMs < tsLast) {
            start += limit;
            continue;
        }

        // targetMs åœ¨æœ¬é¡µæ—¶é—´èŒƒå›´å†…ï¼Œæ‰«ææ‰¾ closest-afterï¼ˆæœ€å° ts>=targetï¼‰
        let lastCandidate = null;
        for (const b of blocks) {
            const ts = getTronBlockTimestampMs(b);
            if (ts === null) continue;
            if (ts >= selectMs) {
                lastCandidate = b;
                continue;
            }
            if (lastCandidate) break;
        }

        const picked = lastCandidate || blocks[0];
        const blockNumber = getTronBlockNumber(picked);
        const blockHash = getTronBlockHash(picked);
        const blockTs = getTronBlockTimestampMs(picked);
        if (!blockNumber || !blockHash || !blockTs) throw new Error("TRON: åŒºå—å­—æ®µç¼ºå¤±");
        const info = { blockNumber, blockHash, blockTimestamp: blockTs };
        tronBlockHashMem.set(blockNumber, blockHash);
        saveToCache(cacheKey, info);
        saveToCache(`blockhash_${blockNumber}`, blockHash);
        return info;
    }

    throw new Error("TRON: æ— æ³•å®šä½æŒ‡å®šæ—¶é—´æˆ³å¯¹åº”çš„åŒºå—ï¼ˆå¯èƒ½æ˜¯APIèƒ½åŠ›/å‚æ•°é™åˆ¶ï¼Œæˆ–ç½‘ç»œ/CORSé—®é¢˜ï¼‰");
}

// å…¼å®¹æ—§è°ƒç”¨ï¼šä»ä¿ç•™å‡½æ•°åï¼Œä½†å†…éƒ¨æ”¹ä¸ºTRONå®ç°
async function getBlockNumberByTimestampV2(timestamp) {
    const info = await getTronBlockInfoByTimestamp(timestamp);
    return info.blockNumber;
}

async function getBlockHashByNumberV2(blockNumber) {
    const mem = tronBlockHashMem.get(String(blockNumber));
    if (mem) return mem;
    const cacheKey = `blockhash_${blockNumber}`;
    const cached = getFromCache(cacheKey);
    if (cached) return cached;
    // æ²¡æœ‰æŒ‰é«˜åº¦æŸ¥è¯¢çš„ç¡®å®šæ¥å£æ—¶ï¼Œé€€åŒ–ä¸ºâ€œæŠ›é”™æç¤ºâ€
    throw new Error("TRON: æœªå‘½ä¸­åŒºå—å“ˆå¸Œç¼“å­˜ï¼Œè¯·å…ˆé€šè¿‡æ—¶é—´æˆ³æŸ¥è¯¢è¯¥æœŸåŒºå—");
}

function calculateResult(hash) {
    hash = hash.replace("0x", "").toLowerCase();
    let used = new Set();
    let chars = [];
    for (let i = hash.length - 1; i >= 0; i--) {
        const char = hash[i];
        if (!used.has(char) && charOrder.includes(char)) {
            used.add(char);
            chars.push(char);
            if (chars.length === 10) break;
        }
    }
    if (chars.length < 10) {
        for (let i = 0; i < 16 && chars.length < 10; i++) {
            const char = charOrder[i];
            if (!used.has(char)) {
                used.add(char);
                chars.push(char);
            }
        }
    }
    const charToCar = {};
    chars.forEach((char, index) => {
        charToCar[char] = index + 1;
    });
    const sortedChars = [...chars].sort((a, b) => {
        return charOrder.indexOf(b) - charOrder.indexOf(a);
    });
    const result = sortedChars.map(char => {
        return charToCar[char].toString().padStart(2, '0');
    });
    return {
        result: result,
        chars: chars,
        sortedChars: sortedChars,
        charToCar: charToCar,
        hash: "0x" + hash
    };
}

function displayAPIDetails(apiCalls) {
    let html = `<div class="info-box" style="margin:15px 0; padding:10px; background:#f0f8ff; border-radius:5px;">
        <h4 style="margin-top:0;">ğŸ”§ API è°ƒç”¨è¯¦æƒ…</h4>`;
    apiCalls.forEach((call, index) => {
        html += `<div style="margin-bottom:10px; padding:8px; background:#fff; border-radius:3px; border-left:4px solid #3498db;">
            <strong>${index + 1}. ${call.name}</strong><br>
            <small><strong>URL:</strong> ${call.url}</small><br>`;
        if (call.response) {
            html += `<small><strong>å“åº”:</strong> ${JSON.stringify(call.response).substring(0, 100)}...</small>`;
        }
        if (call.error) {
            html += `<small style="color:#e74c3c;"><strong>é”™è¯¯:</strong> ${call.error}</small>`;
        }
        html += `</div>`;
    });
    html += `</div>`;
    return html;
}

// ================== æ–°å¢è‡ªåŠ¨å¼€å¥–å‡½æ•° ==================
// è·å–ä¸‹ä¸€æœŸçš„æ—¥æœŸå’ŒæœŸå·
function getNextPhase(dateStrUTC8, phase) {
    let nextDate = dateStrUTC8;
    let nextPhase = phase + 1;
    
    if (nextPhase > PHASES_PER_DAY) {
        // è·¨å¤©åˆ°ç¬¬äºŒå¤©
        const date = new Date(`${dateStrUTC8}T00:00:00+08:00`);
        date.setDate(date.getDate() + 1);
        nextDate = date.toISOString().split('T')[0];
        nextPhase = 1;
    }
    
    return { date: nextDate, phase: nextPhase };
}

// æ›´æ–°è‡ªåŠ¨å¼€å¥–çŠ¶æ€æ˜¾ç¤º
function updateAutoDrawStatus() {
    const detailsElement = document.getElementById('autoDrawDetails');
    const currentPhaseElement = document.getElementById('autoDrawCurrentPhase');
    const nextTimeElement = document.getElementById('autoDrawNextTime');
    const retryCountElement = document.getElementById('autoDrawRetryCount');
    
    if (!detailsElement || !currentPhaseElement || !nextTimeElement || !retryCountElement) return;
    
    if (isAutoDrawRunning && autoDrawCurrentDate && autoDrawCurrentPhase) {
        detailsElement.style.display = 'block';
        
        // è®¡ç®—å½“å‰æœŸçš„å¼€å¥–æ—¶é—´
        const drawTimes = getDrawTimeUTC(autoDrawCurrentDate, autoDrawCurrentPhase);
        if (drawTimes) {
            const drawTimeStr = drawTimes.utc8.split(' ')[1];
            currentPhaseElement.textContent = `å½“å‰æœŸ: ${getPhaseFormat(autoDrawCurrentDate, autoDrawCurrentPhase)} (${drawTimeStr})`;
        } else {
            currentPhaseElement.textContent = `å½“å‰æœŸ: ${getPhaseFormat(autoDrawCurrentDate, autoDrawCurrentPhase)}`;
        }
        
        // è®¡ç®—ä¸‹ä¸€æœŸå¼€å¥–æ—¶é—´
        const nextPhase = getNextPhase(autoDrawCurrentDate, autoDrawCurrentPhase);
        const nextDrawTimes = getDrawTimeUTC(nextPhase.date, nextPhase.phase);
        if (nextDrawTimes) {
            const nextTimeStr = nextDrawTimes.utc8.split(' ')[1];
            nextTimeElement.textContent = `ä¸‹ä¸€æœŸ: ${nextTimeStr}`;
        }
        
        retryCountElement.textContent = `é‡è¯•: ${autoDrawRetryCount}æ¬¡`;
    } else {
        detailsElement.style.display = 'none';
    }
}

function toggleAutoDraw() {
    const switchElement = document.getElementById('autoSwitch');
    const statusElement = document.getElementById('autoStatus');
    const countdownElement = document.getElementById('countdown');
    
    if (switchElement.checked) {
        // å¼€å¯è‡ªåŠ¨å¼€å¥–
        isAutoDrawRunning = true;
        statusElement.textContent = 'è¿è¡Œä¸­';
        statusElement.className = 'auto-status on';
        countdownElement.textContent = 'è®¡ç®—ä¸­...';
        
        // é‡ç½®é‡è¯•è®¡æ•°
        autoDrawRetryCount = 0;
        
        // è®¡ç®—å½“å‰æœŸï¼ˆä¿®å¤è·¨å¤©é€»è¾‘ï¼‰
        const now = new Date();
        const utc8 = new Date(now.getTime() + 8 * 60 * 60 * 1000);
        let todayUTC8 = utc8.toISOString().split('T')[0];

        const utc8Hours = utc8.getUTCHours();
        const utc8Minutes = utc8.getUTCMinutes();
        const utc8Seconds = utc8.getUTCSeconds();
        const totalSecondsUTC8 = utc8Hours * 3600 + utc8Minutes * 60 + utc8Seconds;

        let currentPhaseUTC8;
        let queryDateUTC8 = todayUTC8;
        
        // å¤„ç†è·¨å¤©é€»è¾‘ï¼ˆæ³¢åœº30ç§’èµ›è½¦ï¼‰
        // ç¬¬2880æœŸè·¨å¤©åˆ°ç¬¬äºŒå¤©00:00:03ï¼Œæ‰€ä»¥ï¼š
        // 1. 00:00:00 åˆ° 00:00:32 ä¹‹é—´ï¼šå‰ä¸€å¤©çš„2880æœŸï¼ˆå¼€å¥–æ—¶é—´00:00:03ï¼‰
        // 2. 00:00:33 å¼€å§‹ï¼šå½“å¤©ç¬¬1æœŸ
        if (totalSecondsUTC8 < FIRST_DRAW_SECOND_UTC8) {
            currentPhaseUTC8 = PHASES_PER_DAY;
            // æ—¥æœŸå‡ä¸€å¤©ï¼ˆæœŸå·æ—¥æœŸå±äºå‰ä¸€å¤©ï¼‰
            const yesterday = new Date(utc8);
            yesterday.setDate(yesterday.getDate() - 1);
            queryDateUTC8 = yesterday.toISOString().split('T')[0];
        } else {
            currentPhaseUTC8 = Math.floor((totalSecondsUTC8 - FIRST_DRAW_SECOND_UTC8) / DRAW_INTERVAL_SECONDS) + 1;
            if (currentPhaseUTC8 < 1) currentPhaseUTC8 = 1;
            // å½“æ—¥è‡ªç„¶æ—¥å†…æœ€é«˜åˆ°2879ï¼Œç¬¬2880æœŸè·¨å¤©åˆ°æ¬¡æ—¥00:00:03
            if (currentPhaseUTC8 > PHASES_PER_DAY - 1) currentPhaseUTC8 = PHASES_PER_DAY - 1;
        }
        
        // è®¾ç½®å½“å‰è‡ªåŠ¨å¼€å¥–æœŸå·
        autoDrawCurrentDate = queryDateUTC8;
        autoDrawCurrentPhase = currentPhaseUTC8;
        
        // åŒæ­¥åˆ°ç•Œé¢é€‰æ‹©æ¡†ï¼ˆå½“è‡ªåŠ¨å¼€å¥–å¼€å¯æ—¶è‡ªåŠ¨æ›´æ–°é€‰æ‹©ï¼‰
        try {
            const dateInput = document.getElementById('queryDateUTC8');
            const qihaoInput = document.getElementById('qihaoUTC8');
            if (dateInput) dateInput.value = autoDrawCurrentDate;
            if (qihaoInput) qihaoInput.value = autoDrawCurrentPhase;
        } catch (e) {
            console.warn('åŒæ­¥è‡ªåŠ¨å¼€å¥–æ—¥æœŸåˆ°é€‰æ‹©æ¡†å¤±è´¥', e);
        }

        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        updateAutoDrawStatus();
        
        // æ£€æŸ¥æ˜¯å¦å·²ç»ç”Ÿæˆèµ°åŠ¿å›¾ï¼Œå¦‚æœæ˜¯åˆ™å¯ç”¨è‡ªåŠ¨æ›´æ–°
        if (isTrendChartGenerated) {
            enableTrendAutoUpdate();
        }
        
        // è®¡ç®—å½“å‰æœŸå¼€å¥–æ—¶é—´
        const drawTimes = getDrawTimeUTC(autoDrawCurrentDate, autoDrawCurrentPhase);
        if (drawTimes) {
            const drawTime = new Date(drawTimes.utc8);
            const now = new Date();
            
            // è®¡ç®—è·ç¦»å¼€å¥–æ—¶é—´åçš„3ç§’
            const queryTime = new Date(drawTime.getTime() + 3000); // å¼€å¥–å3ç§’
            
            if (queryTime <= now) {
                // å¦‚æœå¼€å¥–æ—¶é—´å·²ç»è¿‡äº†3ç§’ï¼Œç«‹å³æŸ¥è¯¢
                startAutoDrawQuery();
            } else {
                // è®¡ç®—ç­‰å¾…æ—¶é—´
                const waitTime = queryTime.getTime() - now.getTime();
                countdownElement.textContent = formatTime(Math.floor(waitTime / 1000));
                
                // è®¾ç½®å®šæ—¶å™¨ï¼Œåœ¨å¼€å¥–å3ç§’å¼€å§‹æŸ¥è¯¢
                setTimeout(() => {
                    startAutoDrawQuery();
                }, waitTime);
                
                // æ¯ç§’æ›´æ–°å€’è®¡æ—¶
                autoDrawInterval = setInterval(() => {
                    const remaining = Math.max(0, queryTime.getTime() - Date.now());
                    countdownElement.textContent = formatTime(Math.floor(remaining / 1000));
                }, 1000);
            }
        } else {
            // å¦‚æœæ— æ³•è®¡ç®—å¼€å¥–æ—¶é—´ï¼Œç«‹å³å¼€å§‹æŸ¥è¯¢
            startAutoDrawQuery();
        }
        
        // æ˜¾ç¤ºæç¤ºä¿¡æ¯
        showAutoDrawMessage('è‡ªåŠ¨å¼€å¥–å·²å¼€å¯ï¼Œå°†åœ¨å½“æœŸå¼€å¥–å3ç§’å¼€å§‹æŸ¥è¯¢');
    } else {
        // å…³é—­è‡ªåŠ¨å¼€å¥–
        isAutoDrawRunning = false;
        statusElement.textContent = 'æœªå¼€å¯';
        statusElement.className = 'auto-status off';
        countdownElement.textContent = '--:--';
        
        // å…³é—­èµ°åŠ¿å›¾è‡ªåŠ¨æ›´æ–°
        disableTrendAutoUpdate();
        
        // æ¸…é™¤æ‰€æœ‰å®šæ—¶å™¨
        clearAutoDrawTimers();
        
        // éšè—çŠ¶æ€è¯¦æƒ…
        const detailsElement = document.getElementById('autoDrawDetails');
        if (detailsElement) detailsElement.style.display = 'none';
        
        // æ˜¾ç¤ºæç¤ºä¿¡æ¯
        showAutoDrawMessage('è‡ªåŠ¨å¼€å¥–å·²å…³é—­');
    }
}

// æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º
function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

// å¼€å§‹è‡ªåŠ¨å¼€å¥–æŸ¥è¯¢
function startAutoDrawQuery() {
    if (!isAutoDrawRunning) return;
    
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    clearAutoDrawTimers();
    
    // é‡ç½®é‡è¯•è®¡æ•°
    autoDrawRetryCount = 0;
    
    // æ›´æ–°çŠ¶æ€
    updateAutoDrawStatus();
    
    // æ‰§è¡ŒæŸ¥è¯¢
    executeAutoDrawQuery();
}

// æ‰§è¡Œè‡ªåŠ¨å¼€å¥–æŸ¥è¯¢
async function executeAutoDrawQuery() {
    if (!isAutoDrawRunning || !autoDrawCurrentDate || !autoDrawCurrentPhase) return;
    
    const loadingDiv = document.getElementById('singleLoading');
    const countdownElement = document.getElementById('countdown');
    
    // æ›´æ–°é‡è¯•è®¡æ•°
    autoDrawRetryCount++;
    updateAutoDrawStatus();
    
    // æ˜¾ç¤ºæŸ¥è¯¢çŠ¶æ€
    loadingDiv.textContent = `â³ è‡ªåŠ¨æŸ¥è¯¢ç¬¬ ${getPhaseFormat(autoDrawCurrentDate, autoDrawCurrentPhase)} æœŸ... (ç¬¬${autoDrawRetryCount}æ¬¡å°è¯•)`;
    loadingDiv.style.color = '#27ae60';
    countdownElement.textContent = 'æŸ¥è¯¢ä¸­...';
    
    try {
        // è®¾ç½®æŸ¥è¯¢å‚æ•°
        document.getElementById('queryDateUTC8').value = autoDrawCurrentDate;
        document.getElementById('qihaoUTC8').value = autoDrawCurrentPhase;
        
        // ä¿å­˜åŸå§‹çŠ¶æ€
        const originalIsAutoDrawRunning = isAutoDrawRunning;
        
        // æ‰§è¡ŒæŸ¥è¯¢
        const success = await querySingleWithV2APIForAutoDraw();
        
        if (success) {
            // æŸ¥è¯¢æˆåŠŸï¼Œæ¸…é™¤åŠ è½½æç¤º
            loadingDiv.textContent = '';
            countdownElement.textContent = 'æŸ¥è¯¢æˆåŠŸ';
            
            // æŸ¥è¯¢æˆåŠŸåï¼Œç«‹å³æ›´æ–°åˆ°ä¸‹ä¸€æœŸï¼ˆä¿®å¤è·¨å¤©é—®é¢˜ï¼‰
            moveToNextPhaseForAutoDraw();
        } else {
            // æŸ¥è¯¢å¤±è´¥ï¼Œåˆ¤æ–­æ˜¯å¦ç»§ç»­é‡è¯•
            if (autoDrawRetryCount >= autoDrawMaxRetries) {
                // è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œæ”¾å¼ƒå½“å‰æœŸï¼Œè¿›å…¥ä¸‹ä¸€æœŸ
                loadingDiv.textContent = `âœ— ç¬¬ ${getPhaseFormat(autoDrawCurrentDate, autoDrawCurrentPhase)} æœŸæŸ¥è¯¢å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œè·³è¿‡è¯¥æœŸ`;
                loadingDiv.style.color = '#e74c3c';
                
                // ç§»åŠ¨åˆ°ä¸‹ä¸€æœŸ
                moveToNextPhaseForAutoDraw();
            } else {
                // æœªè¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œ3ç§’åé‡è¯•
                loadingDiv.textContent = `â³ ç¬¬ ${getPhaseFormat(autoDrawCurrentDate, autoDrawCurrentPhase)} æœŸæŸ¥è¯¢å¤±è´¥ï¼Œ3ç§’åé‡è¯• (${autoDrawRetryCount}/${autoDrawMaxRetries})`;
                loadingDiv.style.color = '#f39c12';
                countdownElement.textContent = '03:00';
                
                // è®¾ç½®é‡è¯•å®šæ—¶å™¨
                let retrySeconds = 3;
                autoDrawRetryTimer = setInterval(() => {
                    retrySeconds--;
                    if (retrySeconds <= 0) {
                        clearInterval(autoDrawRetryTimer);
                        executeAutoDrawQuery(); // é‡æ–°æ‰§è¡ŒæŸ¥è¯¢
                    } else {
                        countdownElement.textContent = `0${retrySeconds}:00`;
                    }
                }, 1000);
            }
        }
    } catch (error) {
        console.error("è‡ªåŠ¨å¼€å¥–æŸ¥è¯¢å¼‚å¸¸:", error);
        loadingDiv.textContent = `âœ— è‡ªåŠ¨å¼€å¥–æŸ¥è¯¢å¼‚å¸¸: ${error.message}`;
        loadingDiv.style.color = '#e74c3c';
        
        // å¼‚å¸¸æƒ…å†µä¸‹ï¼Œä¹Ÿå°è¯•è¿›å…¥ä¸‹ä¸€æœŸ
        moveToNextPhaseForAutoDraw();
    }
}

// ä¸ºè‡ªåŠ¨å¼€å¥–ä¸“ç”¨çš„æŸ¥è¯¢å‡½æ•°
async function querySingleWithV2APIForAutoDraw() {
    return new Promise((resolve) => {
        // ä¿å­˜åŸå§‹æŸ¥è¯¢å‡½æ•°å¼•ç”¨
        const originalQuerySingle = querySingleWithV2API;
        let queryCompleted = false;
        let querySuccess = false;
        
        // ä¸´æ—¶è¦†ç›–æŸ¥è¯¢å‡½æ•°ï¼Œä»¥ä¾¿æ•è·ç»“æœ
        window.querySingleWithV2API = async function() {
            const dateStrUTC8 = autoDrawCurrentDate;
            const qiUTC8 = autoDrawCurrentPhase;
            const loadingDiv = document.getElementById('singleLoading');
            const resultDiv = document.getElementById('singleResult');
            
            // å¦‚æœæ˜¯è‡ªåŠ¨å¼€å¥–æ¨¡å¼ï¼Œä¸æ˜¾ç¤ºæ ‡å‡†åŠ è½½ä¿¡æ¯
            loadingDiv.textContent = `â³ è‡ªåŠ¨æŸ¥è¯¢ç¬¬ ${getPhaseFormat(dateStrUTC8, qiUTC8)} æœŸ...`;
            
            resultDiv.innerHTML = "";
            const apiCalls = [];

            try {
                const drawTimes = getDrawTimeUTC(dateStrUTC8, qiUTC8);
                if (!drawTimes) throw new Error("æ— æ³•è®¡ç®—å¼€å¥–æ—¶é—´");

                const timestamp = getTimestamp(drawTimes.utc);
                const phaseFormat = getPhaseFormat(dateStrUTC8, qiUTC8);

                // æ˜¾ç¤ºå¼€å¥–ä¿¡æ¯
                let infoHtml = `
                    <div style="display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px;">
                        <div class="phase-item">
                            <div class="phase-label">UTC+8 æœŸå·</div>
                            <div class="phase-value">${phaseFormat}</div>
                        </div>
                        <div class="phase-item">
                            <div class="phase-label">UTC+8 å¼€å¥–æ—¶é—´</div>
                            <div class="phase-value">${drawTimes.utc8.split(' ')[1]}</div>
                        </div>
                        <div class="phase-item">
                            <div class="phase-label">UTC+8 æ—¥æœŸ</div>
                            <div class="phase-value">${drawTimes.originalDate}</div>
                        </div>
                        <div class="phase-item" style="background:#d5f4e6; border-left:4px solid #27ae60;">
                            <div class="phase-label">æŸ¥è¯¢æ¨¡å¼</div>
                            <div class="phase-value" style="color:#27ae60;">è‡ªåŠ¨å¼€å¥–</div>
                        </div>
                `;
                
                // å¦‚æœè·¨å¤©äº†ï¼Œæ˜¾ç¤ºè·¨å¤©æ ‡è®°
                if (drawTimes.originalDate !== drawTimes.utc8.split(' ')[0]) {
                    infoHtml += `
                        <div class="phase-item" style="background:#fff0f5; border-left:4px solid #ff69b4;">
                            <div class="phase-label">è·¨å¤©æ ‡è®°</div>
                            <div class="phase-value" style="color:#ff69b4;">è·¨å¤©æœŸ</div>
                        </div>
                    `;
                }
                
                infoHtml += `</div>`;
                resultDiv.innerHTML = infoHtml;

                // è·å–åŒºå—å·
                const blockNumber = await getBlockNumberByTimestampV2(timestamp);
                apiCalls.push({ name: "è·å–åŒºå—å·", response: { blockNumber } });

                resultDiv.innerHTML += `
                    <div class="phase-item">
                        <div class="phase-label">åŒºå—é«˜åº¦</div>
                        <div class="phase-value">${blockNumber}</div>
                    </div>
                `;

                // è·å–åŒºå—å“ˆå¸Œ
                const blockHash = await getBlockHashByNumberV2(blockNumber);
                apiCalls.push({ name: "è·å–åŒºå—å“ˆå¸Œ", response: { hash: blockHash.substring(0, 20) + "..." } });

                resultDiv.innerHTML += `
                    <div class="phase-item">
                        <div class="phase-label">åŒºå—å“ˆå¸Œ</div>
                        <div class="phase-value" style="font-size:12px;">${blockHash.substring(0, 20)}...</div>
                    </div>
                `;

                // è®¡ç®—å¼€å¥–ç»“æœ
                const calcResult = calculateResult(blockHash);
                loadingDiv.textContent = "";

                // æ˜¾ç¤ºå¼€å¥–ç»“æœ
                resultDiv.innerHTML += `
                    <div class="result-box">
                        <h3>ç¬¬ ${phaseFormat} æœŸå¼€å¥–ç»“æœ</h3>
                        <div style="font-size:14px; opacity:0.9; margin-bottom:10px;">
                            UTC+8å¼€å¥–æ—¶é—´ï¼š${drawTimes.utc8.split(' ')[1]} | UTCå¼€å¥–æ—¶é—´ï¼š${drawTimes.utc.split(' ')[1]}
                            ${drawTimes.originalDate !== drawTimes.utc8.split(' ')[0] ? '<br><span style="color:#fff; background:#ff69b4; padding:2px 5px; border-radius:3px;">ğŸŒ™ è·¨å¤©æœŸ</span>' : ''}
                            <br><span style="color:#fff; background:#27ae60; padding:2px 5px; border-radius:3px;">ğŸ”” è‡ªåŠ¨è·å– (ç¬¬${autoDrawRetryCount}æ¬¡å°è¯•)</span>
                        </div>
                        <div class="numbers">${calcResult.result.join('  ')}</div>
                        <div style="font-size:14px; opacity:0.9;">
                            å† å†›ï¼š${calcResult.result[0]} | äºšå†›ï¼š${calcResult.result[1]} | å­£å†›ï¼š${calcResult.result[2]}
                        </div>
                    </div>
                `;

                // æ˜¾ç¤ºåŒºå—ä¿¡æ¯
                resultDiv.innerHTML += `
                    <h4>ğŸ“‹ åŒºå—ä¿¡æ¯</h4>
                    <div class="hash-display">
                        <strong>å®Œæ•´åŒºå—å“ˆå¸Œï¼š</strong><br>
                        ${blockHash}
                    </div>
                `;

                // æ˜¾ç¤ºå­—ç¬¦åˆ†å¸ƒ
                resultDiv.innerHTML += `
                    <h4>ğŸ² å­—ç¬¦åˆ†å¸ƒ</h4>
                    <div style="margin-bottom:15px;">
                        <strong>ä»å³åˆ°å·¦å¯¹åº”èµ›è½¦1-10å·ï¼š</strong>
                    </div>
                    <div class="char-grid" style="flex-direction: row; flex-wrap: nowrap; justify-content: center; overflow-x: auto;">
                `;
                
                calcResult.chars.forEach((char, index) => {
                    const isHex = charOrder.indexOf(char) >= 10;
                    resultDiv.innerHTML += `
                        <div class="char-item ${isHex ? 'char-hex' : 'char-digit'}" style="display: inline-flex; margin: 0 5px;">
                            <div>
                                <div style="font-size:10px;">è½¦${(index+1).toString().padStart(2,'0')}</div>
                                <div style="font-size:14px;">${char}</div>
                            </div>
                        </div>
                    `;
                });
                resultDiv.innerHTML += `</div>`;

                // æ˜¾ç¤ºå¼€å¥–è¯¦æƒ…è¡¨æ ¼
                resultDiv.innerHTML += `
                    <div style="margin-top:15px;">
                        <strong>å­—ç¬¦æ’åºï¼ˆä»å¤§åˆ°å°ï¼‰ï¼š</strong><br>
                        ${calcResult.sortedChars.join(' > ')}
                    </div>
                    
                    <h4>ğŸ“Š å¼€å¥–è¯¦æƒ…</h4>
                    <table>
                        <tr>
                            <th>æ’å</th><th>èµ›è½¦å·ç </th><th>å¯¹åº”å­—ç¬¦</th><th>å­—ç¬¦å€¼</th><th>ç±»å‹</th>
                        </tr>
                `;
                
                calcResult.sortedChars.forEach((char, index) => {
                    const carNumber = calcResult.result[index];
                    const charIndex = charOrder.indexOf(char);
                    const charType = charIndex >= 10 ? "åå…­è¿›åˆ¶" : "æ•°å­—";
                    resultDiv.innerHTML += `
                        <tr>
                            <td>ç¬¬${index + 1}å</td>
                            <td><strong>${carNumber}</strong></td>
                            <td>${char}</td>
                            <td>${charIndex}</td>
                            <td>${charType}</td>
                        </tr>
                    `;
                });
                resultDiv.innerHTML += `</table>`;
                
                // æ˜¾ç¤ºAPIè°ƒç”¨è¯¦æƒ…
                resultDiv.innerHTML += displayAPIDetails(apiCalls);
                
                // æ˜¾ç¤ºéªŒè¯ä¿¡æ¯
                resultDiv.innerHTML += `
                    <div class="success" style="margin-top:20px;">
                        <strong>âœ“ ç»“æœå·²ç”Ÿæˆ</strong><br>
                        æ­¤ç»“æœåŸºäºæ³¢åœº(TRON)çœŸå®åŒºå—æ•°æ®è®¡ç®—ï¼Œä»»ä½•äººéƒ½å¯ä»¥å¤ç°ã€‚<br>
                        <small>æ³¨ï¼šå¼€å¥–è®¡ç®—åŸºäºUTCæ—¶é—´ï¼Œç•Œé¢æ˜¾ç¤ºä¸ºUTC+8æ—¶é—´</small>
                        ${drawTimes.originalDate !== drawTimes.utc8.split(' ')[0] ? '<br><small>âš ï¸ æ³¨æ„ï¼šæ­¤æœŸä¸ºè·¨å¤©æœŸï¼ŒæœŸå·ä¸­çš„æ—¥æœŸä¸ºå‰ä¸€å¤©ï¼Œå®é™…å¼€å¥–æ—¶é—´ä¸ºç¬¬äºŒå¤©00:00:03</small>' : ''}
                    </div>
                `;
                
                // ä¿å­˜è‡ªåŠ¨å¼€å¥–ç»“æœåˆ°æ•°æ®åº“
                const resultItem = {
                    date: drawTimes.originalDate,
                    phase: qiUTC8,
                    phaseFormat: phaseFormat,
                    timeUTC8: drawTimes.utc8.split(' ')[1],
                    blockNumber: blockNumber,
                    hash: blockHash,
                    result: calcResult.result,
                    winner: calcResult.result[0],
                    timestamp: Date.now(),
                    source: 'auto_draw',
                    retryCount: autoDrawRetryCount
                };
                
                // ä¿å­˜åˆ°æ•°æ®åº“
                try {
                    await saveAutoDrawResultToDB(resultItem);
                    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                    updateDBStats();
                } catch (error) {
                    console.error("ä¿å­˜è‡ªåŠ¨å¼€å¥–ç»“æœåˆ°æ•°æ®åº“å¤±è´¥:", error);
                }
                
                // å¦‚æœæ˜¯è‡ªåŠ¨å¼€å¥–æ¨¡å¼ä¸”èµ°åŠ¿å›¾å·²ç”Ÿæˆï¼Œå°†ç»“æœæ·»åŠ åˆ°èµ°åŠ¿å›¾
                if (isAutoDrawRunning && isTrendChartGenerated) {
                    await addAutoDrawResultToTrend(calcResult, phaseFormat, dateStrUTC8, qiUTC8);
                }
                
                querySuccess = true;
                queryCompleted = true;
                
                // æ¢å¤åŸå§‹å‡½æ•°
                window.querySingleWithV2API = originalQuerySingle;
                resolve(true);
                
            } catch (error) {
                loadingDiv.textContent = "";
                if (apiCalls.length > 0) {
                    apiCalls[apiCalls.length - 1].error = error.message;
                    resultDiv.innerHTML += displayAPIDetails(apiCalls);
                }
                
                resultDiv.innerHTML += `
                    <div class="error">
                        <strong>âœ— è‡ªåŠ¨è·å–å¼€å¥–ç»“æœå¤±è´¥</strong><br>
                        é”™è¯¯ä¿¡æ¯: ${error.message}<br>
                        ç¬¬${autoDrawRetryCount}æ¬¡å°è¯•å¤±è´¥ï¼Œ3ç§’åé‡è¯•ã€‚
                    </div>
                `;
                
                querySuccess = false;
                queryCompleted = true;
                
                // æ¢å¤åŸå§‹å‡½æ•°
                window.querySingleWithV2API = originalQuerySingle;
                resolve(false);
            }
        };
        
        // æ‰§è¡ŒæŸ¥è¯¢
        setTimeout(() => {
            if (!queryCompleted) {
                window.querySingleWithV2API();
            }
        }, 100);
    });
}

// ç§»åŠ¨åˆ°ä¸‹ä¸€æœŸï¼ˆç”¨äºè‡ªåŠ¨å¼€å¥–ï¼‰ - ä¿®å¤è·¨å¤©é—®é¢˜
function moveToNextPhaseForAutoDraw() {
    if (!autoDrawCurrentDate || !autoDrawCurrentPhase) return;
    
    // è·å–ä¸‹ä¸€æœŸ
    const nextPhase = getNextPhase(autoDrawCurrentDate, autoDrawCurrentPhase);
    autoDrawCurrentDate = nextPhase.date;
    autoDrawCurrentPhase = nextPhase.phase;
    
    // é‡ç½®é‡è¯•è®¡æ•°
    autoDrawRetryCount = 0;
    
    // æ›´æ–°çŠ¶æ€
    updateAutoDrawStatus();

    // åˆ‡æ¢åˆ°ä¸‹ä¸€æœŸæ—¶åŒæ­¥æ›´æ–°é€‰æ‹©æ¡†ä¸ºä¸‹ä¸€æœŸçš„æ—¥æœŸ/æœŸå·ï¼ˆç¡®ä¿è·¨å¤©åé€‰æ‹©ä¸ºæ¬¡æ—¥ï¼‰
    try {
        const dateInput = document.getElementById('queryDateUTC8');
        const qihaoInput = document.getElementById('qihaoUTC8');
        if (dateInput) dateInput.value = autoDrawCurrentDate;
        if (qihaoInput) qihaoInput.value = autoDrawCurrentPhase;
    } catch (e) {
        console.warn('moveToNextPhaseForAutoDraw åŒæ­¥é€‰æ‹©æ¡†å¤±è´¥', e);
    }
    
    // å®‰æ’ä¸‹ä¸€æœŸæŸ¥è¯¢
    scheduleNextAutoDraw();
}

// å®‰æ’ä¸‹ä¸€æœŸè‡ªåŠ¨å¼€å¥– - ä¿®å¤è·¨å¤©é—®é¢˜
function scheduleNextAutoDraw() {
    if (!isAutoDrawRunning || !autoDrawCurrentDate || !autoDrawCurrentPhase) return;
    
    // æ¸…é™¤ç°æœ‰å®šæ—¶å™¨
    clearAutoDrawTimers();
    
    // è·å–ä¸‹ä¸€æœŸ
    // è®¡ç®—å½“å‰ autoDrawCurrentDate/autoDrawCurrentPhase çš„å¼€å¥–æ—¶é—´å¹¶å®‰æ’æŸ¥è¯¢
    const drawTimes = getDrawTimeUTC(autoDrawCurrentDate, autoDrawCurrentPhase);
    if (!drawTimes) {
        // å¦‚æœæ— æ³•è®¡ç®—å¼€å¥–æ—¶é—´ï¼Œç­‰å¾…1åˆ†é’Ÿåé‡è¯•
        setTimeout(() => {
            scheduleNextAutoDraw();
        }, 60000);
        return;
    }

    const drawTime = new Date(drawTimes.utc8);
    const queryTime = new Date(drawTime.getTime() + 3000); // å¼€å¥–å3ç§’
    const now = new Date();

    // å¦‚æœå½“å‰æ—¶é—´å·²ç»è¶…è¿‡äº†æœ¬æœŸçš„å®é™…å¼€å¥–æ—¶é—´ï¼ˆä¾‹å¦‚ç¬¬2880æœŸçš„æ¬¡æ—¥00:00:03å·²è¿‡ï¼‰ï¼Œ
    // é‚£ä¹ˆç•Œé¢é€‰æ‹©æ¡†åº”ç«‹å³åˆ‡æ¢ä¸ºä¸‹ä¸€æœŸçš„æ—¥æœŸï¼ˆæ¬¡æ—¥ï¼‰ï¼Œä»¥ä¿è¯è·¨å¤©å¤„ç†æ­£ç¡®ã€‚
    try {
        const dateInput = document.getElementById('queryDateUTC8');
        const qihaoInput = document.getElementById('qihaoUTC8');
        if (now.getTime() > drawTime.getTime()) {
            const np = getNextPhase(autoDrawCurrentDate, autoDrawCurrentPhase);
            if (dateInput) dateInput.value = np.date;
            if (qihaoInput) qihaoInput.value = np.phase;
        } else {
            if (dateInput) dateInput.value = autoDrawCurrentDate;
            if (qihaoInput) qihaoInput.value = autoDrawCurrentPhase;
        }
    } catch (e) {
        console.warn('scheduleNextAutoDraw åŒæ­¥é€‰æ‹©æ¡†å¤±è´¥', e);
    }

    // è®¡ç®—ç­‰å¾…æ—¶é—´
    const waitTime = queryTime.getTime() - now.getTime();

    if (waitTime <= 0) {
        // å¦‚æœå·²ç»åˆ°æˆ–è¶…è¿‡æŸ¥è¯¢æ—¶é—´ï¼Œç«‹å³å¼€å§‹æŸ¥è¯¢ï¼ˆä¸æ”¹å˜ autoDrawCurrentDate/Phaseï¼‰
        autoDrawRetryCount = 0;
        updateAutoDrawStatus();
        startAutoDrawQuery();
    } else {
        // è®¾ç½®å®šæ—¶å™¨ï¼Œåœ¨å½“å‰æœŸçš„å¼€å¥–å3ç§’å¼€å§‹æŸ¥è¯¢
        autoDrawTimer = setTimeout(() => {
            autoDrawRetryCount = 0;
            updateAutoDrawStatus();
            startAutoDrawQuery();
        }, waitTime);

        // æ›´æ–°å€’è®¡æ—¶æ˜¾ç¤º
        const countdownElement = document.getElementById('countdown');
        if (countdownElement) {
            countdownElement.textContent = formatTime(Math.floor(waitTime / 1000));

            // æ¯ç§’æ›´æ–°å€’è®¡æ—¶
            autoDrawInterval = setInterval(() => {
                const remaining = Math.max(0, queryTime.getTime() - Date.now());
                countdownElement.textContent = formatTime(Math.floor(remaining / 1000));
            }, 1000);
        }
    }
}

function clearAutoDrawTimers() {
    if (autoDrawInterval) {
        clearInterval(autoDrawInterval);
        autoDrawInterval = null;
    }
    if (autoDrawTimer) {
        clearTimeout(autoDrawTimer);
        autoDrawTimer = null;
    }
    if (autoDrawRetryTimer) {
        clearInterval(autoDrawRetryTimer);
        autoDrawRetryTimer = null;
    }
}

function showAutoDrawMessage(message) {
    const resultDiv = document.getElementById('singleResult');
    const existingMessage = document.getElementById('autoDrawMessage');
    
    if (existingMessage) {
        existingMessage.remove();
    }
    
    const messageDiv = document.createElement('div');
    messageDiv.id = 'autoDrawMessage';
    messageDiv.className = isAutoDrawRunning ? 'success' : 'warning';
    messageDiv.style.marginTop = '10px';
    messageDiv.innerHTML = `<strong>${isAutoDrawRunning ? 'ğŸ””' : 'ğŸ”•'} ${message}</strong>`;
    
    // æ’å…¥åˆ°ç»“æœåŒºåŸŸé¡¶éƒ¨
    if (resultDiv.firstChild) {
        resultDiv.insertBefore(messageDiv, resultDiv.firstChild);
    } else {
        resultDiv.appendChild(messageDiv);
    }
    
    // 5ç§’åè‡ªåŠ¨ç§»é™¤æ¶ˆæ¯
    setTimeout(() => {
        if (messageDiv.parentNode) {
            messageDiv.style.opacity = '0';
            messageDiv.style.transition = 'opacity 0.5s';
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.remove();
                }
            }, 500);
        }
    }, 5000);
}

async function querySingleWithV2API() {
    const dateStrUTC8 = document.getElementById('queryDateUTC8').value;
    const qiUTC8 = parseInt(document.getElementById('qihaoUTC8').value);
    const loadingDiv = document.getElementById('singleLoading');
    const resultDiv = document.getElementById('singleResult');
    
    // å¦‚æœæ—¥æœŸä¸ºç©ºï¼Œä½¿ç”¨ä»Šå¤©
    const queryDate = dateStrUTC8 || new Date(new Date().getTime() + 8 * 60 * 60 * 1000).toISOString().split('T')[0];
    
    if (qiUTC8 < 1 || qiUTC8 > PHASES_PER_DAY) { alert(`è¯·è¾“å…¥æ­£ç¡®çš„æœŸå·ï¼ˆ1-${PHASES_PER_DAY}ï¼‰`); return; }

    loadingDiv.textContent = "æ­£åœ¨é€šè¿‡TRON APIè·å–æ³¢åœºåŒºå—æ•°æ®...";
    resultDiv.innerHTML = "";
    const apiCalls = [];

    try {
        const drawTimes = getDrawTimeUTC(queryDate, qiUTC8);
        if (!drawTimes) throw new Error("æ— æ³•è®¡ç®—å¼€å¥–æ—¶é—´");

        const timestamp = getTimestamp(drawTimes.utc);
        const phaseFormat = getPhaseFormat(queryDate, qiUTC8);

        // æ˜¾ç¤ºå¼€å¥–ä¿¡æ¯
        let infoHtml = `
            <div style="display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px;">
                <div class="phase-item">
                    <div class="phase-label">UTC+8 æœŸå·</div>
                    <div class="phase-value">${phaseFormat}</div>
                </div>
                <div class="phase-item">
                    <div class="phase-label">UTC+8 å¼€å¥–æ—¶é—´</div>
                    <div class="phase-value">${drawTimes.utc8.split(' ')[1]}</div>
                </div>
                <div class="phase-item">
                    <div class="phase-label">UTC+8 æ—¥æœŸ</div>
                    <div class="phase-value">${drawTimes.originalDate}</div>
                </div>
        `;
        
        // å¦‚æœè·¨å¤©äº†ï¼Œæ˜¾ç¤ºè·¨å¤©æ ‡è®°
        if (drawTimes.originalDate !== drawTimes.utc8.split(' ')[0]) {
            infoHtml += `
                <div class="phase-item" style="background:#fff0f5; border-left:4px solid #ff69b4;">
                    <div class="phase-label">è·¨å¤©æ ‡è®°</div>
                    <div class="phase-value" style="color:#ff69b4;">è·¨å¤©æœŸ</div>
                </div>
            `;
        }
        
        infoHtml += `</div>`;
        resultDiv.innerHTML = infoHtml;

        // è·å–åŒºå—ä¿¡æ¯ï¼ˆæŒ‰å¼€å¥–æ—¶é—´æˆ³å®šä½â€œclosest afterâ€åŒºå—ï¼‰
        loadingDiv.textContent = "æ­£åœ¨é€šè¿‡TRON APIå®šä½åŒºå—...";
        const blockListUrl = buildTronBlockApiUrl({ start: 0, limit: 100, sort: '-timestamp' });
        apiCalls.push({ name: "è·å–åŒºå—åˆ—è¡¨(TronScan /api/block)", url: blockListUrl });

        const blockInfo = await getTronBlockInfoByTimestamp(timestamp);
        const blockNumber = blockInfo.blockNumber;
        apiCalls[apiCalls.length - 1].response = { blockNumber, blockTimestamp: blockInfo.blockTimestamp };

        resultDiv.innerHTML += `
            <div class="phase-item">
                <div class="phase-label">åŒºå—é«˜åº¦</div>
                <div class="phase-value">${blockNumber}</div>
            </div>
        `;

        // è·å–åŒºå—å“ˆå¸Œ
        loadingDiv.textContent = "æ­£åœ¨è·å–åŒºå—å“ˆå¸Œ...";
        const blockHash = await getBlockHashByNumberV2(blockNumber);
        apiCalls.push({ name: "åŒºå—å“ˆå¸Œ(ä»ç¼“å­˜/æ—¶é—´æˆ³æŸ¥è¯¢ç»“æœ)", response: { hash: blockHash.substring(0, 20) + "..." } });

        resultDiv.innerHTML += `
            <div class="phase-item">
                <div class="phase-label">åŒºå—å“ˆå¸Œ</div>
                <div class="phase-value" style="font-size:12px;">${blockHash.substring(0, 20)}...</div>
            </div>
        `;

        // è®¡ç®—å¼€å¥–ç»“æœ
        loadingDiv.textContent = "æ­£åœ¨è®¡ç®—å¼€å¥–ç»“æœ...";
        
        const calcResult = calculateResult(blockHash);
        loadingDiv.textContent = "";

        // æ˜¾ç¤ºå¼€å¥–ç»“æœ
        resultDiv.innerHTML += `
            <div class="result-box">
                <h3>ç¬¬ ${phaseFormat} æœŸå¼€å¥–ç»“æœ</h3>
                <div style="font-size:14px; opacity:0.9; margin-bottom:10px;">
                    UTC+8å¼€å¥–æ—¶é—´ï¼š${drawTimes.utc8.split(' ')[1]} | UTCå¼€å¥–æ—¶é—´ï¼š${drawTimes.utc.split(' ')[1]}
                    ${drawTimes.originalDate !== drawTimes.utc8.split(' ')[0] ? '<br><span style="color:#fff; background:#ff69b4; padding:2px 5px; border-radius:3px;">ğŸŒ™ è·¨å¤©æœŸ</span>' : ''}
                </div>
                <div class="numbers">${calcResult.result.join('  ')}</div>
                <div style="font-size:14px; opacity:0.9;">
                    å† å†›ï¼š${calcResult.result[0]} | äºšå†›ï¼š${calcResult.result[1]} | å­£å†›ï¼š${calcResult.result[2]}
                </div>
            </div>
        `;

        // æ˜¾ç¤ºåŒºå—ä¿¡æ¯
        resultDiv.innerHTML += `
            <h4>ğŸ“‹ åŒºå—ä¿¡æ¯</h4>
            <div class="hash-display">
                <strong>å®Œæ•´åŒºå—å“ˆå¸Œï¼š</strong><br>
                ${blockHash}
            </div>
        `;

        // æ˜¾ç¤ºå­—ç¬¦åˆ†å¸ƒ
        resultDiv.innerHTML += `
            <h4>ğŸ² å­—ç¬¦åˆ†å¸ƒ</h4>
            <div style="margin-bottom:15px;">
                <strong>ä»å³åˆ°å·¦å¯¹åº”èµ›è½¦1-10å·ï¼š</strong>
            </div>
            <div class="char-grid" style="flex-direction: row; flex-wrap: nowrap; justify-content: center; overflow-x: auto;">
        `;
        
        calcResult.chars.forEach((char, index) => {
            const isHex = charOrder.indexOf(char) >= 10;
            resultDiv.innerHTML += `
                <div class="char-item ${isHex ? 'char-hex' : 'char-digit'}" style="display: inline-flex; margin: 0 5px;">
                    <div>
                        <div style="font-size:10px;">è½¦${(index+1).toString().padStart(2,'0')}</div>
                        <div style="font-size:14px;">${char}</div>
                    </div>
                </div>
            `;
        });
        resultDiv.innerHTML += `</div>`;

        // æ˜¾ç¤ºå¼€å¥–è¯¦æƒ…è¡¨æ ¼
        resultDiv.innerHTML += `
            <div style="margin-top:15px;">
                <strong>å­—ç¬¦æ’åºï¼ˆä»å¤§åˆ°å°ï¼‰ï¼š</strong><br>
                ${calcResult.sortedChars.join(' > ')}
            </div>
            
            <h4>ğŸ“Š å¼€å¥–è¯¦æƒ…</h4>
            <table>
                <tr>
                    <th>æ’å</th><th>èµ›è½¦å·ç </th><th>å¯¹åº”å­—ç¬¦</th><th>å­—ç¬¦å€¼</th><th>ç±»å‹</th>
                </tr>
        `;
        
        calcResult.sortedChars.forEach((char, index) => {
            const carNumber = calcResult.result[index];
            const charIndex = charOrder.indexOf(char);
            const charType = charIndex >= 10 ? "åå…­è¿›åˆ¶" : "æ•°å­—";
            resultDiv.innerHTML += `
                <tr>
                    <td>ç¬¬${index + 1}å</td>
                    <td><strong>${carNumber}</strong></td>
                    <td>${char}</td>
                    <td>${charIndex}</td>
                    <td>${charType}</td>
                </tr>
            `;
        });
        resultDiv.innerHTML += `</table>`;
        
        // æ˜¾ç¤ºAPIè°ƒç”¨è¯¦æƒ…
        resultDiv.innerHTML += displayAPIDetails(apiCalls);
        
        // æ˜¾ç¤ºéªŒè¯ä¿¡æ¯
        resultDiv.innerHTML += `
            <div class="success" style="margin-top:20px;">
                <strong>âœ“ ç»“æœå·²ç”Ÿæˆ</strong><br>
                æ­¤ç»“æœåŸºäºæ³¢åœº(TRON)çœŸå®åŒºå—æ•°æ®è®¡ç®—ï¼Œä»»ä½•äººéƒ½å¯ä»¥å¤ç°ã€‚<br>
                <small>æ³¨ï¼šå¼€å¥–è®¡ç®—åŸºäºUTCæ—¶é—´ï¼Œç•Œé¢æ˜¾ç¤ºä¸ºUTC+8æ—¶é—´</small>
                ${drawTimes.originalDate !== drawTimes.utc8.split(' ')[0] ? '<br><small>âš ï¸ æ³¨æ„ï¼šæ­¤æœŸä¸ºè·¨å¤©æœŸï¼ŒæœŸå·ä¸­çš„æ—¥æœŸä¸ºå‰ä¸€å¤©ï¼Œå®é™…å¼€å¥–æ—¶é—´ä¸ºç¬¬äºŒå¤©00:00:03</small>' : ''}
            </div>
        `;
        
    } catch (error) {
        loadingDiv.textContent = "";
        if (apiCalls.length > 0) {
            apiCalls[apiCalls.length - 1].error = error.message;
            resultDiv.innerHTML += displayAPIDetails(apiCalls);
        }
        
        resultDiv.innerHTML += `
            <div class="error">
                <strong>âœ— è·å–å¼€å¥–ç»“æœå¤±è´¥</strong><br>
                é”™è¯¯ä¿¡æ¯: ${error.message}<br>
                <small>å¯èƒ½åŸå› ï¼š</small>
                <ul>
                    <li>TRON-PRO-API-KEYæ— æ•ˆæˆ–å—é™</li>
                    <li>TronScan APIè°ƒç”¨é¢‘ç‡é™åˆ¶</li>
                    <li>ç½‘ç»œè¿æ¥é—®é¢˜ / CORSé™åˆ¶</li>
                    <li>æŒ‡å®šæ—¶é—´èŒƒå›´æ— æ³•å®šä½åŒºå—</li>
                </ul>
            </div>
        `;
    }
}

async function queryCurrentWithV2API() {
    const now = new Date();
    const utc8 = new Date(now.getTime() + 8 * 60 * 60 * 1000);
    let todayUTC8 = utc8.toISOString().split('T')[0];

    const utc8Hours = utc8.getUTCHours();
    const utc8Minutes = utc8.getUTCMinutes();
    const utc8Seconds = utc8.getUTCSeconds();
    const totalSecondsUTC8 = utc8Hours * 3600 + utc8Minutes * 60 + utc8Seconds;

    let currentPhaseUTC8;
    let queryDateUTC8 = todayUTC8;
    
    // æ³¢åœº30ç§’èµ›è½¦è·¨å¤©é€»è¾‘ï¼š
    // 1) 00:00:00~00:00:32ï¼šå‰ä¸€å¤©ç¬¬2880æœŸï¼ˆå¼€å¥–00:00:03ï¼‰
    // 2) 00:00:33å¼€å§‹ï¼šå½“å¤©ç¬¬1æœŸ
    if (totalSecondsUTC8 < FIRST_DRAW_SECOND_UTC8) {
        currentPhaseUTC8 = PHASES_PER_DAY;
        const yesterday = new Date(utc8);
        yesterday.setDate(yesterday.getDate() - 1);
        queryDateUTC8 = yesterday.toISOString().split('T')[0];
    } else {
        currentPhaseUTC8 = Math.floor((totalSecondsUTC8 - FIRST_DRAW_SECOND_UTC8) / DRAW_INTERVAL_SECONDS) + 1;
        if (currentPhaseUTC8 < 1) currentPhaseUTC8 = 1;
        if (currentPhaseUTC8 > PHASES_PER_DAY - 1) currentPhaseUTC8 = PHASES_PER_DAY - 1;
    }

    // æ›´æ–°ç•Œé¢æ˜¾ç¤º
    document.getElementById('qihaoUTC8').value = currentPhaseUTC8;
    document.getElementById('queryDateUTC8').value = queryDateUTC8;
    
    // è°ƒç”¨æŸ¥è¯¢å‡½æ•°
    await querySingleWithV2API();
}

// ================== èµ°åŠ¿å›¾è‡ªåŠ¨æ›´æ–°å‡½æ•° ==================
function enableTrendAutoUpdate() {
    trendAutoUpdateEnabled = true;
    const statusElement = document.getElementById('trendAutoUpdateStatus');
    if (statusElement) {
        statusElement.style.display = 'block';
        statusElement.innerHTML = `
            <strong>ğŸ”„ èµ°åŠ¿å›¾è‡ªåŠ¨æ›´æ–°å·²å¯ç”¨</strong>
            <p style="margin:5px 0 0 0; font-size:14px;">
                èµ°åŠ¿å›¾å°†éšç€è‡ªåŠ¨å¼€å¥–ç»“æœå®æ—¶æ›´æ–°ã€‚å½“è‡ªåŠ¨å¼€å¥–å¼€å…³æ‰“å¼€æ—¶ï¼Œæ–°å¼€å¥–æ•°æ®ä¼šè‡ªåŠ¨æ·»åŠ åˆ°èµ°åŠ¿å›¾ä¸­ã€‚
            </p>
        `;
    }
}

function disableTrendAutoUpdate() {
    trendAutoUpdateEnabled = false;
    const statusElement = document.getElementById('trendAutoUpdateStatus');
    if (statusElement) {
        statusElement.style.display = 'none';
    }
}

async function addAutoDrawResultToTrend(calcResult, phaseFormat, dateStrUTC8, qiUTC8) {
    if (!trendAutoUpdateEnabled || !isTrendChartGenerated || !trendAllData.length) {
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²ç»æ·»åŠ è¿‡è¯¥æœŸæ•°æ®
    if (lastAutoUpdateIssue === phaseFormat) {
        return; // å·²ç»æ·»åŠ è¿‡ï¼Œè·³è¿‡
    }
    
    lastAutoUpdateIssue = phaseFormat;
    
    // åˆ›å»ºæ–°çš„èµ°åŠ¿å›¾æ•°æ®è¡Œ
    const newRow = { issue: phaseFormat, timestamp: Date.now() };
    for (let i = 0; i < 10; i++) {
        const num = parseInt(calcResult.result[i], 10);
        newRow['p' + (i + 1)] = isNaN(num) ? null : num;
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨è¯¥æœŸæ•°æ®
    const existingIndex = trendAllData.findIndex(item => item.issue === phaseFormat);
    if (existingIndex !== -1) {
        // æ›´æ–°ç°æœ‰æ•°æ®
        trendAllData[existingIndex] = newRow;
    } else {
        // æ·»åŠ æ–°æ•°æ®åˆ°æ•°ç»„å¼€å¤´ï¼ˆæœ€æ–°æ•°æ®åœ¨æœ€å‰é¢ï¼‰
        trendAllData.unshift(newRow);
    }
    
    // æ— è®ºæ·»åŠ è¿˜æ˜¯æ›´æ–°ï¼Œéƒ½ç¡®ä¿åªä¿ç•™è¿‘100æœŸæ•°æ®
    const maxDataSize = 100; // åªä¿ç•™è¿‘100æœŸæ•°æ®
    if (trendAllData.length > maxDataSize) {
        // æŒ‰æœŸå·æ’åºï¼Œä¿ç•™æœ€æ–°çš„100æœŸ
        trendAllData.sort((a, b) => {
            const ai = isNaN(a.issue) ? a.issue : Number(a.issue);
            const bi = isNaN(b.issue) ? b.issue : Number(b.issue);
            if (ai < bi) return 1;
            if (ai > bi) return -1;
            return 0;
        });
        // åªä¿ç•™æœ€æ–°çš„100æœŸ
        trendAllData = trendAllData.slice(0, maxDataSize);
    }
    
    // ä¿å­˜åˆ°æ•°æ®åº“ï¼ˆå¦‚æœæŒä¹…åŒ–å¼€å¯ï¼‰
    if (persistenceEnabled) {
        try {
            await saveTrendDataToDB();
        } catch (error) {
            console.error("ä¿å­˜è‡ªåŠ¨å¼€å¥–æ•°æ®åˆ°æ•°æ®åº“å¤±è´¥:", error);
        }
    }
    
    // æ›´æ–°èµ°åŠ¿å›¾
    generateTrendChart();
    
    // æ˜¾ç¤ºæ›´æ–°æç¤º
    showTrendUpdateMessage(`å·²è‡ªåŠ¨æ›´æ–°èµ°åŠ¿å›¾ï¼šç¬¬ ${phaseFormat} æœŸ`);
    
    // æ£€æŸ¥æŠ•æ³¨ç»“æœï¼ˆä¸å¼€å¥–ç»“æœå¯¹æ¯”ï¼‰
    checkBettingResultsOnNewDraw(calcResult, phaseFormat).catch(err => {
        console.error('æ£€æŸ¥æŠ•æ³¨ç»“æœå¤±è´¥:', err);
    });
    
    // è§¦å‘è‡ªåŠ¨ä¸‹æ³¨ç›‘æ§ï¼ˆå¦‚æœè‡ªåŠ¨å¼€å¥–å¼€å¯ï¼‰
    if (isAutoDrawRunning) {
        checkAutoBettingConditions();
    }
}

function showTrendUpdateMessage(message) {
    const tablesDiv = document.getElementById('trendTables');
    if (!tablesDiv) return;
    
    const existingMessage = tablesDiv.querySelector('.trend-update-message');
    if (existingMessage) {
        existingMessage.remove();
    }
    
    const messageDiv = document.createElement('div');
    messageDiv.className = 'trend-update-message success';
    messageDiv.style.cssText = `
        margin: 10px 0;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 14px;
        text-align: center;
        animation: fadeIn 0.5s;
    `;
    messageDiv.innerHTML = `<strong>ğŸ”„ ${message}</strong>`;
    
    // æ’å…¥åˆ°èµ°åŠ¿å›¾å®¹å™¨é¡¶éƒ¨
    if (tablesDiv.firstChild) {
        tablesDiv.insertBefore(messageDiv, tablesDiv.firstChild);
    } else {
        tablesDiv.appendChild(messageDiv);
    }
    
    // 3ç§’åè‡ªåŠ¨ç§»é™¤æ¶ˆæ¯
    setTimeout(() => {
        if (messageDiv.parentNode) {
            messageDiv.style.opacity = '0';
            messageDiv.style.transition = 'opacity 0.5s';
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.remove();
                }
            }, 500);
        }
    }, 3000);
}

// ================== æ‰¹é‡æŸ¥è¯¢æ”¹è¿›åŠŸèƒ½ ==================
async function testV2API() {
    const startDateStr = document.getElementById('batchStartDateUTC8').value;
    const endDateStr = document.getElementById('batchEndDateUTC8').value;
    const startPhase = parseInt(document.getElementById('batchStartPhase').value) || 1;
    const endPhase = parseInt(document.getElementById('batchEndPhase').value) || PHASES_PER_DAY;
    const loadingDiv = document.getElementById('batchLoading');
    const resultDiv = document.getElementById('batchResult');

    if (startPhase < 1 || startPhase > PHASES_PER_DAY || endPhase < 1 || endPhase > PHASES_PER_DAY) {
        alert(`è¯·è¾“å…¥æ­£ç¡®çš„æœŸå·ï¼ˆ1-${PHASES_PER_DAY}ï¼‰`);
        return;
    }
    if (!startDateStr || !endDateStr) {
        alert('è¯·é€‰æ‹©å¼€å§‹æ—¥æœŸå’Œç»“æŸæ—¥æœŸ');
        return;
    }

    const startDate = new Date(startDateStr);
    const endDate = new Date(endDateStr);
    if (startDate > endDate) {
        alert('å¼€å§‹æ—¥æœŸä¸èƒ½æ™šäºç»“æŸæ—¥æœŸ');
        return;
    }

    // é‡ç½®å˜é‡
    stopBatchQueryFlag = false;
    batchQueryInProgress = true;
    batchTotalQueries = 0;
    batchCompletedQueries = 0;
    batchSuccessQueries = 0;
    batchFailedQueries = 0;
    window.batchAllResults = [];
    window.batchAllErrors = [];

    // è®¡ç®—æ€»æŸ¥è¯¢æ•°
    let tempDate = new Date(startDate);
    let currentPhase = startPhase;
    while (tempDate < endDate || (tempDate.getTime() === endDate.getTime() && currentPhase <= endPhase)) {
        batchTotalQueries++;
        currentPhase++;
        if (currentPhase > PHASES_PER_DAY) {
            currentPhase = 1;
            tempDate.setDate(tempDate.getDate() + 1);
        }
    }

    // æ˜¾ç¤ºè¿›åº¦æ¡å’Œç»Ÿè®¡
    document.getElementById('batchProgress').style.display = 'block';
    document.getElementById('batchStats').style.display = 'grid';
    document.getElementById('stopBatchBtn').style.display = 'inline-block';
    document.getElementById('exportBatchBtn').style.display = 'none';
    document.getElementById('batchResultsContainer').style.display = 'none';
    
    // æ¸…ç©ºç»“æœè¡¨æ ¼
    document.getElementById('batchResultsBody').innerHTML = '';
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    updateBatchStats();

    loadingDiv.textContent = `æ­£åœ¨é€šè¿‡TRON APIè¿ç»­æŸ¥è¯¢ ${startDateStr}ç¬¬${startPhase}æœŸ è‡³ ${endDateStr}ç¬¬${endPhase}æœŸï¼ˆå…±${batchTotalQueries}æœŸï¼‰...`;
    resultDiv.innerHTML = "";
    
    // å¼€å§‹æŸ¥è¯¢
    let currentDate = new Date(startDate);
    currentPhase = startPhase;
    
    // æ¸…ç©ºä¹‹å‰çš„æ‰¹é‡ç»“æœ
    window.batchAllResults = [];
    window.batchAllErrors = [];

    while ((currentDate < endDate || (currentDate.getTime() === endDate.getTime() && currentPhase <= endPhase)) && !stopBatchQueryFlag) {
        try {
            const dateStrUTC8 = currentDate.toISOString().split('T')[0];
            loadingDiv.textContent = `æ­£åœ¨æŸ¥è¯¢ ${dateStrUTC8} ç¬¬${currentPhase}æœŸ... (${batchCompletedQueries + 1}/${batchTotalQueries})`;

            const drawTimes = getDrawTimeUTC(dateStrUTC8, currentPhase);
            if (!drawTimes) throw new Error("æ— æ³•è®¡ç®—å¼€å¥–æ—¶é—´");

            const timestamp = getTimestamp(drawTimes.utc);
            const phaseFormat = getPhaseFormat(drawTimes.originalDate, currentPhase);

            const blockNumber = await getBlockNumberByTimestampV2(timestamp);
            const blockHash = await getBlockHashByNumberV2(blockNumber);
            const calcResult = calculateResult(blockHash);

            const resultItem = {
                date: drawTimes.originalDate,
                phase: currentPhase,
                phaseFormat: phaseFormat,
                timeUTC8: drawTimes.utc8.split(' ')[1],
                blockNumber: blockNumber,
                hash: blockHash,
                result: calcResult.result,
                winner: calcResult.result[0],
                timestamp: Date.now(),
                source: 'batch_query'
            };
            window.batchAllResults.push(resultItem);
            batchSuccessQueries++;
            
            // ä¿å­˜åˆ°æ•°æ®åº“ï¼ˆå¦‚æœæŒä¹…åŒ–å¼€å¯ï¼‰
            if (persistenceEnabled) {
                await saveBatchResultToDB(resultItem);
            }
            
            // æ·»åŠ ç»“æœåˆ°è¡¨æ ¼
            addBatchResultToTable(resultItem, batchCompletedQueries + 1);
            
        } catch (error) {
            const dateStrUTC8 = currentDate.toISOString().split('T')[0];
            const errorItem = {
                date: dateStrUTC8,
                phase: currentPhase,
                phaseFormat: getPhaseFormat(dateStrUTC8, currentPhase),
                error: error.message,
                timestamp: Date.now()
            };
            window.batchAllErrors.push(errorItem);
            batchFailedQueries++;
            
            // æ·»åŠ é”™è¯¯ç»“æœåˆ°è¡¨æ ¼
            addBatchErrorToTable(errorItem, batchCompletedQueries + 1);
        }
        
        batchCompletedQueries++;
        
        // æ›´æ–°è¿›åº¦
        updateBatchProgress();
        
        // æ·»åŠ å»¶è¿Ÿä»¥é¿å…APIé™åˆ¶
        await new Promise(resolve => setTimeout(resolve, 300));
        
        currentPhase++;
        if (currentPhase > PHASES_PER_DAY) {
            currentPhase = 1;
            currentDate.setDate(currentDate.getDate() + 1);
        }
        if (currentDate > endDate || (currentDate.getTime() === endDate.getTime() && currentPhase > endPhase)) {
            break;
        }
    }
    
    // æŸ¥è¯¢å®Œæˆæˆ–åœæ­¢
    batchQueryInProgress = false;
    loadingDiv.textContent = stopBatchQueryFlag ? "æ‰¹é‡æŸ¥è¯¢å·²åœæ­¢" : "æ‰¹é‡æŸ¥è¯¢å®Œæˆ";
    
    // æ˜¾ç¤ºç»“æœå®¹å™¨
    document.getElementById('batchResultsContainer').style.display = 'block';
    
    // éšè—åœæ­¢æŒ‰é’®ï¼Œæ˜¾ç¤ºå¯¼å‡ºæŒ‰é’®
    document.getElementById('stopBatchBtn').style.display = 'none';
    document.getElementById('exportBatchBtn').style.display = 'inline-block';
    
    // æ›´æ–°æ•°æ®åº“ç»Ÿè®¡ä¿¡æ¯
    updateDBStats();
    
    // æ¸²æŸ“åˆ†é¡µç»“æœ
    renderBatchResults();
}

// åœæ­¢æ‰¹é‡æŸ¥è¯¢
function stopBatchQuery() {
    stopBatchQueryFlag = true;
    batchQueryInProgress = false;
    document.getElementById('batchLoading').textContent = "æ­£åœ¨åœæ­¢æŸ¥è¯¢...";
}

// æ›´æ–°æ‰¹é‡æŸ¥è¯¢è¿›åº¦
function updateBatchProgress() {
    const progress = batchTotalQueries > 0 ? Math.round((batchCompletedQueries / batchTotalQueries) * 100) : 0;
    document.getElementById('batchProgressFill').style.width = `${progress}%`;
    document.getElementById('batchProgressText').textContent = `${progress}%`;
    
    updateBatchStats();
}

// æ›´æ–°æ‰¹é‡æŸ¥è¯¢ç»Ÿè®¡
function updateBatchStats() {
    document.getElementById('statTotal').textContent = batchTotalQueries;
    document.getElementById('statSuccess').textContent = batchSuccessQueries;
    document.getElementById('statFailed').textContent = batchFailedQueries;
    
    const progress = batchTotalQueries > 0 ? Math.round((batchCompletedQueries / batchTotalQueries) * 100) : 0;
    document.getElementById('statProgress').textContent = `${progress}%`;
}

// æ·»åŠ æ‰¹é‡ç»“æœåˆ°è¡¨æ ¼
function addBatchResultToTable(resultItem, index) {
    const tbody = document.getElementById('batchResultsBody');
    const row = document.createElement('tr');
    
    // æ„å»ºå¼€å¥–å·ç å­—ç¬¦ä¸²
    const resultNumbers = resultItem.result.join('');
    
    row.innerHTML = `
        <td>${index}</td>
        <td>${resultItem.date}</td>
        <td>${resultItem.phaseFormat}</td>
        <td>${resultItem.timeUTC8}</td>
        <td><strong>${resultNumbers}</strong></td>
        <td>${resultItem.result[0]}</td>
        <td>${resultItem.result[1]}</td>
        <td>${resultItem.result[2]}</td>
        <td>${resultItem.result[3]}</td>
        <td>${resultItem.result[4]}</td>
        <td>${resultItem.result[5]}</td>
        <td>${resultItem.result[6]}</td>
        <td>${resultItem.result[7]}</td>
        <td>${resultItem.result[8]}</td>
        <td>${resultItem.result[9]}</td>
        <td><span style="color:#27ae60;">âœ“ æˆåŠŸ</span></td>
    `;
    
    tbody.appendChild(row);
}

// æ·»åŠ æ‰¹é‡é”™è¯¯åˆ°è¡¨æ ¼ï¼ˆä¿®æ”¹ä¸ºæ˜¾ç¤ºå†æ¬¡æŸ¥è¯¢æŒ‰é’®ï¼‰
function addBatchErrorToTable(errorItem, index) {
    const tbody = document.getElementById('batchResultsBody');
    const row = document.createElement('tr');
    row.id = `error-row-${errorItem.date}-${errorItem.phase}`;
    row.style.backgroundColor = '#fdf2f2';
    
    row.innerHTML = `
        <td>${index}</td>
        <td>${errorItem.date}</td>
        <td>${errorItem.phaseFormat || 'N/A'}</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>
            <button onclick="retryFailedPhase('${errorItem.date}', ${errorItem.phase}, this)" 
                    class="retry-btn">
                å†æ¬¡æŸ¥è¯¢
            </button>
        </td>
    `;
    
    tbody.appendChild(row);
}

// å¯¼å‡ºæ‰¹é‡æŸ¥è¯¢ç»“æœä¸ºExcel
function exportBatchResultsToExcel() {
    if (!window.batchAllResults || window.batchAllResults.length === 0) {
        alert('æ²¡æœ‰æ‰¹é‡æŸ¥è¯¢ç»“æœå¯å¯¼å‡º');
        return;
    }
    
    try {
        const wb = XLSX.utils.book_new();
        
        // å‡†å¤‡æ•°æ®
        const wsData = [
            ['æœŸå·', 'å¼€å¥–å·ç ', 'ç¬¬1å', 'ç¬¬2å', 'ç¬¬3å', 'ç¬¬4å', 'ç¬¬5å', 'ç¬¬6å', 'ç¬¬7å', 'ç¬¬8å', 'ç¬¬9å', 'ç¬¬10å', 'å¼€å¥–æ—¶é—´', 'åŒºå—é«˜åº¦', 'æŸ¥è¯¢æ—¶é—´']
        ];
        
        // åˆå¹¶æˆåŠŸå’Œå¤±è´¥çš„ç»“æœ
        const allResults = [...window.batchAllResults];
        
        // æŒ‰æ—¥æœŸå’ŒæœŸå·æ’åº
        allResults.sort((a, b) => {
            if (a.date !== b.date) return a.date.localeCompare(b.date);
            return a.phase - b.phase;
        });
        
        allResults.forEach(item => {
            const row = [
                item.phaseFormat,
                item.result ? item.result.join('') : 'N/A',
                item.result ? item.result[0] : 'N/A',
                item.result ? item.result[1] : 'N/A',
                item.result ? item.result[2] : 'N/A',
                item.result ? item.result[3] : 'N/A',
                item.result ? item.result[4] : 'N/A',
                item.result ? item.result[5] : 'N/A',
                item.result ? item.result[6] : 'N/A',
                item.result ? item.result[7] : 'N/A',
                item.result ? item.result[8] : 'N/A',
                item.result ? item.result[9] : 'N/A',
                item.timeUTC8 || 'N/A',
                item.blockNumber || 'N/A',
                new Date(item.timestamp).toLocaleString('zh-CN')
            ];
            wsData.push(row);
        });
        
        const ws = XLSX.utils.aoa_to_sheet(wsData);
        XLSX.utils.book_append_sheet(wb, ws, 'æ‰¹é‡æŸ¥è¯¢ç»“æœ');
        
        // æ·»åŠ ç»Ÿè®¡ä¿¡æ¯
        const statsData = [
            ['æ³¢åœº30ç§’èµ›è½¦æ‰¹é‡æŸ¥è¯¢ç»Ÿè®¡æŠ¥å‘Š'],
            ['ç”Ÿæˆæ—¶é—´', new Date().toLocaleString('zh-CN')],
            ['å¼€å§‹æ—¥æœŸ', document.getElementById('batchStartDateUTC8').value],
            ['å¼€å§‹æœŸå·', document.getElementById('batchStartPhase').value],
            ['ç»“æŸæ—¥æœŸ', document.getElementById('batchEndDateUTC8').value],
            ['ç»“æŸæœŸå·', document.getElementById('batchEndPhase').value],
            ['æ€»æŸ¥è¯¢æ•°', batchTotalQueries],
            ['æˆåŠŸæŸ¥è¯¢', batchSuccessQueries],
            ['å¤±è´¥æŸ¥è¯¢', batchFailedQueries],
            ['æˆåŠŸç‡', batchTotalQueries > 0 ? `${Math.round((batchSuccessQueries / batchTotalQueries) * 100)}%` : '0%']
        ];
        
        const wsStats = XLSX.utils.aoa_to_sheet(statsData);
        XLSX.utils.book_append_sheet(wb, wsStats, 'ç»Ÿè®¡ä¿¡æ¯');
        
        const fileName = `æ³¢åœº30ç§’èµ›è½¦æ‰¹é‡æŸ¥è¯¢_${new Date().toISOString().slice(0,10)}.xlsx`;
        XLSX.writeFile(wb, fileName);
        
        alert(`æ‰¹é‡æŸ¥è¯¢ç»“æœå·²å¯¼å‡ºä¸º ${fileName}`);
    } catch (e) {
        alert('å¯¼å‡ºå¤±è´¥ï¼š' + e.message);
        console.error(e);
    }
}

// é‡è¯•å¤±è´¥çš„æœŸå·ï¼ˆä¿®æ”¹ç‰ˆï¼Œæ”¯æŒæŒ‰é’®æ“ä½œï¼‰
async function retryFailedPhase(dateStrUTC8, phase, button) {
    const loadingDiv = document.getElementById('batchLoading');
    const originalText = button.textContent;
    
    // ç¦ç”¨æŒ‰é’®å¹¶æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    button.textContent = "æŸ¥è¯¢ä¸­...";
    button.disabled = true;
    
    try {
        loadingDiv.textContent = `æ­£åœ¨é‡æ–°æŸ¥è¯¢ ${dateStrUTC8} ç¬¬${phase}æœŸ...`;
        
        const drawTimes = getDrawTimeUTC(dateStrUTC8, phase);
        if (!drawTimes) throw new Error("æ— æ³•è®¡ç®—å¼€å¥–æ—¶é—´");

        const timestamp = getTimestamp(drawTimes.utc);
        const phaseFormat = getPhaseFormat(drawTimes.originalDate, phase);
        const blockNumber = await getBlockNumberByTimestampV2(timestamp);
        const blockHash = await getBlockHashByNumberV2(blockNumber);
        const calcResult = calculateResult(blockHash);

        const resultItem = {
            date: drawTimes.originalDate,
            phase: phase,
            phaseFormat: phaseFormat,
            timeUTC8: drawTimes.utc8.split(' ')[1],
            blockNumber: blockNumber,
            hash: blockHash,
            result: calcResult.result,
            winner: calcResult.result[0],
            timestamp: Date.now(),
            source: 'batch_retry'
        };
        
        // ä»é”™è¯¯åˆ—è¡¨ä¸­ç§»é™¤
        const errorIndex = window.batchAllErrors.findIndex(
            err => err.date === dateStrUTC8 && err.phase === phase
        );
        if (errorIndex !== -1) {
            window.batchAllErrors.splice(errorIndex, 1);
        }
        
        // æ·»åŠ åˆ°æˆåŠŸåˆ—è¡¨
        window.batchAllResults.push(resultItem);
        
        // æ›´æ–°ç»Ÿè®¡
        batchSuccessQueries++;
        batchFailedQueries--;
        batchTotalQueries--; // å› ä¸ºå·²ç»ç®—åœ¨æ€»æ•°é‡Œäº†ï¼Œæ‰€ä»¥ä¸å¢åŠ æ€»æ•°
        
        // æ›´æ–°ç»Ÿè®¡æ˜¾ç¤º
        updateBatchStats();
        
        // ä¿å­˜åˆ°æ•°æ®åº“ï¼ˆå¦‚æœæŒä¹…åŒ–å¼€å¯ï¼‰
        if (persistenceEnabled) {
            await saveBatchResultToDB(resultItem);
            updateDBStats();
        }
        
        // æ›´æ–°è¡¨æ ¼è¡Œ
        const row = document.getElementById(`error-row-${dateStrUTC8}-${phase}`);
        if (row) {
            const resultNumbers = resultItem.result.join('');
            row.style.backgroundColor = '';
            row.innerHTML = `
                <td>${Array.from(row.parentNode.children).indexOf(row) + 1}</td>
                <td>${resultItem.date}</td>
                <td>${resultItem.phaseFormat}</td>
                <td>${resultItem.timeUTC8}</td>
                <td><strong>${resultNumbers}</strong></td>
                <td>${resultItem.result[0]}</td>
                <td>${resultItem.result[1]}</td>
                <td>${resultItem.result[2]}</td>
                <td>${resultItem.result[3]}</td>
                <td>${resultItem.result[4]}</td>
                <td>${resultItem.result[5]}</td>
                <td>${resultItem.result[6]}</td>
                <td>${resultItem.result[7]}</td>
                <td>${resultItem.result[8]}</td>
                <td>${resultItem.result[9]}</td>
                <td><span style="color:#27ae60;">âœ“ æˆåŠŸ</span></td>
            `;
        }
        
        loadingDiv.textContent = `âœ“ é‡æ–°æŸ¥è¯¢ ${dateStrUTC8} ç¬¬${phase}æœŸ æˆåŠŸï¼`;
        setTimeout(() => { 
            loadingDiv.textContent = ""; 
            // é‡æ–°æ’åºç»“æœï¼ˆæŒ‰æ—¥æœŸå’ŒæœŸå·ï¼‰
            window.batchAllResults.sort((a, b) => {
                if (a.date !== b.date) return a.date.localeCompare(b.date);
                return a.phase - b.phase;
            });
            
            // é‡æ–°æ¸²æŸ“è¡¨æ ¼
            renderBatchResultsTable();
        }, 1000);
        
    } catch (error) {
        // æ›´æ–°é”™è¯¯ä¿¡æ¯
        const errorIndex = window.batchAllErrors.findIndex(
            err => err.date === dateStrUTC8 && err.phase === phase
        );
        if (errorIndex !== -1) {
            window.batchAllErrors[errorIndex].error = error.message;
            window.batchAllErrors[errorIndex].timestamp = Date.now();
        }
        
        loadingDiv.textContent = `âœ— é‡æ–°æŸ¥è¯¢å¤±è´¥: ${error.message}`;
        button.textContent = originalText;
        button.disabled = false;
        setTimeout(() => { loadingDiv.textContent = ""; }, 3000);
    }
}

// é‡æ–°æ¸²æŸ“æ‰¹é‡ç»“æœè¡¨æ ¼
function renderBatchResultsTable() {
    const tbody = document.getElementById('batchResultsBody');
    if (!tbody) return;
    
    // æ¸…ç©ºè¡¨æ ¼
    tbody.innerHTML = '';
    
    // åˆå¹¶æ‰€æœ‰ç»“æœå¹¶æŒ‰æ—¥æœŸå’ŒæœŸå·æ’åº
    const allItems = [...window.batchAllResults, ...window.batchAllErrors];
    allItems.sort((a, b) => {
        if (a.date !== b.date) return a.date.localeCompare(b.date);
        return a.phase - b.phase;
    });
    
    // é‡æ–°æ·»åŠ æ‰€æœ‰è¡Œ
    allItems.forEach((item, index) => {
        if (item.error) {
            // å¤±è´¥çš„è¡Œ
            addBatchErrorToTable(item, index + 1);
        } else {
            // æˆåŠŸçš„è¡Œ
            addBatchResultToTable(item, index + 1);
        }
    });
}

// æ‰¹é‡ç»“æœåˆ†é¡µæ¸²æŸ“
function renderBatchResults() {
    const resultDiv = document.getElementById('batchResult');
    const startDateStr = document.getElementById('batchStartDateUTC8').value;
    const endDateStr = document.getElementById('batchEndDateUTC8').value;
    const startPhase = parseInt(document.getElementById('batchStartPhase').value) || 1;
    const endPhase = parseInt(document.getElementById('batchEndPhase').value) || PHASES_PER_DAY;

    window.batchAllResults.sort((a, b) => {
        if (a.date !== b.date) return a.date.localeCompare(b.date);
        return a.phase - b.phase;
    });
    window.batchAllErrors.sort((a, b) => {
        if (a.date !== b.date) return a.date.localeCompare(b.date);
        return a.phase - b.phase;
    });

    let html = "";

    const totalSuccess = window.batchAllResults.length;
    const totalFailed = window.batchAllErrors.length;
    const totalAll = totalSuccess + totalFailed;

    if (totalAll > 0) {
        html += `
            <h4>ğŸ“… è¿ç»­æŸ¥è¯¢ç»“æœï¼š${startDateStr}ç¬¬${startPhase}æœŸ è‡³ ${endDateStr}ç¬¬${endPhase}æœŸ</h4>
            <div class="success">
                <strong>âœ“ æ‰¹é‡æŸ¥è¯¢å®Œæˆ</strong><br>
                æˆåŠŸæŸ¥è¯¢ ${totalSuccess} æœŸï¼Œå¤±è´¥ ${totalFailed} æœŸ<br>
                æŸ¥è¯¢èŒƒå›´ï¼š${startDateStr}ç¬¬${startPhase}æœŸ è‡³ ${endDateStr}ç¬¬${endPhase}æœŸ<br>
                <small>æ‰€æœ‰æ—¶é—´ä¸ºUTC+8ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰</small>
            </div>
        `;
        
        // æ˜¾ç¤ºå¤±è´¥æŸ¥è¯¢çš„è¯¦ç»†ä¿¡æ¯
        if (totalFailed > 0) {
            html += `
                <div class="warning" style="margin-top:15px;">
                    <h4>âš ï¸ æŸ¥è¯¢å¤±è´¥è®°å½•ï¼ˆ${totalFailed} æœŸï¼‰</h4>
                    <p>ä»¥ä¸‹æœŸå·æŸ¥è¯¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–API Keyåç‚¹å‡»"å†æ¬¡æŸ¥è¯¢"æŒ‰é’®é‡è¯•ï¼š</p>
                    <table style="margin-top:10px;">
                        <tr>
                            <th>æ—¥æœŸ</th>
                            <th>æœŸå·</th>
                            <th>å¤±è´¥åŸå› </th>
                            <th>æ“ä½œ</th>
                        </tr>
            `;
            window.batchAllErrors.forEach(error => {
                html += `
                    <tr id="error-detail-row-${error.date}-${error.phase}">
                        <td>${error.date}</td>
                        <td>ç¬¬${error.phase}æœŸ</td>
                        <td>${error.error}</td>
                        <td>
                            <button onclick="retryFailedPhaseFromDetail('${error.date}', ${error.phase}, this)" 
                                    class="retry-btn" 
                                    style="padding:5px 10px; font-size:12px;">
                                å†æ¬¡æŸ¥è¯¢
                            </button>
                        </td>
                    </tr>
                `;
            });
            html += `</table></div>`;
        }
    }

    if (window.batchAllResults.length === 0 && window.batchAllErrors.length > 0) {
        html = `
            <div class="error">
                <h4>âœ— æ‰¹é‡æŸ¥è¯¢å¤±è´¥</h4>
                <p>æœªèƒ½æˆåŠŸæŸ¥è¯¢åˆ°ä»»ä½•æœŸå·çš„å¼€å¥–ç»“æœã€‚</p>
                <p>è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€API KeyçŠ¶æ€ï¼Œå¹¶ç¡®ä¿é€‰æ‹©çš„æ—¥æœŸèŒƒå›´å†…æœ‰å¼€å¥–æ•°æ®ã€‚</p>
                <p>å¤±è´¥çš„æŸ¥è¯¢è®°å½•å¦‚ä¸‹ï¼ˆç‚¹å‡»"å†æ¬¡æŸ¥è¯¢"æŒ‰é’®é‡æ–°å°è¯•ï¼‰ï¼š</p>
                <table>
                    <tr>
                        <th>æ—¥æœŸ</th>
                        <th>æœŸå·</th>
                        <th>é”™è¯¯ä¿¡æ¯</th>
                        <th>æ“ä½œ</th>
                    </tr>
        `;
        window.batchAllErrors.forEach(error => {
            html += `
                <tr id="error-detail-row-${error.date}-${error.phase}">
                    <td>${error.date}</td>
                    <td>ç¬¬${error.phase}æœŸ</td>
                    <td>${error.error}</td>
                    <td>
                        <button onclick="retryFailedPhaseFromDetail('${error.date}', ${error.phase}, this)" 
                                class="retry-btn" 
                                style="padding:5px 10px; font-size:12px;">
                            å†æ¬¡æŸ¥è¯¢
                        </button>
                    </td>
                </tr>
            `;
        });
        html += `</table></div>`;
    }

    resultDiv.innerHTML = html;
}

// ä»è¯¦ç»†é”™è¯¯è¡¨æ ¼ä¸­é‡è¯•
async function retryFailedPhaseFromDetail(dateStrUTC8, phase, button) {
    const loadingDiv = document.getElementById('batchLoading');
    const originalText = button.textContent;
    
    button.textContent = "æŸ¥è¯¢ä¸­...";
    button.disabled = true;
    
    try {
        loadingDiv.textContent = `æ­£åœ¨é‡æ–°æŸ¥è¯¢ ${dateStrUTC8} ç¬¬${phase}æœŸ...`;
        
        const drawTimes = getDrawTimeUTC(dateStrUTC8, phase);
        if (!drawTimes) throw new Error("æ— æ³•è®¡ç®—å¼€å¥–æ—¶é—´");

        const timestamp = getTimestamp(drawTimes.utc);
        const phaseFormat = getPhaseFormat(drawTimes.originalDate, phase);
        const blockNumber = await getBlockNumberByTimestampV2(timestamp);
        const blockHash = await getBlockHashByNumberV2(blockNumber);
        const calcResult = calculateResult(blockHash);

        const resultItem = {
            date: drawTimes.originalDate,
            phase: phase,
            phaseFormat: phaseFormat,
            timeUTC8: drawTimes.utc8.split(' ')[1],
            blockNumber: blockNumber,
            hash: blockHash,
            result: calcResult.result,
            winner: calcResult.result[0],
            timestamp: Date.now(),
            source: 'batch_retry'
        };
        
        // ä»é”™è¯¯åˆ—è¡¨ä¸­ç§»é™¤
        const errorIndex = window.batchAllErrors.findIndex(
            err => err.date === dateStrUTC8 && err.phase === phase
        );
        if (errorIndex !== -1) {
            window.batchAllErrors.splice(errorIndex, 1);
        }
        
        // æ·»åŠ åˆ°æˆåŠŸåˆ—è¡¨
        window.batchAllResults.push(resultItem);
        
        // æ›´æ–°ç»Ÿè®¡
        batchSuccessQueries++;
        batchFailedQueries--;
        
        // æ›´æ–°ç»Ÿè®¡æ˜¾ç¤º
        updateBatchStats();
        
        // ä¿å­˜åˆ°æ•°æ®åº“ï¼ˆå¦‚æœæŒä¹…åŒ–å¼€å¯ï¼‰
        if (persistenceEnabled) {
            await saveBatchResultToDB(resultItem);
            updateDBStats();
        }
        
        // ä»è¯¦ç»†é”™è¯¯è¡¨æ ¼ä¸­ç§»é™¤è¯¥è¡Œ
        const detailRow = document.getElementById(`error-detail-row-${dateStrUTC8}-${phase}`);
        if (detailRow) {
            detailRow.remove();
        }
        
        // æ›´æ–°ä¸»è¡¨æ ¼ä¸­çš„å¯¹åº”è¡Œï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        const mainRow = document.getElementById(`error-row-${dateStrUTC8}-${phase}`);
        if (mainRow) {
            const resultNumbers = resultItem.result.join('');
            mainRow.style.backgroundColor = '';
            mainRow.innerHTML = `
                <td>${Array.from(mainRow.parentNode.children).indexOf(mainRow) + 1}</td>
                <td>${resultItem.date}</td>
                <td>${resultItem.phaseFormat}</td>
                <td>${resultItem.timeUTC8}</td>
                <td><strong>${resultNumbers}</strong></td>
                <td>${resultItem.result[0]}</td>
                <td>${resultItem.result[1]}</td>
                <td>${resultItem.result[2]}</td>
                <td>${resultItem.result[3]}</td>
                <td>${resultItem.result[4]}</td>
                <td>${resultItem.result[5]}</td>
                <td>${resultItem.result[6]}</td>
                <td>${resultItem.result[7]}</td>
                <td>${resultItem.result[8]}</td>
                <td>${resultItem.result[9]}</td>
                <td><span style="color:#27ae60;">âœ“ æˆåŠŸ</span></td>
            `;
        }
        
        loadingDiv.textContent = `âœ“ é‡æ–°æŸ¥è¯¢ ${dateStrUTC8} ç¬¬${phase}æœŸ æˆåŠŸï¼`;
        setTimeout(() => { 
            loadingDiv.textContent = ""; 
            // é‡æ–°æ’åºç»“æœï¼ˆæŒ‰æ—¥æœŸå’ŒæœŸå·ï¼‰
            window.batchAllResults.sort((a, b) => {
                if (a.date !== b.date) return a.date.localeCompare(b.date);
                return a.phase - b.phase;
            });
            
            // é‡æ–°æ¸²æŸ“ç»“æœæ‘˜è¦
            renderBatchResults();
        }, 1000);
        
    } catch (error) {
        // æ›´æ–°é”™è¯¯ä¿¡æ¯
        const errorIndex = window.batchAllErrors.findIndex(
            err => err.date === dateStrUTC8 && err.phase === phase
        );
        if (errorIndex !== -1) {
            window.batchAllErrors[errorIndex].error = error.message;
            window.batchAllErrors[errorIndex].timestamp = Date.now();
        }
        
        loadingDiv.textContent = `âœ— é‡æ–°æŸ¥è¯¢å¤±è´¥: ${error.message}`;
        button.textContent = originalText;
        button.disabled = false;
        setTimeout(() => { loadingDiv.textContent = ""; }, 3000);
    }
}

function clearAPICache() {
    let count = 0;
    for (let i = localStorage.length - 1; i >= 0; i--) {
        const key = localStorage.key(i);
        if (key.startsWith(CACHE_PREFIX)) {
            localStorage.removeItem(key);
            count++;
        }
    }
    const resultDiv = document.getElementById('singleResult');
    resultDiv.innerHTML = `
        <div class="success">
            <strong>âœ“ ç¼“å­˜å·²æ¸…é™¤</strong><br>
            å·²æ¸…é™¤ ${count} æ¡TRON APIç¼“å­˜è®°å½•
        </div>
    `;
}

// åˆå§‹åŒ–æ•°æ®åº“å’Œé¡µé¢
window.onload = async function() {
    const utc8 = new Date(new Date().getTime() + 8 * 60 * 60 * 1000);
    const todayUTC8 = utc8.toISOString().split('T')[0];
    document.getElementById('queryDateUTC8').value = todayUTC8;
    document.getElementById('batchStartDateUTC8').value = todayUTC8;
    document.getElementById('batchEndDateUTC8').value = todayUTC8;

    window.batchAllResults = [];
    window.batchAllErrors = [];
    updateCurrentTime();

    const utc8Hours = utc8.getUTCHours();
    const utc8Minutes = utc8.getUTCMinutes();
    const utc8Seconds = utc8.getUTCSeconds();
    const totalSecondsUTC8 = utc8Hours * 3600 + utc8Minutes * 60 + utc8Seconds;
    
    let currentPhaseUTC8;
    let queryDateUTC8 = todayUTC8;
    
    // æ³¢åœº30ç§’èµ›è½¦è·¨å¤©é€»è¾‘ï¼š
    // 1) 00:00:00~00:00:32ï¼šå‰ä¸€å¤©ç¬¬2880æœŸï¼ˆå¼€å¥–00:00:03ï¼‰
    // 2) 00:00:33å¼€å§‹ï¼šå½“å¤©ç¬¬1æœŸ
    if (totalSecondsUTC8 < FIRST_DRAW_SECOND_UTC8) {
        currentPhaseUTC8 = PHASES_PER_DAY;
        const yesterday = new Date(utc8);
        yesterday.setDate(yesterday.getDate() - 1);
        queryDateUTC8 = yesterday.toISOString().split('T')[0];
    } else {
        currentPhaseUTC8 = Math.floor((totalSecondsUTC8 - FIRST_DRAW_SECOND_UTC8) / DRAW_INTERVAL_SECONDS) + 1;
        if (currentPhaseUTC8 < 1) currentPhaseUTC8 = 1;
        if (currentPhaseUTC8 > PHASES_PER_DAY - 1) currentPhaseUTC8 = PHASES_PER_DAY - 1;
    }
    
    document.getElementById('qihaoUTC8').value = currentPhaseUTC8;
    const phaseFormat = getPhaseFormat(queryDateUTC8, currentPhaseUTC8);
    
    // åˆå§‹åŒ–IndexedDB
    try {
        await initIndexedDB();
    } catch (error) {
        console.error("IndexedDBåˆå§‹åŒ–å¤±è´¥:", error);
        updateDBStatus("åˆå§‹åŒ–å¤±è´¥");
    }
    
    // æ˜¾ç¤ºæ¬¢è¿ä¿¡æ¯
    document.getElementById('singleResult').innerHTML = `
        <div class="info-box" style="margin-top:10px; padding:15px; background:#e8f4fd; border-radius:5px;">
            <h4 style="margin-top:0;">ğŸš€ æ³¢åœº30ç§’èµ›è½¦ - TRON APIç‰ˆæœ¬ (UTC+8æ—¶åŒº)</h4>
            <p>æœ¬ç³»ç»Ÿä½¿ç”¨ <strong>TronScan /api/block</strong> è·å–æ³¢åœºåŒºå—æ•°æ®ï¼Œå¹¶æ”¯æŒUTC+8æ—¶åŒºæ˜¾ç¤ºï¼š</p>
            <p><strong>ğŸ†• å¼€å¥–æ—¶é—´è§„åˆ™ï¼š</strong></p>
            <ul>
                <li><strong>ç¬¬ä¸€æœŸå¼€å¥–æ—¶é—´ï¼š</strong>00:00:33 UTC+8</li>
                <li><strong>æœ€åä¸€æœŸï¼ˆç¬¬2880æœŸï¼‰ï¼š</strong>è·¨å¤©åˆ°ç¬¬äºŒå¤©00:00:03</li>
                <li><strong>è·¨å¤©è§„åˆ™ï¼š</strong>æœŸå·ä¸­çš„æ—¥æœŸä¿æŒå‰ä¸€å¤©ï¼Œç³»ç»Ÿè‡ªåŠ¨æ— ç¼è¿‡æ¸¡</li>
                <li><strong>æ¯å¤©æœŸæ•°ï¼š</strong>2880æœŸï¼ˆæ¯30ç§’ä¸€æœŸï¼‰</li>
            </ul>
            <p><strong>ğŸ†• æ–°å¢è‡ªåŠ¨å¼€å¥–æ”¹è¿›ï¼š</strong></p>
            <ul>
                <li><strong>æŸ¥è¯¢æ—¶é—´ï¼š</strong>å½“æœŸå®é™…å¼€å¥–æ—¶é—´å3ç§’å¼€å§‹æŸ¥è¯¢</li>
                <li><strong>é‡è¯•æœºåˆ¶ï¼š</strong>æŸ¥è¯¢åˆ°å½“æœŸä¿¡æ¯åˆ™åœæ­¢ï¼Œæ²¡æŸ¥è¯¢åˆ°åˆ™é—´éš”3ç§’é‡æ–°æŸ¥è¯¢</li>
                <li><strong>è·³è¿‡æœºåˆ¶ï¼š</strong>åˆ°ä¸‹æœŸå¼€å¥–æ—¶é—´åˆ°äº†ï¼Œå½“æœŸè¿˜æ²¡æŸ¥è¯¢åˆ°åˆ™è·³è¿‡æŸ¥è¯¢</li>
                <li><strong>çŠ¶æ€æ˜¾ç¤ºï¼š</strong>æ˜¾ç¤ºå½“å‰æŸ¥è¯¢æœŸå·ã€é‡è¯•æ¬¡æ•°å’Œä¸‹ä¸€æœŸå¼€å¥–æ—¶é—´</li>
            </ul>
            <p><strong>ğŸ†• æ–°å¢IndexedDBæŒä¹…åŒ–å­˜å‚¨ï¼š</strong></p>
            <ul>
                <li><strong>æ‰¹é‡æŸ¥è¯¢ç»“æœï¼š</strong>æ°¸ä¹…ä¿å­˜ï¼Œä¸ä¼šè¿‡æœŸ</li>
                <li><strong>è‡ªåŠ¨å¼€å¥–è®°å½•ï¼š</strong>è‡ªåŠ¨ç´¯ç§¯ï¼Œä¸ä¼šä¸¢å¤±</li>
                <li><strong>èµ°åŠ¿å›¾æ•°æ®ï¼š</strong>æŒä¹…ä¿å­˜ï¼Œé¡µé¢åˆ·æ–°åä»å­˜åœ¨</li>
                <li><strong>æ•°æ®å®‰å…¨ï¼š</strong>æ‰€æœ‰æ•°æ®å­˜å‚¨åœ¨æµè§ˆå™¨æœ¬åœ°ï¼Œä¸ä¼šä¸Šä¼ åˆ°æœåŠ¡å™¨</li>
                <li><strong>ç¦»çº¿è®¿é—®ï¼š</strong>å·²æŸ¥è¯¢çš„æ•°æ®å¯åœ¨ç¦»çº¿çŠ¶æ€ä¸‹æŸ¥çœ‹</li>
            </ul>
            <p><strong>ğŸ“Š æ‰¹é‡æŸ¥è¯¢æ”¹è¿›ï¼š</strong></p>
            <ul>
                <li>æ–°å¢"åœæ­¢æŸ¥è¯¢"æŒ‰é’®ï¼Œå¯éšæ—¶åœæ­¢æ‰¹é‡æŸ¥è¯¢</li>
                <li>æ–°å¢"å¯¼å‡ºExcel"æŒ‰é’®ï¼Œå¯¼å‡ºæ‰¹é‡æŸ¥è¯¢ç»“æœ</li>
                <li>å®æ—¶è¿›åº¦æ¡æ˜¾ç¤ºæŸ¥è¯¢è¿›åº¦</li>
                <li>ç»Ÿè®¡é¢æ¿æ˜¾ç¤ºæŸ¥è¯¢çŠ¶æ€</li>
                <li>è¡¨æ ¼å±•ç¤ºæŸ¥è¯¢ç»“æœ</li>
                <li><strong>å¤±è´¥æŸ¥è¯¢å¯ç‚¹å‡»"å†æ¬¡æŸ¥è¯¢"æŒ‰é’®é‡è¯•</strong></li>
            </ul>
            <p><strong>å½“å‰å·²è‡ªåŠ¨é€‰æ‹©UTC+8ç¬¬ ${phaseFormat} æœŸ</strong></p>
            <p>ç‚¹å‡»"<span style="color:#9b59b6; font-weight:bold;">æŒä¹…åŒ–å­˜å‚¨å¼€å…³</span>"å¼€å¯æ•°æ®æŒä¹…åŒ–</p>
            <p>ç‚¹å‡»"<span style="color:#27ae60; font-weight:bold;">è‡ªåŠ¨å¼€å¥–å¼€å…³</span>"å¼€å§‹è‡ªåŠ¨è·å–å¼€å¥–ä¿¡æ¯</p>
            <p><strong>âš ï¸ æ³¨æ„ï¼š</strong> æœ¬ç³»ç»Ÿä¸ºæ¯30ç§’å¼€å¥–ä¸€æ¬¡ï¼Œæ¯å¤©å…±2880æœŸï¼Œç¬¬ä¸€æœŸ00:00:33</p>
        </div>
    `;
};

// ================== é¡µé¢å¸è½½æ—¶æ¸…ç†å®šæ—¶å™¨ ==================
window.addEventListener('beforeunload', function() {
    clearAutoDrawTimers();
});

// é¡µé¢åŠ è½½åï¼šåŒæ­¥â€œç›‘æ§è§„åˆ™3â€æŒ‰é’®é»˜è®¤çŠ¶æ€ï¼Œå¹¶å»ºç«‹ç›‘æ§åŸºçº¿ï¼ˆä¸å¯¹å†å²æ•°æ®é¸£å«ï¼‰
window.addEventListener('load', function() {
    try {
        updateMonitorRule3Button();
        monitorRule3LastStreak = computeRule3LossStreakFromLocalRecords();
    } catch (e) {}
});

// ================== æ‰¹é‡ç»“æœèµ°åŠ¿å›¾æ¨¡å— JS ==================
let trendAllData = [];
let trendCurrentPage = 1;
let trendPageSize = 100;
let trendTotalPages = 1;
let trendStats = null;
let trendSource = 'batch';

// ================== è‡ªåŠ¨ä¸‹æ³¨è§„åˆ™ ==================
let currentBettingRule = 3; // é»˜è®¤ä½¿ç”¨è§„åˆ™3ï¼ˆ1=è§„åˆ™1ï¼Œ2=è§„åˆ™2ï¼Œ3=è§„åˆ™3ï¼‰

// ================== è§„åˆ™3ç›‘æ§ï¼ˆé»˜è®¤å¼€å¯ï¼‰==================
let monitorRule3Enabled = true;           // â€œç›‘æ§è§„åˆ™3â€æŒ‰é’®é»˜è®¤æ‰“å¼€
let monitorRule3LastStreak = null;        // ä¸Šä¸€æ¬¡ç›‘æ§åˆ°çš„è¿ç»­æœªä¸­å¥–â€œæœŸæ•°â€ï¼ˆæŒ‰åˆå¹¶è§„åˆ™è®¡ç®—ï¼‰

function updateMonitorRule3Button() {
    const btn = document.getElementById('monitorRule3Btn');
    if (!btn) return;
    if (monitorRule3Enabled) {
        btn.className = 'success';
        btn.style.background = '#16a085';
        btn.textContent = 'ç›‘æ§è§„åˆ™3ï¼šå¼€';
        btn.title = 'å·²å¼€å¯ï¼šè§„åˆ™3è‡ªåŠ¨ä¸‹æ³¨æ—¶ï¼Œè‹¥è¿ç»­3æœŸä¸‹æ³¨æœªä¸­å¥–ï¼ˆè¿ç»­æœŸå·åˆå¹¶ä¸º1æœŸï¼‰å°†æç¤ºéŸ³';
    } else {
        btn.className = '';
        btn.style.background = '#95a5a6';
        btn.textContent = 'ç›‘æ§è§„åˆ™3ï¼šå…³';
        btn.title = 'å·²å…³é—­ï¼šä¸å†æç¤ºè§„åˆ™3è¿ç»­æœªä¸­å¥–';
    }
}

function toggleMonitorRule3(force) {
    if (typeof force === 'boolean') {
        monitorRule3Enabled = force;
    } else {
        monitorRule3Enabled = !monitorRule3Enabled;
    }
    updateMonitorRule3Button();
    // åˆ‡æ¢å¼€å…³æ—¶ï¼Œé‡ç½®åŸºçº¿ï¼Œé¿å…ä¸€æ‰“å¼€å°±å¯¹å†å²æ•°æ®ç«‹åˆ»é¸£å«
    try {
        monitorRule3LastStreak = computeRule3LossStreakFromLocalRecords();
    } catch (e) {
        monitorRule3LastStreak = null;
    }
}

function parseIssueParts(issue) {
    const s = String(issue || '').trim();
    // æ ¼å¼ï¼šYYYYMMDD0001
    if (/^\d{12}$/.test(s)) {
        const dateStr = s.slice(0, 8);
        const phaseStr = s.slice(8);
        const phase = parseInt(phaseStr, 10);
        return { type: 'datePhase', raw: s, dateStr, phase };
    }
    // çº¯æ•°å­—æœŸå·ï¼ˆå…¼å®¹ï¼‰
    if (/^\d+$/.test(s)) {
        const num = parseInt(s, 10);
        return { type: 'number', raw: s, num };
    }
    return { type: 'unknown', raw: s };
}

function isConsecutiveIssue(prevIssue, nextIssue) {
    const a = parseIssueParts(prevIssue);
    const b = parseIssueParts(nextIssue);
    if (a.type === 'datePhase' && b.type === 'datePhase') {
        if (!a.phase || !b.phase) return false;
        if (a.dateStr === b.dateStr) return b.phase === a.phase + 1;
        // è·¨å¤©ï¼š2880 -> æ¬¡æ—¥0001
        if (a.phase === PHASES_PER_DAY && b.phase === 1) {
            const y = parseInt(a.dateStr.slice(0, 4), 10);
            const m = parseInt(a.dateStr.slice(4, 6), 10) - 1;
            const d = parseInt(a.dateStr.slice(6, 8), 10);
            const dt = new Date(y, m, d);
            dt.setDate(dt.getDate() + 1);
            const nextDateStr = `${dt.getFullYear()}${String(dt.getMonth() + 1).padStart(2, '0')}${String(dt.getDate()).padStart(2, '0')}`;
            return b.dateStr === nextDateStr;
        }
        return false;
    }
    if (a.type === 'number' && b.type === 'number') {
        return b.num === a.num + 1;
    }
    // æ··åˆ/æœªçŸ¥ï¼šä¸è®¤ä¸ºè¿ç»­
    return false;
}

function playRule3MonitorSound() {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        // åªå“ä¸€å£°ï¼ŒéŸ³è°ƒæ›´é•¿
        oscillator.frequency.value = 660;
        oscillator.type = 'sine';

        const t = audioContext.currentTime;
        const duration = 1.0; // ç§’

        // æ¸å…¥æ¸å‡ºï¼Œé¿å…çˆ†éŸ³
        gainNode.gain.setValueAtTime(0, t);
        gainNode.gain.linearRampToValueAtTime(0.35, t + 0.02);
        gainNode.gain.setValueAtTime(0.35, t + duration - 0.05);
        gainNode.gain.exponentialRampToValueAtTime(0.001, t + duration);

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.start(t);
        oscillator.stop(t + duration);
    } catch (e) {
        console.log('è§„åˆ™3ç›‘æ§æç¤ºéŸ³æ’­æ”¾å¤±è´¥ï¼ˆå¯èƒ½éœ€è¦ç”¨æˆ·äº¤äº’åæ‰èƒ½æ’­æ”¾ï¼‰:', e);
    }
}

function computeRule3LossStreakFromLocalRecords() {
    const all = (typeof getBettingRecords === 'function') ? (getBettingRecords() || []) : [];
    const rule3 = all.filter(r => r && r.rule === 'è§„åˆ™3' && r.checked === true && r.isWin !== null && r.isWin !== undefined);

    // æŒ‰æ—¶é—´å‡åºï¼ˆä»æ—§åˆ°æ–°ï¼‰ç»Ÿè®¡â€œè‡ªä¸Šæ¬¡ä¸­å¥–ä»¥æ¥â€çš„è¿ç»­æœªä¸­å¥–æœŸæ•°
    rule3.sort((a, b) => {
        const ta = (a.timestamp || 0);
        const tb = (b.timestamp || 0);
        if (ta !== tb) return ta - tb;
        const ia = String(a.nextIssue || '');
        const ib = String(b.nextIssue || '');
        return ia < ib ? -1 : ia > ib ? 1 : 0;
    });

    let streak = 0;
    let inLossRun = false;
    let lastLossIssue = null;

    for (const r of rule3) {
        const isWin = !!r.isWin;
        const issue = r.nextIssue;
        if (isWin) {
            streak = 0;
            inLossRun = false;
            lastLossIssue = null;
            continue;
        }

        // æœªä¸­å¥–
        if (!inLossRun) {
            streak += 1;
        } else {
            // æœŸå·è¿ç»­ç®—ä½œä¸€æœŸï¼ˆä¾‹å¦‚0001å’Œ0002éƒ½æœªä¸­å¥–ç®—ä½œä¸€æœŸï¼‰
            if (!isConsecutiveIssue(lastLossIssue, issue)) {
                streak += 1;
            }
        }
        inLossRun = true;
        lastLossIssue = issue;
    }

    return streak;
}

function monitorRule3ConsecutiveLosses() {
    // ä»…åœ¨â€œé€‰æ‹©è§„åˆ™3è‡ªåŠ¨ä¸‹æ³¨â€æ—¶ç›‘æ§
    if (currentBettingRule !== 3) return;
    if (!monitorRule3Enabled) return;

    const streak = computeRule3LossStreakFromLocalRecords();

    // é¦–æ¬¡åˆå§‹åŒ–ï¼šåªè®°åŸºçº¿ï¼Œä¸é¸£å«
    if (monitorRule3LastStreak === null || typeof monitorRule3LastStreak === 'undefined') {
        monitorRule3LastStreak = streak;
        return;
    }

    // è¾¾åˆ°3æœŸåï¼šæ¯å½“â€œæœªä¸­å¥–æœŸæ•°ï¼ˆæŒ‰åˆå¹¶è§„åˆ™ï¼‰â€æ–°å¢+1 å°±å†æç¤ºä¸€æ¬¡
    // ä¾‹å¦‚ï¼š3 -> 4 -> 5 ... æ¯æ¬¡å¢é•¿éƒ½ä¼šå“ï¼›ä½†è‹¥åªæ˜¯è¿ç»­æœŸå·çš„æœªä¸­å¥–ï¼Œä¸ä¼šå¢é•¿ï¼Œä¹Ÿä¸ä¼šå“
    if (streak >= 3 && streak > monitorRule3LastStreak) {
        console.warn(`è§„åˆ™3ç›‘æ§ï¼šè¿ç»­æœªä¸­å¥–å·²å¢åŠ åˆ°${streak}æœŸï¼ˆè¿ç»­æœŸå·åˆå¹¶ä¸º1æœŸï¼‰ï¼Œå·²è§¦å‘æç¤ºéŸ³`);
        playRule3MonitorSound();
        if (typeof showAutoDrawMessage === 'function') {
            showAutoDrawMessage(`âš ï¸ è§„åˆ™3ç›‘æ§ï¼šè¿ç»­æœªä¸­å¥– ${streak} æœŸï¼ˆè¿ç»­æœŸå·åˆå¹¶ä¸º1æœŸï¼‰`);
        }
    }

    monitorRule3LastStreak = streak;
}

function trendSetSource(source) {
    trendSource = source;
    const fileInput = document.getElementById('trendFileInput');
    if (!fileInput) return;
    if (source === 'file') {
        fileInput.style.display = 'inline-block';
    } else {
        fileInput.style.display = 'none';
    }
}

function trendImportFromFile() {
    if (trendSource !== 'file') {
        alert('è¯·å…ˆé€‰æ‹©"æ–‡ä»¶å¯¼å…¥"ä½œä¸ºæ•°æ®æ¥æºï¼Œå†ç‚¹å‡»å¯¼å…¥æ–‡ä»¶æ•°æ®');
        return;
    }
    const fileInput = document.getElementById('trendFileInput');
    if (!fileInput) {
        alert('æ‰¾ä¸åˆ°æ–‡ä»¶é€‰æ‹©æ§ä»¶');
        return;
    }
    fileInput.click();
}

function trendHandleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = trendParseFileData(e.target.result, file.name);
            if (!data || !data.length) {
                alert('æ— æ³•è§£ææ–‡ä»¶æ•°æ®ï¼Œè¯·æ£€æŸ¥æ ¼å¼ï¼ˆæœŸå· + 10ä¸ªä½ç½®ï¼‰');
                return;
            }
            trendAllData = data;
            trendCurrentPage = 1;
            trendUpdatePageSize();
            trendShowDataPreview();
            document.getElementById('trendBox').style.display = 'block';
            alert(`å·²ä»æ–‡ä»¶å¯¼å…¥ ${trendAllData.length} æœŸæ•°æ®ï¼Œå¯ç›´æ¥ç‚¹å‡»"ç”Ÿæˆèµ°åŠ¿å›¾"æŸ¥çœ‹`);
        } catch (err) {
            alert('æ–‡ä»¶è§£æå¤±è´¥ï¼š' + err.message);
            console.error(err);
        }
    };
    if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
        reader.readAsArrayBuffer(file);
    } else {
        reader.readAsText(file);
    }
}

function trendParseFileData(content, fileName) {
    const results = [];
    if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
        const workbook = XLSX.read(content, { type: 'array' });
        const sheet = workbook.Sheets[workbook.SheetNames[0]];
        const json = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        for (let i = 1; i < json.length; i++) {
            const row = json[i];
            if (!row || row.length < 2) continue;
            const issue = String(row[0] || '').trim();
            if (!issue) continue;
            const obj = { issue };
            const startIndex = row.length >= 12 ? 2 : 1;
            for (let p = 1; p <= 10; p++) {
                const idx = startIndex + (p - 1);
                const val = row[idx];
                if (val === null || typeof val === 'undefined' || val === '') {
                    obj['p' + p] = null;
                } else {
                    const num = parseInt(val, 10);
                    obj['p' + p] = isNaN(num) ? null : num;
                }
            }
            let hasData = false;
            for (let p = 1; p <= 10; p++) {
                if (obj['p' + p] !== null) { hasData = true; break; }
            }
            if (hasData) results.push(obj);
        }
    } else {
        const lines = content.split(/\r?\n/);
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line || line.startsWith('#')) continue;
            const parts = line.split(/[,\t]/);
            if (parts.length < 2) continue;
            const issue = (parts[0] || '').trim();
            if (!issue) continue;
            const obj = { issue };
            const startIndex = parts.length >= 12 ? 2 : 1;
            for (let p = 1; p <= 10; p++) {
                const idx = startIndex + (p - 1);
                const v = parts[idx];
                if (typeof v === 'undefined' || v === null || v.trim() === '') {
                    obj['p' + p] = null;
                } else {
                    const num = parseInt(v.trim(), 10);
                    obj['p' + p] = isNaN(num) ? null : num;
                }
            }
            let hasData = false;
            for (let p = 1; p <= 10; p++) {
                if (obj['p' + p] !== null) { hasData = true; break; }
            }
            if (hasData) results.push(obj);
        }
    }
    return results;
}

function loadBatchIntoTrend() {
    if (!window.batchAllResults || window.batchAllResults.length === 0) {
        alert('è¯·å…ˆå®Œæˆæ‰¹é‡æŸ¥è¯¢ï¼Œå†åŠ è½½æ‰¹é‡ç»“æœç”Ÿæˆèµ°åŠ¿å›¾');
        return;
    }
    const sorted = window.batchAllResults.slice().sort((a, b) => {
        if (a.date !== b.date) return a.date < b.date ? -1 : 1;
        return a.phase - b.phase;
    });
    trendAllData = sorted.map(item => {
        const row = { 
            issue: item.phaseFormat || (item.date + 'ç¬¬' + item.phase + 'æœŸ'),
            timestamp: item.timestamp || Date.now()
        };
        if (Array.isArray(item.result) && item.result.length >= 10) {
            for (let i = 0; i < 10; i++) {
                const num = parseInt(item.result[i], 10);
                row['p' + (i + 1)] = isNaN(num) ? null : num;
            }
        } else {
            for (let i = 1; i <= 10; i++) row['p' + i] = null;
        }
        return row;
    });
    trendCurrentPage = 1;
    trendUpdatePageSize();
    trendShowDataPreview();
    document.getElementById('trendBox').style.display = 'block';
    alert(`å·²ä»æ‰¹é‡ç»“æœåŠ è½½ ${trendAllData.length} æœŸæ•°æ®åˆ°èµ°åŠ¿å›¾æ¨¡å—`);
}

function trendUpdatePageSize() {
    const sel = document.getElementById('trendPageSizeSelect');
    if (sel) {
        const v = parseInt(sel.value, 10);
        trendPageSize = isNaN(v) ? 100 : v;
    }
}

function trendGetCurrentPageData() {
    const sortedDesc = trendAllData.slice().sort((a, b) => {
        const ai = isNaN(a.issue) ? a.issue : Number(a.issue);
        const bi = isNaN(b.issue) ? b.issue : Number(b.issue);
        if (ai < bi) return 1;
        if (ai > bi) return -1;
        return 0;
    });
    const start = (trendCurrentPage - 1) * trendPageSize;
    const end = start + trendPageSize;
    return sortedDesc.slice(start, end);
}

function generateTrendChart() {
    if (!trendAllData.length) {
        alert('è¯·å…ˆç‚¹å‡»"ä»æ‰¹é‡ç»“æœåŠ è½½æ•°æ®"æˆ–"å¯¼å…¥æ–‡ä»¶æ•°æ®"');
        return;
    }

    trendUpdatePageSize();
    trendTotalPages = Math.ceil(trendAllData.length / trendPageSize);
    if (trendTotalPages < 1) trendTotalPages = 1;
    if (trendCurrentPage > trendTotalPages) trendCurrentPage = trendTotalPages;
    if (trendCurrentPage < 1) trendCurrentPage = 1;

    const rows = trendGetCurrentPageData();
    const tablesDiv = document.getElementById('trendTables');
    tablesDiv.innerHTML = '';

    const chartType = document.getElementById('trendChartTypeSelect').value;
    const displayMode = document.getElementById('trendDisplayModeSelect').value;

    let positions = [];
    if (displayMode === 'top3') {
        positions = ['p1','p2','p3'];
    } else if (displayMode === 'top5') {
        positions = ['p1','p2','p3','p4','p5'];
    } else {
        positions = ['p1','p2','p3','p4','p5','p6','p7','p8','p9','p10'];
    }

    const names = {
        p1:'ç¬¬ä¸€å', p2:'ç¬¬äºŒå', p3:'ç¬¬ä¸‰å', p4:'ç¬¬å››å', p5:'ç¬¬äº”å',
        p6:'ç¬¬å…­å', p7:'ç¬¬ä¸ƒå', p8:'ç¬¬å…«å', p9:'ç¬¬ä¹å', p10:'ç¬¬åå'
    };
    const colors = {
        p1:'#ff4d4d', p2:'#4d7fff', p3:'#4dff7f', p4:'#ffcc4d', p5:'#cc4dff',
        p6:'#ffa07a', p7:'#7fffd4', p8:'#87cefa', p9:'#da70d6', p10:'#ffa500'
    };

    let title = '';
    if (chartType === 'basic')      title = 'åå¤§åæ¬¡åŸºæœ¬èµ°åŠ¿å›¾';
    else if (chartType === 'trend') title = 'åå¤§åæ¬¡è¶‹åŠ¿åˆ†æå›¾ï¼ˆå¸¦è¿çº¿ï¼‰';
    else if (chartType === 'miss')  title = 'åå¤§åæ¬¡é—æ¼èµ°åŠ¿å›¾ï¼ˆæ•°å­—ä¸ºé—æ¼å€¼ï¼‰';

    const firstIssue = rows.length ? rows[rows.length - 1].issue : '';
    const lastIssue  = rows.length ? rows[0].issue : '';
    document.getElementById('trendTitle').textContent =
        `${title}ï¼ˆ${firstIssue} ~ ${lastIssue} å…± ${rows.length} æœŸï¼‰`;

    const combinedContainer = document.createElement('div');
    combinedContainer.className = 'trend-combined-container';

    const sortedAsc = rows.slice().sort((a, b) => {
        const ai = isNaN(a.issue) ? a.issue : Number(a.issue);
        const bi = isNaN(b.issue) ? b.issue : Number(b.issue);
        if (ai < bi) return -1;
        if (ai > bi) return 1;
        return 0;
    });

    positions.forEach((pos, idx) => {
        const posIndex = idx + 1;
        const wrapper = document.createElement('div');
        wrapper.className = 'trend-combined-wrapper';
        wrapper.setAttribute('data-pos', String(posIndex));

        let html = `<table class="trend-table"><thead>`;
        html += `<tr><th rowspan="2">æœŸå·</th>`;
        html += `<th rowspan="2">å¼€å¥–å·ç </th>`;
        html += `<th colspan="10">${names[pos]}</th></tr>`;
        html += `<tr>`;
        for (let i = 1; i <= 10; i++) html += `<th>${i}</th>`;
        html += `</tr></thead><tbody>`;

        const missForEachNumber = Array(11).fill(null).map(() => []);
        for (let d = 1; d <= 10; d++) {
            let miss = 0;
            for (let i = 0; i < sortedAsc.length; i++) {
                const raw = sortedAsc[i][pos];
                const val = (raw === null || raw === '' || typeof raw === 'undefined')
                    ? null : parseInt(raw, 10);
                if (val === d) miss = 0; else miss++;
                missForEachNumber[d][i] = miss;
            }
        }

        const rowsDesc = rows.slice().sort((a, b) => {
            const ai = isNaN(a.issue) ? a.issue : Number(a.issue);
            const bi = isNaN(b.issue) ? b.issue : Number(b.issue);
            if (ai < bi) return 1;
            if (ai > bi) return -1;
            return 0;
        });
        const missReversed = Array(11).fill(null).map(() => []);
        for (let d = 1; d <= 10; d++) {
            missReversed[d] = [...missForEachNumber[d]].reverse();
        }

        rowsDesc.forEach((r, rowIndex) => {
            const nums = [];
            for (let p = 1; p <= 10; p++) {
                const v = r['p' + p];
                // ä½¿ç”¨ä¸¤ä½æ˜¾ç¤ºï¼ˆå¦‚ 05ï¼‰ï¼Œç¼ºå¤±æ˜¾ç¤ºä¸º '--'
                nums.push(v == null || v === '' ? '--' : String(v).padStart(2, '0'));
            }

            // æ„å»ºå½©è‰²æ–¹å—çš„ HTMLï¼ˆæ¯ä¸ªæ•°å­—ä¸€ä¸ªè‰²å—ï¼Œé¢œè‰²æŒ‰æ•°å­—ä¸€è‡´ï¼‰
            let blocksHtml = '<div class="lottery-block-container">';
            for (let i = 0; i < 10; i++) {
                const display = nums[i];
                if (display === '--') {
                    blocksHtml += `<div class="lottery-block num-empty">-</div>`;
                } else {
                    const numVal = parseInt(display, 10);
                    const cls = (numVal >= 1 && numVal <= 10) ? `num-${numVal}` : 'num-empty';
                    blocksHtml += `<div class="lottery-block ${cls}">${display}</div>`;
                }
            }
            blocksHtml += '</div>';
            html += `<tr><td>${r.issue}</td><td class="trend-lottery-num">${blocksHtml}</td>`;

            const rawVal = r[pos];
            const val = (rawVal === null || rawVal === '' || typeof rawVal === 'undefined')
                ? null : parseInt(rawVal, 10);

            for (let d = 1; d <= 10; d++) {
                if (chartType === 'miss') {
                    const missVal = (missReversed[d] && missReversed[d][rowIndex] !== undefined)
                        ? missReversed[d][rowIndex] : '';
                    html += `<td class="tmiss">${missVal}</td>`;
                } else {
                    if (val === d) {
                        html += `<td><div class="tpos-${posIndex}">${d}</div></td>`;
                    } else {
                        const missVal = (missReversed[d] && missReversed[d][rowIndex] !== undefined)
                            ? missReversed[d][rowIndex] : '';
                        html += `<td class="tmiss">${missVal}</td>`;
                    }
                }
            }
            html += `</tr>`;
        });

        html += `</tbody></table>`;
        wrapper.innerHTML = html;
        combinedContainer.appendChild(wrapper);
    });

    tablesDiv.appendChild(combinedContainer);
    trendUpdatePageInfo();
    document.getElementById('trendPaginationControls').style.display =
        trendTotalPages > 1 ? 'flex' : 'none';

    trendCalculateStatistics(rows);
    trendDisplayStatistics();
    trendShowDataPreview();

    if (chartType === 'basic' || chartType === 'trend') {
        setTimeout(() => {
            trendDrawLines(positions, colors, combinedContainer);
        }, 60);
    }
    
    // æ ‡è®°èµ°åŠ¿å›¾å·²ç”Ÿæˆ
    isTrendChartGenerated = true;
    
    // åˆ·æ–°æŠ•æ³¨è®°å½•æ˜¾ç¤º
    refreshBettingRecords();
    
    // å¦‚æœè‡ªåŠ¨å¼€å¥–å¼€å…³æ˜¯æ‰“å¼€çš„ï¼Œå¯ç”¨èµ°åŠ¿å›¾è‡ªåŠ¨æ›´æ–°
    if (isAutoDrawRunning) {
        enableTrendAutoUpdate();
    }
}

function trendDrawLines(positions, colors, combinedContainer) {
    positions.forEach((pos, idx) => {
        const posIndex = idx + 1;
        const wrapper = combinedContainer.children[idx];
        const table = wrapper.querySelector('table.trend-table');
        if (!table) return;

        let svg = wrapper.querySelector('svg');
        if (svg) svg.remove();

        const tableRect = table.getBoundingClientRect();
        const wrapperRect = wrapper.getBoundingClientRect();

        svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.classList.add('trend-svg');
        svg.setAttribute('width', tableRect.width);
        svg.setAttribute('height', tableRect.height);
        svg.style.top = (tableRect.top - wrapperRect.top) + 'px';
        svg.style.left = '0px';
        wrapper.appendChild(svg);

        const centers = [];
        const trs = table.querySelectorAll('tbody tr');
        trs.forEach(tr => {
            const dot = tr.querySelector('td div.tpos-' + posIndex);
            if (dot) {
                const r = dot.getBoundingClientRect();
                const x = r.left - tableRect.left + r.width / 2;
                const y = r.top  - tableRect.top  + r.height / 2;
                centers.push({x, y});
            }
        });

        const color = colors[pos];
        for (let i = 0; i < centers.length - 1; i++) {
            const a = centers[i];
            const b = centers[i + 1];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 10) continue; // è‡³å°‘éœ€è¦10pxæ‰èƒ½ç¼©çŸ­ä¸¤ç«¯å„4px

            // è®¡ç®—æ–¹å‘å•ä½å‘é‡
            const unitX = dx / dist;
            const unitY = dy / dist;
            
            // èµ·ç‚¹å‘å‰ç§»åŠ¨4pxï¼Œç»ˆç‚¹å‘åç§»åŠ¨4px
            const x1 = a.x + unitX * 4;
            const y1 = a.y + unitY * 4;
            const x2 = b.x - unitX * 4;
            const y2 = b.y - unitY * 4;

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', color);
            line.setAttribute('stroke-width', '2');
            line.setAttribute('stroke-opacity', '0.6');
            svg.appendChild(line);
        }
    });
}

function trendUpdatePageInfo() {
    const info = document.getElementById('trendPageInfo');
    if (!info) return;
    const start = (trendCurrentPage - 1) * trendPageSize + 1;
    const end = Math.min(trendCurrentPage * trendPageSize, trendAllData.length);
    info.textContent = `ç¬¬ ${trendCurrentPage} é¡µ / å…± ${trendTotalPages} é¡µ (æ˜¾ç¤ºç¬¬ ${start}-${end} æœŸ)`;
}
function trendFirstPage() { trendCurrentPage = 1; generateTrendChart(); }
function trendPrevPage()  { if (trendCurrentPage > 1) { trendCurrentPage--; generateTrendChart(); } }
function trendNextPage()  { if (trendCurrentPage < trendTotalPages) { trendCurrentPage++; generateTrendChart(); } }
function trendLastPage()  { trendCurrentPage = trendTotalPages; generateTrendChart(); }
function trendJumpToPage() {
    const input = document.getElementById('trendJumpToPage');
    const p = parseInt(input.value, 10);
    if (isNaN(p) || p < 1 || p > trendTotalPages) {
        alert(`è¯·è¾“å…¥æœ‰æ•ˆçš„é¡µç ï¼ˆ1-${trendTotalPages}ï¼‰`);
        input.value = trendCurrentPage;
        return;
    }
    trendCurrentPage = p;
    generateTrendChart();
}

function trendCalculateStatistics(data) {
    if (!data || !data.length) { trendStats = null; return; }
    const positionStats = {};
    for (let pos = 1; pos <= 10; pos++) {
        positionStats[pos] = { counts: Array(10).fill(0), total: 0 };
    }
    data.forEach(row => {
        for (let pos = 1; pos <= 10; pos++) {
            const raw = row['p' + pos];
            if (raw !== null && raw !== undefined && raw !== '') {
                const num = parseInt(raw, 10);
                if (!isNaN(num) && num >= 1 && num <= 10) {
                    positionStats[pos].counts[num - 1]++;
                    positionStats[pos].total++;
                }
            }
        }
    });
    const hotNumbers = {};
    const coldNumbers = {};
    for (let pos = 1; pos <= 10; pos++) {
        const s = positionStats[pos];
        if (!s.total) continue;
        const avg = s.total / 10;
        hotNumbers[pos] = [];
        coldNumbers[pos] = [];
        for (let num = 1; num <= 10; num++) {
            const c = s.counts[num - 1];
            if (c > avg * 1.5) hotNumbers[pos].push(num);
            if (c < avg * 0.5) coldNumbers[pos].push(num);
        }
    }
    trendStats = { totalItems: data.length, positionStats, hotNumbers, coldNumbers };
}

function trendDisplayStatistics() {
    const panel = document.getElementById('trendStatsPanel');
    if (!trendStats || !panel) {
        if (panel) panel.style.display = 'none';
        return;
    }
    const s = trendStats;
    let html = '';
    html += `<div class="stat-item">
        <div class="stat-label">åˆ†ææœŸæ•°</div>
        <div class="stat-value">${s.totalItems}</div>
    </div>`;
    for (let pos = 1; pos <= 3; pos++) {
        const hotCount  = s.hotNumbers[pos]  ? s.hotNumbers[pos].length  : 0;
        const coldCount = s.coldNumbers[pos]? s.coldNumbers[pos].length : 0;
        html += `<div class="stat-item">
            <div class="stat-label">ç¬¬${pos}åçƒ­å·</div>
            <div class="stat-value">${hotCount}ä¸ª</div>
        </div>`;
        html += `<div class="stat-item">
            <div class="stat-label">ç¬¬${pos}åå†·å·</div>
            <div class="stat-value">${coldCount}ä¸ª</div>
        </div>`;
    }
    let validPos = 0;
    for (let pos = 1; pos <= 10; pos++) {
        if (s.positionStats[pos] && s.positionStats[pos].total > 0) validPos++;
    }
    html += `<div class="stat-item">
        <div class="stat-label">æ•°æ®å®Œæ•´æ€§</div>
        <div class="stat-value">${validPos}/10</div>
    </div>`;
    panel.innerHTML = html;
    panel.style.display = 'grid';
}

function trendShowDataPreview() {
    const box = document.getElementById('trendDataPreview');
    const content = document.getElementById('trendPreviewContent');
    if (!box || !content) return;
    if (!trendAllData.length) {
        box.style.display = 'none';
        return;
    }
    const sortedDesc = trendAllData.slice().sort((a, b) => {
        const ai = isNaN(a.issue) ? a.issue : Number(a.issue);
        const bi = isNaN(b.issue) ? b.issue : Number(b.issue);
        if (ai < bi) return 1;
        if (ai > bi) return -1;
        return 0;
    }).slice(0, 10);
    let html = '';
    sortedDesc.forEach(row => {
        const nums = [];
        for (let p = 1; p <= 10; p++) {
            const v = row['p' + p];
            nums.push(v == null || v === '' ? '--' : v.toString().padStart(2,'0'));
        }
        html += `<div class="data-row">${row.issue}: ${nums.join(' ')}</div>`;
    });
    content.innerHTML = html;
    box.style.display = 'block';
}

function exportTrendToExcel() {
    if (!trendAllData.length) {
        alert('æ²¡æœ‰èµ°åŠ¿å›¾æ•°æ®å¯å¯¼å‡ºï¼Œè¯·å…ˆåŠ è½½æ•°æ®å¹¶ç”Ÿæˆèµ°åŠ¿å›¾');
        return;
    }
    try {
        const wb = XLSX.utils.book_new();

        // å¯¼å‡ºä¸º 12 åˆ—ï¼šæœŸå· | å¼€å¥–å·ç  | ç¬¬1å | ç¬¬2å | ... | ç¬¬10å
        const wsData = [];
        const header = ['æœŸå·', 'å¼€å¥–å·ç '];
        for (let p = 1; p <= 10; p++) header.push(`ç¬¬${p}å`);
        wsData.push(header);

        trendAllData.forEach(r => {
            const row = [];
            row.push(r.issue);

            const nums = [];
            for (let p = 1; p <= 10; p++) {
                const v = r['p' + p];
                nums.push(v == null || v === '' ? '--' : String(v).padStart(2, '0'));
            }

            // ç¬¬äºŒåˆ—ï¼šå¼€å¥–å·ç ï¼ˆæ‹¼æ¥ï¼‰
            row.push(nums.join(''));

            // ç¬¬3~12åˆ—ï¼šç¬¬1å~ç¬¬10å
            for (let p = 0; p < 10; p++) {
                row.push(nums[p]);
            }

            wsData.push(row);
        });

        const ws = XLSX.utils.aoa_to_sheet(wsData);
        XLSX.utils.book_append_sheet(wb, ws, 'å¼€å¥–æ•°æ®');

        const name = `æ³¢åœº30ç§’èµ›è½¦èµ°åŠ¿å›¾_${new Date().toISOString().slice(0,10)}.xlsx`;
        XLSX.writeFile(wb, name);
        alert(`æ•°æ®å·²å¯¼å‡ºä¸º ${name}`);
    } catch (e) {
        alert('å¯¼å‡ºå¤±è´¥ï¼š' + e.message);
        console.error(e);
    }
}

// æ³¨æ„ï¼šclearTrendData() å‡½æ•°å·²åœ¨ä¸Šé¢å®šä¹‰ä¸ºå¼‚æ­¥å‡½æ•°ï¼ŒåŒ…å«å®Œæ•´çš„æ¸…ç©ºé€»è¾‘
// æ­¤å¤„çš„æ—§å‡½æ•°å·²åˆ é™¤ï¼Œé¿å…å‡½æ•°é‡å¤å®šä¹‰

// ================== PK10å‰ä¸‰ç›´é€‰å•å¼ç”Ÿæˆå™¨ï¼ˆå¯ç¼–ç¨‹è°ƒç”¨ç‰ˆæœ¬ï¼‰==================
const BETTING_STORE_KEY = 'betting_records';
const MAX_BETTING_RECORDS = 50;

// PK10ç”Ÿæˆå™¨æ ¸å¿ƒå‡½æ•°ï¼ˆå¯ç¼–ç¨‹è°ƒç”¨ï¼‰
function pk10GenerateScheme(enabledPositions, excludeDigits, excludeRules) {
    // enabledPositions: ['w','q','b'] æˆ–å…¶ä¸­éƒ¨åˆ†
    // excludeDigits: {w: [1,2], q: [3], b: []}
    // excludeRules: {pair: true, triple: true, quad: false, quint: false}
    
    if (!enabledPositions || enabledPositions.length === 0) {
        return [];
    }
    
    const excludeNums = {};
    ['w','q','b'].forEach(p => {
        excludeNums[p] = new Set(excludeDigits[p] || []);
    });
    
    const results = [];
    
    function dfs(idx, arr) {
        if (idx === enabledPositions.length) {
            const digits = arr.slice();
            const counts = {};
            digits.forEach(d => counts[d] = (counts[d] || 0) + 1);
            const maxC = Math.max(...Object.values(counts));
            
            if (excludeRules.pair && maxC >= 2) return;
            if (excludeRules.triple && maxC >= 3) return;
            if (excludeRules.quad && maxC >= 4) return;
            if (excludeRules.quint && maxC >= 5) return;
            
            results.push(digits.map(v => String(v).padStart(2, '0')).join(' '));
            return;
        }
        
        const p = enabledPositions[idx];
        for (let v = 1; v <= 10; v++) {
            if (excludeNums[p].has(v)) continue;
            dfs(idx + 1, arr.concat([v]));
        }
    }
    
    dfs(0, []);
    return results;
}

// ================== é—æ¼æ•°è®¡ç®— ==================
// ç›´æ¥å¼•ç”¨èµ°åŠ¿å›¾é»˜è®¤çš„æ¯é¡µæ˜¾ç¤ºæœŸæ•°ï¼ˆ100æœŸï¼‰é—æ¼æ¡†é‡Œé¢çš„æ•°å­—
function calculateMissCounts(position, dataArray, limit = 100) {
    // position: 1-3 (ç¬¬1åã€ç¬¬2åã€ç¬¬3å)
    // dataArray: trendAllDataæ•°ç»„ï¼ˆå·²æŒ‰æœŸå·å‡åºæ’åºï¼Œæœ€æ—§çš„åœ¨å‰ï¼‰
    // limit: ä½¿ç”¨èµ°åŠ¿å›¾é»˜è®¤çš„æ¯é¡µæ˜¾ç¤ºæœŸæ•°ï¼ˆ100æœŸï¼‰
    
    // è·å–å½“å‰é¡µçš„æ•°æ®ï¼ˆä½¿ç”¨èµ°åŠ¿å›¾çš„é€»è¾‘ï¼‰
    const pageSize = trendPageSize || 100; // é»˜è®¤100æœŸ
    const sortedDesc = dataArray.slice().sort((a, b) => {
        const ai = isNaN(a.issue) ? a.issue : Number(a.issue);
        const bi = isNaN(b.issue) ? b.issue : Number(b.issue);
        if (ai < bi) return 1;
        if (ai > bi) return -1;
        return 0;
    });
    
    // å–å½“å‰é¡µçš„æ•°æ®ï¼ˆæœ€æ–°çš„ä¸€é¡µï¼Œæœ€å¤špageSizeæœŸï¼‰
    const rows = sortedDesc.slice(0, pageSize);
    
    // æŒ‰æœŸå·å‡åºæ’åºï¼ˆç”¨äºè®¡ç®—é—æ¼å€¼ï¼Œå’Œèµ°åŠ¿å›¾é€»è¾‘ä¸€è‡´ï¼‰
    const sortedAsc = rows.slice().sort((a, b) => {
        const ai = isNaN(a.issue) ? a.issue : Number(a.issue);
        const bi = isNaN(b.issue) ? b.issue : Number(b.issue);
        if (ai < bi) return -1;
        if (ai > bi) return 1;
        return 0;
    });
    
    // ä½¿ç”¨å’Œèµ°åŠ¿å›¾ç›¸åŒçš„é—æ¼å€¼è®¡ç®—é€»è¾‘
    const missForEachNumber = Array(11).fill(null).map(() => []);
    for (let d = 1; d <= 10; d++) {
        let miss = 0;
        for (let i = 0; i < sortedAsc.length; i++) {
            const raw = sortedAsc[i]['p' + position];
            const val = (raw === null || raw === '' || typeof raw === 'undefined')
                ? null : parseInt(raw, 10);
            if (val === d) miss = 0; else miss++;
            missForEachNumber[d][i] = miss;
        }
    }
    
    // åè½¬æ•°ç»„ï¼ˆå’Œèµ°åŠ¿å›¾é€»è¾‘ä¸€è‡´ï¼Œæœ€æ–°ä¸€æœŸåœ¨ç´¢å¼•0ï¼‰
    const missReversed = Array(11).fill(null).map(() => []);
    for (let d = 1; d <= 10; d++) {
        missReversed[d] = [...missForEachNumber[d]].reverse();
    }
    
    // è·å–æœ€æ–°ä¸€æœŸï¼ˆç¬¬ä¸€è¡Œï¼‰çš„é—æ¼å€¼
    const missCounts = {}; // {æ•°å­—: é—æ¼æ•°}
    for (let d = 1; d <= 10; d++) {
        // missReversed[d][0] å°±æ˜¯æœ€æ–°ä¸€æœŸçš„é—æ¼å€¼
        const missVal = (missReversed[d] && missReversed[d][0] !== undefined)
            ? missReversed[d][0] : sortedAsc.length;
        missCounts[d] = missVal;
    }
    
    return missCounts;
}

// è·å–é—æ¼æ•°ç¬¬ä¸€çš„æ•°å­—ï¼ˆå¯èƒ½æœ‰å¤šä¸ªï¼‰
function getTopMissNumbers(missCounts, rank = 1) {
    const sorted = Object.entries(missCounts)
        .map(([num, miss]) => ({ num: parseInt(num), miss }))
        .sort((a, b) => b.miss - a.miss);
    
    if (rank === 1) {
        const maxMiss = sorted[0].miss;
        return sorted.filter(item => item.miss === maxMiss).map(item => item.num);
    } else if (rank === 2) {
        if (sorted.length < 2) return [];
        const firstMiss = sorted[0].miss;
        const secondMiss = sorted.find(item => item.miss < firstMiss)?.miss;
        if (secondMiss === undefined) return [];
        return sorted.filter(item => item.miss === secondMiss).map(item => item.num);
    }
    
    return [];
}

// æ ¹æ®é—æ¼æ•°é€‰æ‹©è§„åˆ™ï¼Œé€‰æ‹©éœ€è¦æ’é™¤çš„æ•°å­—
// è¿”å›ä¸€ä¸ªæ•°ç»„ï¼ŒåŒ…å«éœ€è¦æ’é™¤çš„æ•°å­—ï¼ˆæœ€å¤š2ä¸ªï¼‰
function selectMissNumbersForExclude(top1Miss, top2Miss) {
    const result = [];
    
    // æƒ…å†µ1ï¼šé—æ¼æ•°ç¬¬ä¸€æœ‰2ä¸ªæ•°å­— - åŒæ—¶é€‰æ‹©è¿™2ä¸ªæ•°å­—æ’é™¤
    if (top1Miss.length === 2) {
        result.push(...top1Miss);
    }
    // æƒ…å†µ2ï¼šé—æ¼æ•°ç¬¬ä¸€æœ‰3ä¸ªæˆ–ä»¥ä¸Š - éšæœºé€‰æ‹©2ä¸ªæ•°å­—æ’é™¤
    else if (top1Miss.length >= 3) {
        const shuffled = [...top1Miss].sort(() => Math.random() - 0.5);
        result.push(...shuffled.slice(0, 2));
    }
    // æƒ…å†µ3ï¼šé—æ¼æ•°ç¬¬ä¸€æœ‰1ä¸ªæ•°å­—ï¼Œé—æ¼æ•°ç¬¬äºŒæœ‰1ä¸ªæ•°å­— - å„é€‰æ‹©1ä¸ªæ•°å­—æ’é™¤
    else if (top1Miss.length === 1 && top2Miss.length === 1) {
        result.push(top1Miss[0]);
        result.push(top2Miss[0]);
    }
    // æƒ…å†µ4ï¼šé—æ¼æ•°ç¬¬ä¸€æœ‰1ä¸ªæ•°å­—ï¼Œé—æ¼æ•°ç¬¬äºŒæœ‰2ä¸ªæˆ–ä»¥ä¸Šçš„æ•°å­— - é—æ¼æ•°ç¬¬ä¸€é€‰æ‹©1ä¸ªæ•°å­—æ’é™¤ï¼Œé—æ¼æ•°ç¬¬äºŒéšæœºé€‰æ‹©1ä¸ªæ•°å­—æ’é™¤
    else if (top1Miss.length === 1 && top2Miss.length >= 2) {
        result.push(top1Miss[0]);
        const randomIndex = Math.floor(Math.random() * top2Miss.length);
        result.push(top2Miss[randomIndex]);
    }
    // å…¶ä»–æƒ…å†µï¼šå¦‚æœé—æ¼æ•°ç¬¬ä¸€æœ‰1ä¸ªæ•°å­—ï¼Œä½†é—æ¼æ•°ç¬¬äºŒä¸ºç©ºï¼Œåªé€‰æ‹©é—æ¼æ•°ç¬¬ä¸€çš„1ä¸ª
    else if (top1Miss.length === 1) {
        result.push(top1Miss[0]);
    }
    
    return result;
}

// ================== åˆ‡æ¢ä¸‹æ³¨è§„åˆ™ ==================
function switchBettingRule(rule) {
    currentBettingRule = rule;
    const rule1Btn = document.getElementById('rule1Btn');
    const rule2Btn = document.getElementById('rule2Btn');
    const rule3Btn = document.getElementById('rule3Btn');
    
    const setActive = (btn, active) => {
        if (!btn) return;
        if (active) {
            btn.className = 'success';
            btn.style.background = '#27ae60';
        } else {
            btn.className = '';
            btn.style.background = '#95a5a6';
        }
    };
    
    setActive(rule1Btn, rule === 1);
    setActive(rule2Btn, rule === 2);
    setActive(rule3Btn, rule === 3);
    
    // åˆ‡æ¢åˆ°è§„åˆ™3æ—¶ï¼šé‡ç½®ç›‘æ§åŸºçº¿ï¼Œé¿å…ä¸€åˆ‡æ¢å°±å¯¹å†å²æ•°æ®æŠ¥è­¦
    if (rule === 3) {
        try {
            monitorRule3LastStreak = computeRule3LossStreakFromLocalRecords();
        } catch (e) {
            monitorRule3LastStreak = null;
        }
    }

    console.log(`å·²åˆ‡æ¢åˆ°è§„åˆ™${rule}`);
}

// ================== è‡ªåŠ¨ç›‘æ§å’Œä¸‹æ³¨é€»è¾‘ ==================
function checkAutoBettingConditions() {
    if (!trendAllData || trendAllData.length < 3) {
        return; // æ•°æ®ä¸è¶³ï¼Œä¸è¿›è¡Œç›‘æ§
    }
    
    // æŒ‰æœŸå·å‡åºæ’åºï¼ˆæœ€æ—§çš„åœ¨å‰ï¼‰
    const sortedData = trendAllData.slice().sort((a, b) => {
        const ai = isNaN(a.issue) ? a.issue : Number(a.issue);
        const bi = isNaN(b.issue) ? b.issue : Number(b.issue);
        if (ai < bi) return -1;
        if (ai > bi) return 1;
        return 0;
    });
    
    // æ£€æŸ¥æœ€è¿‘3æœŸï¼ˆæœŸå·å‡åºï¼‰
    if (sortedData.length < 3) return;
    
    const last3 = sortedData.slice(-3);
    
    // æ ¹æ®å½“å‰è§„åˆ™æ£€æŸ¥è§¦å‘æ¡ä»¶
    const triggers = [];
    
    if (currentBettingRule === 1) {
        // è§„åˆ™1ï¼šæ£€æŸ¥ç¬¬1åã€ç¬¬2åã€ç¬¬3åæ˜¯å¦æœ‰è¿ç»­ä¸‰æœŸåŒä¸€æ•°å­—
        for (let pos = 1; pos <= 3; pos++) {
            const nums = last3.map(item => item['p' + pos]);
            
            // æ£€æŸ¥æ˜¯å¦è¿ç»­ä¸‰æœŸéƒ½æ˜¯åŒä¸€ä¸ªæ•°å­—
            if (nums[0] !== null && nums[0] === nums[1] && nums[1] === nums[2]) {
                triggers.push({
                    position: pos,
                    number: nums[0],
                    last3Issues: last3.map(item => item.issue)
                });
            }
        }
        
        // å¦‚æœæœ‰è§¦å‘æ¡ä»¶ï¼Œæ‰§è¡Œä¸‹æ³¨ï¼ˆè§„åˆ™1ï¼‰
        if (triggers.length > 0) {
            triggers.forEach(async trigger => {
                await executeAutoBetting(trigger, sortedData);
            });
        }
    } else if (currentBettingRule === 2) {
        // è§„åˆ™2ï¼šåªæ£€æŸ¥ç¬¬1åæˆ–ç¬¬2åæ˜¯å¦æœ‰è¿ç»­ä¸‰æœŸåŒä¸€æ•°å­—
        for (let pos = 1; pos <= 2; pos++) {
            const nums = last3.map(item => item['p' + pos]);
            
            // æ£€æŸ¥æ˜¯å¦è¿ç»­ä¸‰æœŸéƒ½æ˜¯åŒä¸€ä¸ªæ•°å­—
            if (nums[0] !== null && nums[0] === nums[1] && nums[1] === nums[2]) {
                triggers.push({
                    position: pos,
                    number: nums[0],
                    last3Issues: last3.map(item => item.issue)
                });
            }
        }
        
        // å¦‚æœæœ‰è§¦å‘æ¡ä»¶ï¼Œæ‰§è¡Œä¸‹æ³¨ï¼ˆè§„åˆ™2ï¼‰
        if (triggers.length > 0) {
            triggers.forEach(async trigger => {
                await executeAutoBettingRule2(trigger, sortedData);
            });
        }
    } else if (currentBettingRule === 3) {
        // è§„åˆ™3ï¼šç›‘æ§ç¬¬1åæˆ–ç¬¬2åæ˜¯å¦æœ‰è¿ç»­ä¸‰æœŸåŒä¸€æ•°å­—
        for (let pos = 1; pos <= 2; pos++) {
            const nums = last3.map(item => item['p' + pos]);
            
            if (nums[0] !== null && nums[0] === nums[1] && nums[1] === nums[2]) {
                triggers.push({
                    position: pos,
                    number: nums[0],
                    last3Issues: last3.map(item => item.issue)
                });
            }
        }
        
        if (triggers.length > 0) {
            triggers.forEach(async trigger => {
                await executeAutoBettingRule3(trigger, sortedData);
            });
        }
    }
}

// æ‰§è¡Œè‡ªåŠ¨ä¸‹æ³¨
async function executeAutoBetting(trigger, sortedData) {
    const { position, number, last3Issues } = trigger;
    
    // æ ¹æ®è§„åˆ™é€‰æ‹©æ’é™¤æ•°å­—
    let enabledPositions = [];
    let excludeDigits = { w: [], q: [], b: [] };
    
    if (position === 1) {
        // ç¬¬1åè¿ç»­ä¸‰æœŸåŒä¸€æ•°å­—
        enabledPositions = ['w', 'q'];
        
        // è®¡ç®—ç¬¬1åçš„è¿‘100æœŸé—æ¼æ•°
        const missCounts1 = calculateMissCounts(1, sortedData, 100);
        const top1Miss1 = getTopMissNumbers(missCounts1, 1);
        const top2Miss1 = getTopMissNumbers(missCounts1, 2);
        
        // è®¡ç®—ç¬¬2åçš„è¿‘100æœŸé—æ¼æ•°
        const missCounts2 = calculateMissCounts(2, sortedData, 100);
        const top1Miss2 = getTopMissNumbers(missCounts2, 1);
        const top2Miss2 = getTopMissNumbers(missCounts2, 2);
        
        // ç¬¬1åæ’é™¤ï¼šè¿ç»­ä¸‰æœŸçš„æ•°å­— + é—æ¼æ•°ç¬¬ä¸€çš„1ä¸ª + é—æ¼æ•°ç¬¬äºŒçš„1ä¸ªï¼ˆå…±3ä¸ªï¼‰
        excludeDigits.w.push(number);
        const missNums1 = selectMissNumbersForExclude(top1Miss1, top2Miss1);
        excludeDigits.w.push(...missNums1);
        
        // ç¬¬2åæ’é™¤ï¼šé—æ¼æ•°ç¬¬ä¸€çš„1ä¸ª + é—æ¼æ•°ç¬¬äºŒçš„1ä¸ªï¼ˆå…±2ä¸ªï¼‰
        const missNums2 = selectMissNumbersForExclude(top1Miss2, top2Miss2);
        excludeDigits.q.push(...missNums2);
        
    } else if (position === 2) {
        // ç¬¬2åè¿ç»­ä¸‰æœŸåŒä¸€æ•°å­—
        enabledPositions = ['w', 'q'];
        
        // è®¡ç®—ç¬¬1åçš„è¿‘100æœŸé—æ¼æ•°
        const missCounts1 = calculateMissCounts(1, sortedData, 100);
        const top1Miss1 = getTopMissNumbers(missCounts1, 1);
        const top2Miss1 = getTopMissNumbers(missCounts1, 2);
        
        // è®¡ç®—ç¬¬2åçš„è¿‘100æœŸé—æ¼æ•°
        const missCounts2 = calculateMissCounts(2, sortedData, 100);
        const top1Miss2 = getTopMissNumbers(missCounts2, 1);
        const top2Miss2 = getTopMissNumbers(missCounts2, 2);
        
        // ç¬¬1åæ’é™¤ï¼šé—æ¼æ•°ç¬¬ä¸€çš„1ä¸ª + é—æ¼æ•°ç¬¬äºŒçš„1ä¸ªï¼ˆå…±2ä¸ªï¼‰
        const missNums1 = selectMissNumbersForExclude(top1Miss1, top2Miss1);
        excludeDigits.w.push(...missNums1);
        
        // ç¬¬2åæ’é™¤ï¼šè¿ç»­ä¸‰æœŸçš„æ•°å­— + é—æ¼æ•°ç¬¬ä¸€çš„1ä¸ª + é—æ¼æ•°ç¬¬äºŒçš„1ä¸ªï¼ˆå…±3ä¸ªï¼‰
        excludeDigits.q.push(number);
        const missNums2 = selectMissNumbersForExclude(top1Miss2, top2Miss2);
        excludeDigits.q.push(...missNums2);
        
    } else if (position === 3) {
        // ç¬¬3åè¿ç»­ä¸‰æœŸåŒä¸€æ•°å­—
        enabledPositions = ['w', 'q', 'b'];
        
        // è®¡ç®—ç¬¬1åçš„è¿‘100æœŸé—æ¼æ•°
        const missCounts1 = calculateMissCounts(1, sortedData, 100);
        const top1Miss1 = getTopMissNumbers(missCounts1, 1);
        const top2Miss1 = getTopMissNumbers(missCounts1, 2);
        
        // è®¡ç®—ç¬¬2åçš„è¿‘100æœŸé—æ¼æ•°
        const missCounts2 = calculateMissCounts(2, sortedData, 100);
        const top1Miss2 = getTopMissNumbers(missCounts2, 1);
        const top2Miss2 = getTopMissNumbers(missCounts2, 2);
        
        // è®¡ç®—ç¬¬3åçš„è¿‘100æœŸé—æ¼æ•°
        const missCounts3 = calculateMissCounts(3, sortedData, 100);
        const top1Miss3 = getTopMissNumbers(missCounts3, 1);
        const top2Miss3 = getTopMissNumbers(missCounts3, 2);
        
        // ç¬¬1åæ’é™¤ï¼šé—æ¼æ•°ç¬¬ä¸€çš„1ä¸ª + é—æ¼æ•°ç¬¬äºŒçš„1ä¸ªï¼ˆå…±2ä¸ªï¼‰
        const missNums1 = selectMissNumbersForExclude(top1Miss1, top2Miss1);
        excludeDigits.w.push(...missNums1);
        
        // ç¬¬2åæ’é™¤ï¼šé—æ¼æ•°ç¬¬ä¸€çš„1ä¸ª + é—æ¼æ•°ç¬¬äºŒçš„1ä¸ªï¼ˆå…±2ä¸ªï¼‰
        const missNums2 = selectMissNumbersForExclude(top1Miss2, top2Miss2);
        excludeDigits.q.push(...missNums2);
        
        // ç¬¬3åæ’é™¤ï¼šè¿ç»­ä¸‰æœŸçš„æ•°å­— + é—æ¼æ•°ç¬¬ä¸€çš„1ä¸ª + é—æ¼æ•°ç¬¬äºŒçš„1ä¸ªï¼ˆå…±3ä¸ªï¼‰
        excludeDigits.b.push(number);
        const missNums3 = selectMissNumbersForExclude(top1Miss3, top2Miss3);
        excludeDigits.b.push(...missNums3);
    }
    
    // å»é‡
    excludeDigits.w = [...new Set(excludeDigits.w)];
    excludeDigits.q = [...new Set(excludeDigits.q)];
    excludeDigits.b = [...new Set(excludeDigits.b)];
    
    // ç”Ÿæˆæ–¹æ¡ˆ
    const excludeRules = { pair: true, triple: true, quad: false, quint: false };
    const schemes = pk10GenerateScheme(enabledPositions, excludeDigits, excludeRules);
    
    if (schemes.length > 0) {
        // è®°å½•æŠ•æ³¨
        const nextIssue = getNextIssue(sortedData);
        recordBetting({
            rule: 'è§„åˆ™1',
            triggerPosition: position,
            triggerNumber: number,
            triggerIssues: last3Issues,
            nextIssue: nextIssue,
            enabledPositions: enabledPositions,
            excludeDigits: excludeDigits,
            schemes: schemes,
            timestamp: Date.now()
        });
        
        // æ˜¾ç¤ºæ–¹æ¡ˆåˆ°æ˜¾ç¤ºæ¡†
        displayAutoScheme(schemes, position, number, nextIssue, excludeDigits, enabledPositions);
        
        // æ˜¾ç¤ºé€šçŸ¥
        showAutoBettingNotification(position, number, schemes.length, nextIssue);
    }
}

// æ‰§è¡Œè‡ªåŠ¨ä¸‹æ³¨ï¼ˆè§„åˆ™2ï¼‰
async function executeAutoBettingRule2(trigger, sortedData) {
    const { position, number, last3Issues } = trigger;
    
    // è§„åˆ™2ï¼šåªå¤„ç†ç¬¬1åæˆ–ç¬¬2å
    if (position !== 1 && position !== 2) {
        return;
    }
    
    // è·å–æœ€è¿‘ä¸€æœŸçš„æ•°æ®ï¼ˆç”¨äºæ’é™¤æ•°å­—ï¼‰
    const lastIssue = sortedData[sortedData.length - 1];
    if (!lastIssue) return;
    
    // æ ¹æ®è§„åˆ™é€‰æ‹©æ’é™¤æ•°å­—
    let enabledPositions = ['w', 'q'];
    let excludeDigits = { w: [], q: [], b: [] };
    
    // è·å–å½“æœŸç¬¬ä¸€åå’Œç¬¬äºŒåå‡ºç°è¿‡çš„æ•°å­—
    const currentFirst = lastIssue.p1;
    const currentSecond = lastIssue.p2;
    
    // æ’é™¤å½“æœŸç¬¬ä¸€åå’Œç¬¬äºŒåå‡ºç°è¿‡çš„2ä¸ªæ•°å­—
    const excludeNums = [];
    if (currentFirst !== null && currentFirst !== undefined) {
        excludeNums.push(currentFirst);
    }
    if (currentSecond !== null && currentSecond !== undefined) {
        excludeNums.push(currentSecond);
    }
    
    // å»é‡
    const uniqueExcludeNums = [...new Set(excludeNums)];
    
    // å¦‚æœä¸è¶³2ä¸ªæ•°å­—ï¼Œå°è¯•ä»å…¶ä»–ä½ç½®è·å–
    if (uniqueExcludeNums.length < 2 && sortedData.length > 0) {
        // å¦‚æœåªæœ‰1ä¸ªæ•°å­—ï¼Œå¯ä»¥å†æ·»åŠ ä¸€ä¸ªï¼ˆæ¯”å¦‚ä»ç¬¬ä¸‰åï¼‰
        if (uniqueExcludeNums.length === 1 && lastIssue.p3 !== null && lastIssue.p3 !== undefined) {
            uniqueExcludeNums.push(lastIssue.p3);
        }
    }
    
    // ç¡®ä¿è‡³å°‘æœ‰2ä¸ªæ•°å­—ç”¨äºæ’é™¤ï¼ˆå¦‚æœæ•°æ®ä¸è¶³ï¼Œåˆ™ä½¿ç”¨å·²æœ‰çš„ï¼‰
    const finalExcludeNums = uniqueExcludeNums.slice(0, 2);
    
    // ç¬¬ä¸€åå’Œç¬¬äºŒåéƒ½æ’é™¤è¿™2ä¸ªæ•°å­—
    excludeDigits.w = [...finalExcludeNums];
    excludeDigits.q = [...finalExcludeNums];
    
    // å»é‡
    excludeDigits.w = [...new Set(excludeDigits.w)];
    excludeDigits.q = [...new Set(excludeDigits.q)];
    
    // ç”Ÿæˆæ–¹æ¡ˆ
    const excludeRules = { pair: true, triple: true, quad: false, quint: false };
    const schemes = pk10GenerateScheme(enabledPositions, excludeDigits, excludeRules);
    
    if (schemes.length > 0) {
        // è®°å½•æŠ•æ³¨
        const nextIssue = getNextIssue(sortedData);
        recordBetting({
            rule: 'è§„åˆ™2',
            triggerPosition: position,
            triggerNumber: number,
            triggerIssues: last3Issues,
            nextIssue: nextIssue,
            enabledPositions: enabledPositions,
            excludeDigits: excludeDigits,
            schemes: schemes,
            timestamp: Date.now()
        });
        
        // æ˜¾ç¤ºæ–¹æ¡ˆåˆ°æ˜¾ç¤ºæ¡†
        displayAutoScheme(schemes, position, number, nextIssue, excludeDigits, enabledPositions);
        
        // æ˜¾ç¤ºé€šçŸ¥
        showAutoBettingNotification(position, number, schemes.length, nextIssue);
    }
}

// æ‰§è¡Œè‡ªåŠ¨ä¸‹æ³¨ï¼ˆè§„åˆ™3ï¼‰
async function executeAutoBettingRule3(trigger, sortedData) {
    const { position, number, last3Issues } = trigger;
    
    // è§„åˆ™3ï¼šåªå¤„ç†ç¬¬1åæˆ–ç¬¬2å
    if (position !== 1 && position !== 2) {
        return;
    }
    
    // è·å–æœ€è¿‘ä¸€æœŸçš„æ•°æ®ï¼ˆç”¨äºæ’é™¤æ•°å­—ï¼‰
    const lastIssue = sortedData[sortedData.length - 1];
    if (!lastIssue) return;
    
    const currentFirst = lastIssue.p1;
    const currentSecond = lastIssue.p2;
    
    // å½“æœŸç¬¬ä¸€åå’Œç¬¬äºŒåå‡ºç°è¿‡çš„æ•°å­—
    const baseExclude = [];
    if (currentFirst !== null && currentFirst !== undefined) baseExclude.push(currentFirst);
    if (currentSecond !== null && currentSecond !== undefined) baseExclude.push(currentSecond);
    const uniqueBaseExclude = [...new Set(baseExclude)];
    
    // åˆå§‹æ’é™¤ï¼šä¸¤åéƒ½æ’é™¤å½“æœŸç¬¬ä¸€åå’Œç¬¬äºŒåå‡ºç°è¿‡çš„2ä¸ªæ•°å­—
    const enabledPositions = ['w', 'q']; // åªä¸‹æ³¨ç¬¬ä¸€åå’Œç¬¬äºŒå
    const excludeDigits = { w: [...uniqueBaseExclude], q: [...uniqueBaseExclude], b: [] };
    
    // è®¡ç®—é—æ¼æ•°ï¼ˆæ’é™¤å½“æœŸç¬¬ä¸€ã€äºŒåå‡ºç°è¿‡çš„æ•°å­—ï¼‰
    const bannedSet = new Set(uniqueBaseExclude);
    const missCounts1 = calculateMissCounts(1, sortedData, 100);
    const missCounts2 = calculateMissCounts(2, sortedData, 100);
    
    // é€‰æ‹©æœ€å¤§é—æ¼æ•°ï¼ˆæ’é™¤å½“å‰ä¸¤ä½å‡ºç°è¿‡çš„æ•°å­—ï¼‰ï¼Œè‹¥å¹¶åˆ—éšæœºå–1ä¸ª
    const pickMaxMissNumber = (missCounts) => {
        const entries = Object.entries(missCounts)
            .map(([num, miss]) => ({ num: parseInt(num, 10), miss }))
            .filter(item => !bannedSet.has(item.num));
        if (!entries.length) return null;
        const maxMiss = Math.max(...entries.map(e => e.miss));
        const candidates = entries.filter(e => e.miss === maxMiss).map(e => e.num);
        const chosen = candidates.length === 1 ? candidates[0] : candidates[Math.floor(Math.random() * candidates.length)];
        return { num: chosen, miss: maxMiss };
    };
    
    const extra1 = pickMaxMissNumber(missCounts1);
    const extra2 = pickMaxMissNumber(missCounts2);
    
    // åœ¨ç¬¬ä¸€åå’Œç¬¬äºŒåä¹‹é—´é€‰é—æ¼æ•°æ›´å¤§çš„1ä¸ªæ•°å­—ï¼Œå¤šé‡å¹¶åˆ—æ—¶éšæœº
    let targetPos = null;
    let extraNumber = null;
    if (extra1 && extra2) {
        if (extra1.miss > extra2.miss) {
            targetPos = 'w';
            extraNumber = extra1.num;
        } else if (extra2.miss > extra1.miss) {
            targetPos = 'q';
            extraNumber = extra2.num;
        } else {
            const pick = Math.random() < 0.5 ? 'w' : 'q';
            targetPos = pick;
            extraNumber = pick === 'w' ? extra1.num : extra2.num;
        }
    } else if (extra1) {
        targetPos = 'w';
        extraNumber = extra1.num;
    } else if (extra2) {
        targetPos = 'q';
        extraNumber = extra2.num;
    }
    
    if (targetPos && extraNumber !== null && extraNumber !== undefined) {
        excludeDigits[targetPos].push(extraNumber);
    }
    
    // å»é‡
    excludeDigits.w = [...new Set(excludeDigits.w)];
    excludeDigits.q = [...new Set(excludeDigits.q)];
    
    // ç”Ÿæˆæ–¹æ¡ˆï¼ˆè§„åˆ™åŒè§„åˆ™2ï¼Œç¬¬ä¸‰åä¸å‚ä¸ï¼‰
    const excludeRules = { pair: true, triple: true, quad: false, quint: false };
    const schemes = pk10GenerateScheme(enabledPositions, excludeDigits, excludeRules);
    
    if (schemes.length > 0) {
        // è®°å½•æŠ•æ³¨
        const nextIssue = getNextIssue(sortedData);
        recordBetting({
            rule: 'è§„åˆ™3',
            triggerPosition: position,
            triggerNumber: number,
            triggerIssues: last3Issues,
            nextIssue: nextIssue,
            enabledPositions: enabledPositions,
            excludeDigits: excludeDigits,
            schemes: schemes,
            timestamp: Date.now()
        });
        
        // æ˜¾ç¤ºæ–¹æ¡ˆåˆ°æ˜¾ç¤ºæ¡†
        displayAutoScheme(schemes, position, number, nextIssue, excludeDigits, enabledPositions);
        
        // æ˜¾ç¤ºé€šçŸ¥
        showAutoBettingNotification(position, number, schemes.length, nextIssue);
    }
}

// è·å–ä¸‹ä¸€æœŸæœŸå·
function getNextIssue(sortedData) {
    if (sortedData.length === 0) return 'æœªçŸ¥';
    const lastIssue = sortedData[sortedData.length - 1].issue;
    
    // å¤„ç†æœŸå·æ ¼å¼ï¼šYYYYMMDD0001ï¼ˆ12ä½ï¼‰æˆ–ç®€å•æ•°å­—
    if (typeof lastIssue === 'string' && lastIssue.length >= 12) {
        // æœŸå·æ ¼å¼ï¼šYYYYMMDD0001
        const dateStr = lastIssue.substring(0, 8); // YYYYMMDD
        const phaseStr = lastIssue.substring(8); // 0001-2880
        const phase = parseInt(phaseStr, 10);
        
        if (!isNaN(phase)) {
            let nextDate = dateStr;
            let nextPhase = phase + 1;
            
            // å¤„ç†è·¨å¤©ï¼šç¬¬2880æœŸçš„ä¸‹ä¸€æœŸæ˜¯ç¬¬äºŒå¤©çš„ç¬¬1æœŸ
            if (nextPhase > PHASES_PER_DAY) {
                // æ—¥æœŸåŠ ä¸€å¤©
                const year = parseInt(dateStr.substring(0, 4), 10);
                const month = parseInt(dateStr.substring(4, 6), 10) - 1; // æœˆä»½ä»0å¼€å§‹
                const day = parseInt(dateStr.substring(6, 8), 10);
                const date = new Date(year, month, day);
                date.setDate(date.getDate() + 1);
                
                const nextYear = date.getFullYear();
                const nextMonth = String(date.getMonth() + 1).padStart(2, '0');
                const nextDay = String(date.getDate()).padStart(2, '0');
                nextDate = `${nextYear}${nextMonth}${nextDay}`;
                nextPhase = 1;
            }
            
            // é‡æ–°ç»„åˆæœŸå·
            const nextPhaseStr = String(nextPhase).padStart(4, '0');
            return `${nextDate}${nextPhaseStr}`;
        }
    } else if (!isNaN(lastIssue)) {
        // ç®€å•æ•°å­—æ ¼å¼ï¼šç›´æ¥åŠ 1ï¼ˆå…¼å®¹æ—§æ•°æ®ï¼‰
        const phase = Number(lastIssue);
        if (phase >= PHASES_PER_DAY) {
            // è·¨å¤©ï¼šè¿”å›ç¬¬äºŒå¤©çš„ç¬¬1æœŸï¼ˆéœ€è¦çŸ¥é“æ—¥æœŸï¼Œè¿™é‡Œè¿”å›1ä½œä¸ºæœŸå·ï¼‰
            return '1';
        }
        return String(phase + 1);
    }
    
    return 'æœªçŸ¥';
}

// æ’­æ”¾å£°éŸ³æç¤ºï¼ˆè¿ç»­8æ¬¡ï¼‰
function playBettingSound() {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const playBeep = (delay) => {
            setTimeout(() => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                // è®¾ç½®éŸ³è°ƒï¼ˆ800Hzï¼Œæ¯”è¾ƒæ‚¦è€³ï¼‰
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                
                // è®¾ç½®éŸ³é‡æ›²çº¿ï¼ˆæ¸å…¥æ¸å‡ºï¼‰
                const currentTime = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, currentTime);
                gainNode.gain.linearRampToValueAtTime(0.3, currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.3);
                
                // è¿æ¥èŠ‚ç‚¹
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // æ’­æ”¾å£°éŸ³ï¼ˆ300æ¯«ç§’ï¼‰
                oscillator.start(currentTime);
                oscillator.stop(currentTime + 0.3);
            }, delay);
        };
        
        // è¿ç»­æ’­æ”¾8æ¬¡ï¼Œæ¯æ¬¡é—´éš”350æ¯«ç§’
        for (let i = 0; i < 8; i++) {
            playBeep(i * 350);
        }
    } catch (e) {
        console.log('å£°éŸ³æ’­æ”¾å¤±è´¥ï¼ˆå¯èƒ½éœ€è¦ç”¨æˆ·äº¤äº’åæ‰èƒ½æ’­æ”¾ï¼‰:', e);
    }
}

// æ˜¾ç¤ºè‡ªåŠ¨ä¸‹æ³¨é€šçŸ¥
function showAutoBettingNotification(position, number, schemeCount, nextIssue) {
    const positionNames = ['', 'ç¬¬1å', 'ç¬¬2å', 'ç¬¬3å'];
    const message = `è‡ªåŠ¨ä¸‹æ³¨è§¦å‘ï¼š${positionNames[position]}è¿ç»­ä¸‰æœŸå‡ºç°æ•°å­—${number}ï¼Œå·²ç”Ÿæˆ${schemeCount}ä¸ªæ–¹æ¡ˆï¼Œä¸‹æ³¨æœŸå·ï¼š${nextIssue}`;
    console.log(message);
    
    // æ’­æ”¾å£°éŸ³æç¤º
    playBettingSound();
    
    // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ UIé€šçŸ¥
    if (typeof showAutoDrawMessage === 'function') {
        showAutoDrawMessage(message);
    }
}

// æ˜¾ç¤ºè‡ªåŠ¨ç”Ÿæˆçš„æ–¹æ¡ˆåˆ°æ˜¾ç¤ºæ¡†
function displayAutoScheme(schemes, position, number, nextIssue, excludeDigits, enabledPositions) {
    const box = document.getElementById('autoSchemeBox');
    const textarea = document.getElementById('autoSchemeTextarea');
    const meta = document.getElementById('autoSchemeMeta');
    
    if (!box || !textarea || !meta) return;
    
    // æ˜¾ç¤ºæ–¹æ¡ˆæ¡†
    box.style.display = 'block';
    
    // å°†æ–¹æ¡ˆæ˜¾ç¤ºåˆ°æ–‡æœ¬æ¡†ï¼ˆæ›¿æ¢æ¨¡å¼ï¼Œä¸å åŠ ï¼Œä¸æ˜¾ç¤ºæ³¨é‡Šå¤´ï¼‰
    const schemeText = schemes.join('\n');
    
    // ç›´æ¥æ›¿æ¢å†…å®¹ï¼Œä¸è¿½åŠ ï¼Œä¸æ˜¾ç¤ºæ³¨é‡Šå¤´
    textarea.value = schemeText;
    
    // ç»Ÿè®¡å®é™…æ–¹æ¡ˆæ•°é‡ï¼ˆç›´æ¥ä½¿ç”¨schemesæ•°ç»„é•¿åº¦ï¼Œå› ä¸ºä¸å†æœ‰æ³¨é‡Šè¡Œï¼‰
    const schemeCount = schemes.length;
    
    // ç”Ÿæˆæ’é™¤æ•°å­—ä¿¡æ¯
    const excludeInfo = [];
    const posMap = { 'w': 'ç¬¬ä¸€å', 'q': 'ç¬¬äºŒå', 'b': 'ç¬¬ä¸‰å' };
    
    // æŒ‰ç…§enabledPositionsçš„é¡ºåºæ˜¾ç¤º
    enabledPositions.forEach(pos => {
        const posName = posMap[pos];
        const excludeNums = excludeDigits[pos] || [];
        if (excludeNums.length > 0) {
            // æ’åºå¹¶è½¬æ¢ä¸ºå­—ç¬¦ä¸²
            const sortedNums = excludeNums.slice().sort((a, b) => a - b);
            excludeInfo.push(`${posName}æ’é™¤${sortedNums.join('ã€')}`);
        }
    });
    
    // æ›´æ–°å…ƒä¿¡æ¯ï¼šæ˜¾ç¤ºæ–¹æ¡ˆæ•°é‡å’Œæ’é™¤æ•°å­—ä¿¡æ¯
    let metaText = `å…±${schemeCount}ä¸ªæ–¹æ¡ˆ`;
    if (excludeInfo.length > 0) {
        metaText += 'ï¼Œ' + excludeInfo.join('ï¼Œ');
    }
    meta.textContent = metaText;
    
    // è‡ªåŠ¨æ»šåŠ¨åˆ°é¡¶éƒ¨
    textarea.scrollTop = 0;
}

// å¤åˆ¶è‡ªåŠ¨ç”Ÿæˆçš„æ–¹æ¡ˆ
async function copyAutoScheme() {
    const textarea = document.getElementById('autoSchemeTextarea');
    if (!textarea || !textarea.value.trim()) {
        alert('å½“å‰æ²¡æœ‰æ–¹æ¡ˆå†…å®¹å¯å¤åˆ¶');
        return;
    }
    
    try {
        await navigator.clipboard.writeText(textarea.value);
        alert('æ–¹æ¡ˆå·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
    } catch (e) {
        // å›é€€æ–¹æ¡ˆ
        textarea.select();
        document.execCommand('copy');
        alert('æ–¹æ¡ˆå·²å¤åˆ¶ï¼ˆå›é€€æ–¹å¼ï¼‰');
    }
}

// æ¸…ç©ºè‡ªåŠ¨ç”Ÿæˆçš„æ–¹æ¡ˆ
function clearAutoScheme() {
    if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰è‡ªåŠ¨ç”Ÿæˆçš„æ–¹æ¡ˆå—ï¼Ÿ')) {
        const textarea = document.getElementById('autoSchemeTextarea');
        const meta = document.getElementById('autoSchemeMeta');
        if (textarea) textarea.value = '';
        if (meta) meta.textContent = '';
    }
}

// ================== æŠ•æ³¨è®°å½•ç®¡ç† ==================
function recordBetting(bettingData) {
    // ä¿å­˜åˆ°localStorageï¼ˆä¸é™åˆ¶æ¡æ•°ï¼‰ï¼Œä¸ä¿å­˜åˆ°IndexedDB
    // IndexedDBåªä¿å­˜å·²ç¡®å®šå¼€å¥–ç»“æœå’ŒçŠ¶æ€çš„è®°å½•
    const records = getBettingRecords();
    records.unshift(bettingData);

    localStorage.setItem(BETTING_STORE_KEY, JSON.stringify(records));
}

// ä¿å­˜æŠ•æ³¨è®°å½•åˆ°IndexedDBï¼ˆåªä¿å­˜å·²ç¡®å®šå¼€å¥–ç»“æœå’ŒçŠ¶æ€çš„è®°å½•ï¼‰
async function saveBettingRecordToDB(bettingData) {
    return new Promise((resolve, reject) => {
        if (!db) {
            resolve(); // æ•°æ®åº“æœªåˆå§‹åŒ–æ—¶ï¼Œè·³è¿‡
            return;
        }
        
        // åªä¿å­˜å·²ç¡®å®šå¼€å¥–ç»“æœå’ŒçŠ¶æ€çš„è®°å½•
        if (!bettingData.checked || bettingData.isWin === null || bettingData.isWin === undefined) {
            resolve(); // æœªå¼€å¥–çš„è®°å½•ä¸ä¿å­˜åˆ°IndexedDB
            return;
        }
        
        try {
            const transaction = db.transaction([STORE_BETTING], "readwrite");
            const store = transaction.objectStore(STORE_BETTING);
            
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆé€šè¿‡nextIssueå’Œtimestampåˆ¤æ–­ï¼‰
            const index = store.index("nextIssue");
            const getRequest = index.get(bettingData.nextIssue);
            
            getRequest.onsuccess = function() {
                const existingRecord = getRequest.result;
                
                if (existingRecord) {
                    // å¦‚æœå·²å­˜åœ¨ï¼Œæ›´æ–°è®°å½•
                    const recordToUpdate = {
                        ...bettingData,
                        id: existingRecord.id, // ä¿ç•™åŸæœ‰çš„id
                        timestamp: bettingData.timestamp || Date.now()
                    };
                    
                    const putRequest = store.put(recordToUpdate);
                    putRequest.onsuccess = function() {
                        console.log("æ›´æ–°æŠ•æ³¨è®°å½•åˆ°IndexedDB:", bettingData.nextIssue);
                        resolve();
                    };
                    putRequest.onerror = function(event) {
                        console.error("æ›´æ–°æŠ•æ³¨è®°å½•åˆ°IndexedDBå¤±è´¥:", event.target.error);
                        reject(event.target.error);
                    };
                } else {
                    // å¦‚æœä¸å­˜åœ¨ï¼Œæ·»åŠ æ–°è®°å½•
                    const recordToSave = {
                        ...bettingData,
                        timestamp: bettingData.timestamp || Date.now()
                    };
                    
                    const addRequest = store.add(recordToSave);
                    addRequest.onsuccess = function() {
                        console.log("ä¿å­˜æŠ•æ³¨è®°å½•åˆ°IndexedDB:", bettingData.nextIssue);
                        resolve();
                    };
                    addRequest.onerror = function(event) {
                        console.error("ä¿å­˜æŠ•æ³¨è®°å½•åˆ°IndexedDBå¤±è´¥:", event.target.error);
                        reject(event.target.error);
                    };
                }
            };
            
            getRequest.onerror = function(event) {
                console.error("æŸ¥è¯¢æŠ•æ³¨è®°å½•å¤±è´¥:", event.target.error);
                // å¦‚æœæŸ¥è¯¢å¤±è´¥ï¼Œå°è¯•ç›´æ¥æ·»åŠ 
                try {
                    const recordToSave = {
                        ...bettingData,
                        timestamp: bettingData.timestamp || Date.now()
                    };
                    const addRequest = store.add(recordToSave);
                    addRequest.onsuccess = () => resolve();
                    addRequest.onerror = (e) => {
                        console.error("ä¿å­˜æŠ•æ³¨è®°å½•åˆ°IndexedDBå¤±è´¥:", e.target.error);
                        resolve(); // å‡ºé”™æ—¶ä¸å½±å“ä¸»æµç¨‹
                    };
                } catch (error) {
                    console.error("ä¿å­˜æŠ•æ³¨è®°å½•åˆ°IndexedDBå¼‚å¸¸:", error);
                    resolve(); // å‡ºé”™æ—¶ä¸å½±å“ä¸»æµç¨‹
                }
            };
        } catch (error) {
            console.error("ä¿å­˜æŠ•æ³¨è®°å½•åˆ°IndexedDBå¼‚å¸¸:", error);
            resolve(); // å‡ºé”™æ—¶ä¸å½±å“ä¸»æµç¨‹
        }
    });
}

// ä»IndexedDBåŠ è½½æ‰€æœ‰æŠ•æ³¨è®°å½•
async function loadBettingRecordsFromDB() {
    return new Promise((resolve, reject) => {
        if (!db) {
            resolve([]);
            return;
        }
        
        const transaction = db.transaction([STORE_BETTING], "readonly");
        const store = transaction.objectStore(STORE_BETTING);
        const index = store.index("timestamp");
        const request = index.openCursor(null, "prev"); // æŒ‰æ—¶é—´å€’åº
        
        const records = [];
        
        request.onsuccess = function(event) {
            const cursor = event.target.result;
            if (cursor) {
                const record = cursor.value;
                delete record.id; // ç§»é™¤IndexedDBçš„idå­—æ®µ
                records.push(record);
                cursor.continue();
            } else {
                resolve(records);
            }
        };
        
        request.onerror = function(event) {
            reject(event.target.error);
        };
    });
}

function getBettingRecords() {
    try {
        return JSON.parse(localStorage.getItem(BETTING_STORE_KEY)) || [];
    } catch (e) {
        return [];
    }
}

// æ£€æŸ¥æŠ•æ³¨ç»“æœï¼ˆä¸å¼€å¥–ç»“æœå¯¹æ¯”ï¼‰
async function checkBettingResult(issue, result) {
    // result: {p1: 1, p2: 2, p3: 3, ...}
    const records = getBettingRecords();
    let hasUpdate = false;
    
    for (const record of records) {
        // åŒ¹é…æœŸå·ï¼ˆæ”¯æŒå­—ç¬¦ä¸²å’Œæ•°å­—æ¯”è¾ƒï¼‰
        const recordIssue = String(record.nextIssue);
        const currentIssue = String(issue);
        
        if (recordIssue === currentIssue && !record.checked) {
            // æ£€æŸ¥æ˜¯å¦ä¸­å¥–
            const isWin = checkSchemeWin(record.schemes, result, record.enabledPositions);
            
            record.checked = true;
            record.resultIssue = issue;
            record.result = JSON.parse(JSON.stringify(result)); // æ·±æ‹·è´
            record.isWin = isWin;
            record.checkTime = Date.now();
            hasUpdate = true;
            
            // ä¿å­˜åˆ°IndexedDBï¼ˆåªæœ‰ç¡®å®šäº†å¼€å¥–ç»“æœå’ŒçŠ¶æ€çš„è®°å½•æ‰ä¿å­˜ï¼‰
            await saveBettingRecordToDB(record);
            
            // è¾“å‡ºå¯¹æ¯”æ—¥å¿—
            console.log(`æŠ•æ³¨ç»“æœå¯¹æ¯” - æœŸå·ï¼š${issue}ï¼Œä¸­å¥–ï¼š${isWin ? 'æ˜¯' : 'å¦'}ï¼Œæ–¹æ¡ˆæ•°ï¼š${record.schemes.length}`);
        }
    }
    
    if (hasUpdate) {
        localStorage.setItem(BETTING_STORE_KEY, JSON.stringify(records));
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        updateDBStats();
    }
}

// æ­¤å‡½æ•°å·²ä¸å†ä½¿ç”¨ï¼Œä¿å­˜é€»è¾‘å·²åˆå¹¶åˆ°saveBettingRecordToDBä¸­

// æ£€æŸ¥æ–¹æ¡ˆæ˜¯å¦ä¸­å¥–
function checkSchemeWin(schemes, result, enabledPositions) {
    // schemes: ['01 02', '03 04', ...] æˆ– ['01 02 03', ...]
    // result: {p1: 1, p2: 2, p3: 3, ...}
    // enabledPositions: ['w','q','b']
    
    if (!schemes || schemes.length === 0) return false;
    if (!result || !enabledPositions || enabledPositions.length === 0) return false;
    
    const posMap = { 'w': 1, 'q': 2, 'b': 3 };
    const resultArray = enabledPositions.map(pos => {
        const posNum = posMap[pos];
        const num = result['p' + posNum];
        // å¦‚æœç»“æœä¸ºç©ºæˆ–æ— æ•ˆï¼Œè¿”å›null
        if (num === null || num === undefined || isNaN(num)) {
            return null;
        }
        return String(num).padStart(2, '0');
    });
    
    // å¦‚æœç»“æœä¸­æœ‰æ— æ•ˆå€¼ï¼Œæ— æ³•åˆ¤æ–­ä¸­å¥–
    if (resultArray.some(val => val === null)) {
        return false;
    }
    
    const resultStr = resultArray.join(' ');
    
    return schemes.includes(resultStr);
}

// åœ¨è‡ªåŠ¨å¼€å¥–æ›´æ–°æ—¶æ£€æŸ¥æŠ•æ³¨ç»“æœ
async function checkBettingResultsOnNewDraw(calcResult, phaseFormat) {
    const result = {};
    for (let i = 0; i < 10; i++) {
        const num = parseInt(calcResult.result[i], 10);
        result['p' + (i + 1)] = isNaN(num) ? null : num;
    }
    
    await checkBettingResult(phaseFormat, result);
    
    // åˆ·æ–°æŠ•æ³¨è®°å½•æ˜¾ç¤º
    refreshBettingRecords();

    // è§„åˆ™3ç›‘æ§ï¼šåœ¨â€œå¼€å¥–ç»“ç®—åâ€è§¦å‘ä¸€æ¬¡æ£€æŸ¥ï¼ˆå®æ—¶ï¼‰
    try {
        monitorRule3ConsecutiveLosses();
    } catch (e) {}
}

// ================== æŠ•æ³¨è®°å½•æ˜¾ç¤º ==================
async function refreshBettingRecords() {
    const records = getBettingRecords();
    const tableContent = document.getElementById('bettingRecordsTable');
    const statsContent = document.getElementById('bettingRecordsStats');
    const box = document.getElementById('bettingRecordsBox');
    
    if (!tableContent || !statsContent || !box) return;
    
    if (records.length === 0) {
        tableContent.innerHTML = '<p style="color:#999;">æš‚æ— æŠ•æ³¨è®°å½•</p>';
        statsContent.innerHTML = '';
        box.style.display = 'none';
        return;
    }
    
    box.style.display = 'block';
    
    // æ˜¾ç¤ºå…¨éƒ¨è®°å½•ï¼ˆä¸é™åˆ¶æ¡æ•°ï¼‰
    const displayRecords = records;
    
    // ç”Ÿæˆè¡¨æ ¼HTMLï¼ˆå¯æ»šåŠ¨åŒºåŸŸï¼‰
    let tableHtml = '<table style="width:100%; border-collapse:collapse;">';
    tableHtml += '<thead><tr>';
    tableHtml += '<th style="border:1px solid #ddd; padding:8px; background:#f8f9fa; position:sticky; top:0; z-index:10;">æœŸå·</th>';
    tableHtml += '<th style="border:1px solid #ddd; padding:8px; background:#f8f9fa; position:sticky; top:0; z-index:10;">è§¦å‘æ¡ä»¶</th>';
    tableHtml += '<th style="border:1px solid #ddd; padding:8px; background:#f8f9fa; position:sticky; top:0; z-index:10;">æ–¹æ¡ˆè§„åˆ™</th>';
    tableHtml += '<th style="border:1px solid #ddd; padding:8px; background:#f8f9fa; position:sticky; top:0; z-index:10;">æ–¹æ¡ˆæ•°</th>';
    tableHtml += '<th style="border:1px solid #ddd; padding:8px; background:#f8f9fa; position:sticky; top:0; z-index:10;">æ’é™¤é¡¹</th>';
    tableHtml += '<th style="border:1px solid #ddd; padding:8px; background:#f8f9fa; position:sticky; top:0; z-index:10;">å¼€å¥–ç»“æœ</th>';
    tableHtml += '<th style="border:1px solid #ddd; padding:8px; background:#f8f9fa; position:sticky; top:0; z-index:10;">ä¸­å¥–çŠ¶æ€</th>';
    tableHtml += '<th style="border:1px solid #ddd; padding:8px; background:#f8f9fa; position:sticky; top:0; z-index:10;">æ—¶é—´</th>';
    tableHtml += '</tr></thead><tbody>';
    
    displayRecords.forEach((record, index) => {
        const positionNames = ['', 'ç¬¬1å', 'ç¬¬2å', 'ç¬¬3å'];
        const triggerDesc = `${positionNames[record.triggerPosition]}è¿ç»­ä¸‰æœŸå‡ºç°æ•°å­—${record.triggerNumber}`;
        const timeStr = new Date(record.timestamp).toLocaleString('zh-CN');
        
        let resultStr = 'å¾…å¼€å¥–';
        let winStatus = '<span style="color:#999;">å¾…å¼€å¥–</span>';
        
        if (record.checked) {
            const resultNums = [];
            record.enabledPositions.forEach(pos => {
                const posMap = { 'w': 1, 'q': 2, 'b': 3 };
                const posNum = posMap[pos];
                const num = record.result['p' + posNum];
                resultNums.push(num != null ? String(num).padStart(2, '0') : '--');
            });
            resultStr = resultNums.join(' ');
            
            if (record.isWin) {
                winStatus = '<span style="color:#27ae60; font-weight:bold;">âœ“ ä¸­å¥–</span>';
            } else {
                winStatus = '<span style="color:#e74c3c;">âœ— æœªä¸­å¥–</span>';
            }
        }
        
        // ç”Ÿæˆæ’é™¤é¡¹ä¿¡æ¯
        const excludeInfo = [];
        const posMap = { 'w': 'ç¬¬ä¸€å', 'q': 'ç¬¬äºŒå', 'b': 'ç¬¬ä¸‰å' };
        if (record.enabledPositions && record.excludeDigits) {
            record.enabledPositions.forEach(pos => {
                const posName = posMap[pos];
                const excludeNums = record.excludeDigits[pos] || [];
                if (excludeNums.length > 0) {
                    // æ’åºå¹¶è½¬æ¢ä¸ºå­—ç¬¦ä¸²
                    const sortedNums = excludeNums.slice().sort((a, b) => a - b);
                    excludeInfo.push(`${posName}æ’é™¤${sortedNums.join('ã€')}`);
                }
            });
        }
        const excludeStr = excludeInfo.length > 0 ? excludeInfo.join('ï¼Œ') : 'æ— ';
        
        // è·å–æ–¹æ¡ˆè§„åˆ™ï¼ˆå…¼å®¹æ—§æ•°æ®ï¼Œé»˜è®¤ä¸º"è§„åˆ™1"ï¼‰
        const ruleStr = record.rule || 'è§„åˆ™1';
        
        tableHtml += '<tr>';
        tableHtml += `<td style="border:1px solid #ddd; padding:8px;">${record.nextIssue}</td>`;
        tableHtml += `<td style="border:1px solid #ddd; padding:8px;">${triggerDesc}</td>`;
        tableHtml += `<td style="border:1px solid #ddd; padding:8px;">${ruleStr}</td>`;
        tableHtml += `<td style="border:1px solid #ddd; padding:8px;">${record.schemes.length}</td>`;
        tableHtml += `<td style="border:1px solid #ddd; padding:8px; font-size:13px;">${excludeStr}</td>`;
        tableHtml += `<td style="border:1px solid #ddd; padding:8px;">${resultStr}</td>`;
        tableHtml += `<td style="border:1px solid #ddd; padding:8px;">${winStatus}</td>`;
        tableHtml += `<td style="border:1px solid #ddd; padding:8px; font-size:12px;">${timeStr}</td>`;
        tableHtml += '</tr>';
    });
    
    tableHtml += '</tbody></table>';
    tableContent.innerHTML = tableHtml;
    
    // ç”Ÿæˆç»Ÿè®¡ä¿¡æ¯HTMLï¼ˆå›ºå®šåŒºåŸŸï¼Œä¸æ»šåŠ¨ï¼‰
    let statsRecords = [];
    try {
        statsRecords = await loadBettingRecordsFromDB();
    } catch (e) {
        statsRecords = [];
    }
    // åˆå¹¶å½“å‰æœ¬åœ°æœ€è¿‘è®°å½•ï¼Œé¿å…é—æ¼æœªå…¥åº“çš„å¾…å¼€å¥–è®°å½•
    const statsMap = new Map();
    const addToStats = (arr) => {
        arr.forEach(r => {
            const key = `${r.nextIssue}_${r.timestamp || ''}`;
            if (!statsMap.has(key)) statsMap.set(key, r);
        });
    };
    addToStats(records);
    addToStats(statsRecords);
    const mergedStats = Array.from(statsMap.values());
    
    const checkedRecords = mergedStats.filter(r => r.checked);
    const winCount = checkedRecords.filter(r => r.isWin).length;
    const loseCount = checkedRecords.filter(r => !r.isWin).length;
    
    let statsHtml = `<strong>ç»Ÿè®¡ï¼ˆè¡¨æ ¼æ˜¾ç¤º${displayRecords.length}æ¡ï¼Œç»Ÿè®¡è¦†ç›–å…¨éƒ¨${mergedStats.length}æ¡ï¼‰ï¼š</strong>`;
    statsHtml += `æ€»æŠ•æ³¨ ${mergedStats.length} æœŸï¼Œå·²å¼€å¥– ${checkedRecords.length} æœŸï¼Œ`;
    statsHtml += `<span style="color:#27ae60;">ä¸­å¥– ${winCount} æœŸ</span>ï¼Œ`;
    statsHtml += `<span style="color:#e74c3c;">æœªä¸­å¥– ${loseCount} æœŸ</span>`;
    if (checkedRecords.length > 0) {
        const winRate = ((winCount / checkedRecords.length) * 100).toFixed(2);
        statsHtml += `ï¼Œä¸­å¥–ç‡ ${winRate}%`;
    }
    
    statsContent.innerHTML = statsHtml;

    // æ‰‹åŠ¨åˆ·æ–°/å…¶ä»–åˆ·æ–°åœºæ™¯ä¹Ÿè¡¥ä¸€æ¬¡ç›‘æ§ï¼ˆä¸ä¼šé‡å¤å“ï¼Œå†…éƒ¨åšäº†é˜ˆå€¼åˆ¤æ–­ï¼‰
    try {
        monitorRule3ConsecutiveLosses();
    } catch (e) {}
}

// NOTE: `clearBettingRecords` çš„å¼‚æ­¥å®ç°åœ¨æ–‡ä»¶ä¸Šæ–¹å·²å®šä¹‰å¹¶è´Ÿè´£åŒæ—¶æ¸…é™¤ IndexedDB å’Œ localStorageï¼Œ
// æ­¤å¤„ç§»é™¤æ—§çš„é‡å¤å®šä¹‰ä»¥é¿å…è¦†ç›–æ­£ç¡®å®ç°ã€‚

// åœ¨ç”Ÿæˆèµ°åŠ¿å›¾æ—¶æ˜¾ç¤ºæŠ•æ³¨è®°å½•ï¼ˆå·²åœ¨generateTrendChartå‡½æ•°æœ«å°¾è°ƒç”¨refreshBettingRecordsï¼‰

function showTrendHelp() {
    alert(`æ‰¹é‡ç»“æœèµ°åŠ¿å›¾ä½¿ç”¨è¯´æ˜ï¼š

1. å…ˆåœ¨é¡µé¢ä¸Šå®Œæˆ"æ‰¹é‡æŸ¥è¯¢"ï¼Œå¾—åˆ°ä¸€æ®µæ—¶é—´å†…çš„å¼€å¥–ç»“æœï¼Œæˆ–å‡†å¤‡å¥½Excel/CSVæ–‡ä»¶ã€‚
2. ç„¶åï¼š
   - è‹¥ä½¿ç”¨æ‰¹é‡ç»“æœï¼šé€‰æ‹©"æ‰¹é‡æŸ¥è¯¢ç»“æœ"ï¼Œç‚¹å‡»"ä»æ‰¹é‡ç»“æœåŠ è½½æ•°æ®"ï¼›
   - è‹¥ä½¿ç”¨æ–‡ä»¶ï¼šé€‰æ‹©"æ–‡ä»¶å¯¼å…¥"ï¼Œç‚¹å‡»"å¯¼å…¥æ–‡ä»¶æ•°æ®"å¹¶é€‰æ‹©æ–‡ä»¶ï¼›
   - è‹¥ä½¿ç”¨æ•°æ®åº“ï¼šé€‰æ‹©"æ•°æ®åº“åŠ è½½"ï¼Œç‚¹å‡»"ä»æ•°æ®åº“åŠ è½½èµ°åŠ¿å›¾"ã€‚
   - æ¥ç€é€‰æ‹©æ¯é¡µæœŸæ•° / èµ°åŠ¿å›¾ç±»å‹ / æ˜¾ç¤ºä½ç½®ï¼Œç‚¹å‡»"ç”Ÿæˆèµ°åŠ¿å›¾"ã€‚
3. æŒä¹…åŒ–å­˜å‚¨ï¼š
   - å¼€å¯"æŒä¹…åŒ–å­˜å‚¨"å¼€å…³åï¼Œæ•°æ®ä¼šè‡ªåŠ¨ä¿å­˜åˆ°IndexedDB
   - èµ°åŠ¿å›¾æ•°æ®å¯ä»¥æ‰‹åŠ¨ç‚¹å‡»"ğŸ’¾ ä¿å­˜åˆ°æ•°æ®åº“"æŒ‰é’®ä¿å­˜
   - æ•°æ®æ°¸ä¹…ä¿å­˜ï¼Œé¡µé¢åˆ·æ–°ã€å…³æœºåæ•°æ®ä»ç„¶å­˜åœ¨
4. è‡ªåŠ¨æ›´æ–°åŠŸèƒ½ï¼š
   - ç”Ÿæˆèµ°åŠ¿å›¾åï¼Œå¼€å¯"è‡ªåŠ¨å¼€å¥–å¼€å…³"ï¼Œæ–°å¼€å¥–æ•°æ®ä¼šè‡ªåŠ¨æ·»åŠ åˆ°èµ°åŠ¿å›¾ä¸­
   - å®æ—¶æ›´æ–°ï¼Œæ— éœ€æ‰‹åŠ¨åˆ·æ–°
   - å½“è‡ªåŠ¨å¼€å¥–å¼€å…³å…³é—­æ—¶ï¼Œèµ°åŠ¿å›¾åœæ­¢è‡ªåŠ¨æ›´æ–°
5. åŠŸèƒ½è¯´æ˜ï¼š
   - åŸºæœ¬èµ°åŠ¿å›¾ï¼šæ˜¾ç¤ºæ¯ä¸ªä½ç½®çš„å·ç å’Œé—æ¼ï¼›
   - è¶‹åŠ¿åˆ†æå›¾ï¼šåœ¨åŸºæœ¬èµ°åŠ¿å›¾åŸºç¡€ä¸Šç”»å‡ºè¿çº¿ï¼›
   - é—æ¼é‡ç‚¹å›¾ï¼šåªæ˜¾ç¤ºé—æ¼å€¼ï¼›
   - åˆ†é¡µæ§ä»¶ï¼šæµè§ˆå¤§é‡å†å²æœŸæ•°ï¼›
   - ç»Ÿè®¡é¢æ¿ï¼šæŸ¥çœ‹å‰å‡ åçš„çƒ­å·ã€å†·å·å’Œæ•°æ®å®Œæ•´æ€§ï¼›
   - å¯¼å‡ºä¸ºExcelï¼šå¯¼å‡ºå½“å‰å…¨éƒ¨èµ°åŠ¿å›¾æ•°æ®åŠç»Ÿè®¡æŠ¥å‘Šã€‚
6. æ³¨æ„ï¼šæ‰¹é‡ç»“æœæ¥æºæ˜¯æœ¬é¡µæ³¢åœº(TRON)çœŸå®åŒºå—æ•°æ®ï¼›æ–‡ä»¶å¯¼å…¥å¯ç”¨äºç¦»çº¿å†å²æ•°æ®åˆ†æã€‚`);
}
</script>
</body>
</html>
